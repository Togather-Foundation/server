
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Togather-Foundation/server/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/Togather-Foundation/server/internal/api/handlers/context.go (66.7%)</option>
				
				<option value="file2">github.com/Togather-Foundation/server/internal/api/handlers/events.go (44.7%)</option>
				
				<option value="file3">github.com/Togather-Foundation/server/internal/api/handlers/health.go (0.0%)</option>
				
				<option value="file4">github.com/Togather-Foundation/server/internal/api/handlers/organizations.go (70.3%)</option>
				
				<option value="file5">github.com/Togather-Foundation/server/internal/api/handlers/places.go (70.3%)</option>
				
				<option value="file6">github.com/Togather-Foundation/server/internal/api/middleware/auth_cookie.go (0.0%)</option>
				
				<option value="file7">github.com/Togather-Foundation/server/internal/api/middleware/idempotency.go (0.0%)</option>
				
				<option value="file8">github.com/Togather-Foundation/server/internal/api/middleware/logging.go (0.0%)</option>
				
				<option value="file9">github.com/Togather-Foundation/server/internal/api/middleware/negotiate.go (84.9%)</option>
				
				<option value="file10">github.com/Togather-Foundation/server/internal/api/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file11">github.com/Togather-Foundation/server/internal/api/openapi.go (0.0%)</option>
				
				<option value="file12">github.com/Togather-Foundation/server/internal/api/pagination/cursor.go (87.5%)</option>
				
				<option value="file13">github.com/Togather-Foundation/server/internal/api/problem/problem.go (53.8%)</option>
				
				<option value="file14">github.com/Togather-Foundation/server/internal/api/router.go (0.0%)</option>
				
				<option value="file15">github.com/Togather-Foundation/server/internal/auth/apikey.go (78.1%)</option>
				
				<option value="file16">github.com/Togather-Foundation/server/internal/auth/jwt.go (87.0%)</option>
				
				<option value="file17">github.com/Togather-Foundation/server/internal/auth/rbac.go (0.0%)</option>
				
				<option value="file18">github.com/Togather-Foundation/server/internal/config/config.go (0.0%)</option>
				
				<option value="file19">github.com/Togather-Foundation/server/internal/config/logging.go (0.0%)</option>
				
				<option value="file20">github.com/Togather-Foundation/server/internal/domain/events/dedup.go (0.0%)</option>
				
				<option value="file21">github.com/Togather-Foundation/server/internal/domain/events/ingest.go (0.0%)</option>
				
				<option value="file22">github.com/Togather-Foundation/server/internal/domain/events/normalize.go (0.0%)</option>
				
				<option value="file23">github.com/Togather-Foundation/server/internal/domain/events/service.go (91.4%)</option>
				
				<option value="file24">github.com/Togather-Foundation/server/internal/domain/events/validation.go (0.0%)</option>
				
				<option value="file25">github.com/Togather-Foundation/server/internal/domain/ids/ids.go (82.7%)</option>
				
				<option value="file26">github.com/Togather-Foundation/server/internal/domain/organizations/service.go (73.1%)</option>
				
				<option value="file27">github.com/Togather-Foundation/server/internal/domain/places/service.go (77.8%)</option>
				
				<option value="file28">github.com/Togather-Foundation/server/internal/domain/provenance/service.go (0.0%)</option>
				
				<option value="file29">github.com/Togather-Foundation/server/internal/jobs/alerts.go (0.0%)</option>
				
				<option value="file30">github.com/Togather-Foundation/server/internal/jobs/river.go (0.0%)</option>
				
				<option value="file31">github.com/Togather-Foundation/server/internal/jobs/workers.go (0.0%)</option>
				
				<option value="file32">github.com/Togather-Foundation/server/internal/jsonld/context.go (84.1%)</option>
				
				<option value="file33">github.com/Togather-Foundation/server/internal/jsonld/framing.go (90.9%)</option>
				
				<option value="file34">github.com/Togather-Foundation/server/internal/jsonld/serializer.go (81.0%)</option>
				
				<option value="file35">github.com/Togather-Foundation/server/internal/storage/postgres/auth_repository.go (0.0%)</option>
				
				<option value="file36">github.com/Togather-Foundation/server/internal/storage/postgres/db.go (0.0%)</option>
				
				<option value="file37">github.com/Togather-Foundation/server/internal/storage/postgres/events_repository.go (34.0%)</option>
				
				<option value="file38">github.com/Togather-Foundation/server/internal/storage/postgres/migrate.go (43.8%)</option>
				
				<option value="file39">github.com/Togather-Foundation/server/internal/storage/postgres/organizations_repository.go (87.5%)</option>
				
				<option value="file40">github.com/Togather-Foundation/server/internal/storage/postgres/places_repository.go (87.5%)</option>
				
				<option value="file41">github.com/Togather-Foundation/server/internal/storage/postgres/provenance_repository.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/Togather-Foundation/server/internal/api"
        "github.com/Togather-Foundation/server/internal/config"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/rs/zerolog"
        "golang.org/x/crypto/bcrypt"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "config error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger := config.NewLogger(cfg.Logging)
        logger.Info().Msg("starting SEL server")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        if err := bootstrapAdminUser(ctx, cfg, logger); err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("admin bootstrap failed")
        }</span>
        <span class="cov0" title="0">cancel()

        server := &amp;http.Server{
                Addr:              fmt.Sprintf("%s:%d", cfg.Server.Host, cfg.Server.Port),
                Handler:           api.NewRouter(cfg, logger),
                ReadHeaderTimeout: 5 * time.Second,
        }

        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        logger.Error().Err(err).Msg("http server error")
                }</span>
        }()

        <span class="cov0" title="0">shutdown(server, logger)</span>
}

func bootstrapAdminUser(ctx context.Context, cfg config.Config, logger zerolog.Logger) error <span class="cov0" title="0">{
        bootstrap := cfg.AdminBootstrap
        if bootstrap.Username == "" || bootstrap.Password == "" || bootstrap.Email == "" </span><span class="cov0" title="0">{
                logger.Warn().Msg("admin bootstrap env vars not fully set; skipping")
                return nil
        }</span>

        <span class="cov0" title="0">pool, err := pgxpool.New(ctx, cfg.Database.URL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer pool.Close()

        const checkQuery = `SELECT id FROM users WHERE email = $1 OR username = $2 LIMIT 1`
        row := pool.QueryRow(ctx, checkQuery, bootstrap.Email, bootstrap.Username)
        var existingID string
        if err := row.Scan(&amp;existingID); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if !errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return fmt.Errorf("check admin user: %w", err)
        }</span>

        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(bootstrap.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("hash admin password: %w", err)
        }</span>

        <span class="cov0" title="0">const insertQuery = `
INSERT INTO users (id, username, email, password_hash, role, is_active, created_at)
VALUES (gen_random_uuid(), $1, $2, $3, 'admin', true, now())`
        if _, err := pool.Exec(ctx, insertQuery, bootstrap.Username, bootstrap.Email, string(hash)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create admin user: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info().Str("email", bootstrap.Email).Msg("bootstrapped admin user")
        return nil</span>
}

func shutdown(server *http.Server, logger zerolog.Logger) <span class="cov0" title="0">{
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        &lt;-stop
        logger.Info().Msg("shutting down")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("shutdown error")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import "github.com/Togather-Foundation/server/internal/jsonld"

func loadDefaultContext() any <span class="cov8" title="1">{
        ctxDoc, err := jsonld.LoadDefaultContext()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if ctx, ok := ctxDoc["@context"]; ok </span><span class="cov8" title="1">{
                return ctx
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strings"

        "github.com/Togather-Foundation/server/internal/api/problem"
        "github.com/Togather-Foundation/server/internal/domain/events"
        "github.com/Togather-Foundation/server/internal/domain/ids"
)

type EventsHandler struct {
        Service *events.Service
        Ingest  *events.IngestService
        Env     string
        BaseURL string
}

func NewEventsHandler(service *events.Service, ingest *events.IngestService, env string, baseURL string) *EventsHandler <span class="cov8" title="1">{
        return &amp;EventsHandler{Service: service, Ingest: ingest, Env: env, BaseURL: baseURL}
}</span>

type listResponse struct {
        Items      []map[string]any `json:"items"`
        NextCursor string           `json:"next_cursor"`
}

func (h *EventsHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">filters, pagination, err := events.ParseFilters(r.URL.Query())
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">result, err := h.Service.List(r.Context(), filters, pagination)
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">contextValue := loadDefaultContext()
        items := make([]map[string]any, 0, len(result.Events))
        for _, event := range result.Events </span><span class="cov8" title="1">{
                items = append(items, map[string]any{
                        "@context": contextValue,
                        "@type":    "Event",
                        "name":     event.Name,
                })
        }</span>

        <span class="cov8" title="1">writeJSON(w, http.StatusOK, listResponse{Items: items, NextCursor: result.NextCursor}, contentTypeFromRequest(r))</span>
}

func (h *EventsHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h == nil || h.Ingest == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov0" title="0">var input events.EventInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", err, h.Env)
                return
        }</span>

        <span class="cov0" title="0">var (
                result *events.IngestResult
                err    error
        )
        if key := idempotencyKey(r); key != "" </span><span class="cov0" title="0">{
                result, err = h.Ingest.IngestWithIdempotency(r.Context(), input, key)
        }</span> else<span class="cov0" title="0"> {
                result, err = h.Ingest.Ingest(r.Context(), input)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, events.ErrConflict) </span><span class="cov0" title="0">{
                        problem.Write(w, r, http.StatusConflict, "https://sel.events/problems/conflict", "Conflict", err, h.Env)
                        return
                }</span>
                <span class="cov0" title="0">problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", err, h.Env)
                return</span>
        }

        <span class="cov0" title="0">status := http.StatusCreated
        if result != nil &amp;&amp; result.IsDuplicate </span><span class="cov0" title="0">{
                status = http.StatusConflict
        }</span>

        <span class="cov0" title="0">location := eventLocationPayload(input)
        payload := map[string]any{
                "@context": loadDefaultContext(),
                "@type":    "Event",
                "@id":      eventURI(h.BaseURL, result),
                "name":     input.Name,
        }
        if location != nil </span><span class="cov0" title="0">{
                payload["location"] = location
        }</span>

        <span class="cov0" title="0">writeJSON(w, status, payload, contentTypeFromRequest(r))</span>
}

func (h *EventsHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">ulidValue := strings.TrimSpace(pathParam(r, "id"))
        if ulidValue == "" </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", events.FilterError{Field: "id", Message: "missing"}, h.Env)
                return
        }</span>
        <span class="cov8" title="1">if err := ids.ValidateULID(ulidValue); err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", events.FilterError{Field: "id", Message: "invalid ULID"}, h.Env)
                return
        }</span>

        <span class="cov8" title="1">item, err := h.Service.GetByULID(r.Context(), ulidValue)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, events.ErrNotFound) </span><span class="cov8" title="1">{
                        problem.Write(w, r, http.StatusNotFound, "https://sel.events/problems/not-found", "Not found", err, h.Env)
                        return
                }</span>
                <span class="cov0" title="0">problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return</span>
        }

        <span class="cov8" title="1">contextValue := loadDefaultContext()
        payload := map[string]any{
                "@context": contextValue,
                "@type":    "Event",
                "name":     item.Name,
        }
        writeJSON(w, http.StatusOK, payload, contentTypeFromRequest(r))</span>
}

func writeJSON(w http.ResponseWriter, status int, payload any, contentType string) <span class="cov8" title="1">{
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = "application/json"
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(contentType, "application/") </span><span class="cov0" title="0">{
                contentType = "application/json"
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", contentType)
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(payload)</span>
}

func contentTypeFromRequest(r *http.Request) string <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return "application/json"
        }</span>
        <span class="cov8" title="1">accept := strings.TrimSpace(r.Header.Get("Accept"))
        if accept == "" || strings.HasPrefix(accept, "application/json") </span><span class="cov8" title="1">{
                return "application/json"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(accept, "application/ld+json") </span><span class="cov8" title="1">{
                return "application/ld+json"
        }</span>
        <span class="cov0" title="0">return "application/json"</span>
}

func pathParam(r *http.Request, key string) string <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return r.PathValue(key)</span>
}

func eventURI(baseURL string, result *events.IngestResult) string <span class="cov0" title="0">{
        if result == nil || result.Event == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">uri, err := ids.BuildCanonicalURI(baseURL, "events", result.Event.ULID)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return uri</span>
}

func eventLocationPayload(input events.EventInput) map[string]any <span class="cov0" title="0">{
        if input.Location != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "@type": "Place",
                        "name":  input.Location.Name,
                }
        }</span>
        <span class="cov0" title="0">if input.VirtualLocation != nil </span><span class="cov0" title="0">{
                return map[string]any{
                        "@type": "VirtualLocation",
                        "url":   input.VirtualLocation.URL,
                        "name":  input.VirtualLocation.Name,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func idempotencyKey(r *http.Request) string <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(r.Header.Get("Idempotency-Key"))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
)

type healthResponse struct {
        Status string `json:"status"`
}

// Healthz returns a lightweight liveness response.
func Healthz() http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                respondHealth(w, http.StatusOK, "ok")
        }</span>)
}

// Readyz returns a readiness response. Future dependencies can be checked here.
func Readyz() http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                respondHealth(w, http.StatusOK, "ready")
        }</span>)
}

func respondHealth(w http.ResponseWriter, status int, value string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(healthResponse{Status: value})
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strings"

        "github.com/Togather-Foundation/server/internal/api/problem"
        "github.com/Togather-Foundation/server/internal/domain/organizations"
)

type OrganizationsHandler struct {
        Service *organizations.Service
        Env     string
}

func NewOrganizationsHandler(service *organizations.Service, env string) *OrganizationsHandler <span class="cov8" title="1">{
        return &amp;OrganizationsHandler{Service: service, Env: env}
}</span>

type organizationListResponse struct {
        Items      []map[string]any `json:"items"`
        NextCursor string           `json:"next_cursor"`
}

func (h *OrganizationsHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">filters, pagination, err := organizations.ParseFilters(r.URL.Query())
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">result, err := h.Service.List(r.Context(), filters, pagination)
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">contextValue := loadDefaultContext()
        items := make([]map[string]any, 0, len(result.Organizations))
        for _, org := range result.Organizations </span><span class="cov8" title="1">{
                items = append(items, map[string]any{
                        "@context": contextValue,
                        "@type":    "Organization",
                        "name":     org.Name,
                })
        }</span>

        <span class="cov8" title="1">writeJSON(w, http.StatusOK, organizationListResponse{Items: items, NextCursor: result.NextCursor}, contentTypeFromRequest(r))</span>
}

func (h *OrganizationsHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">ulidValue := strings.TrimSpace(pathParam(r, "id"))
        if ulidValue == "" </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", organizations.FilterError{Field: "id", Message: "missing"}, h.Env)
                return
        }</span>
        <span class="cov8" title="1">if err := organizations.ValidateULID(ulidValue); err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", organizations.FilterError{Field: "id", Message: "invalid ULID"}, h.Env)
                return
        }</span>

        <span class="cov8" title="1">item, err := h.Service.GetByULID(r.Context(), ulidValue)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, organizations.ErrNotFound) </span><span class="cov8" title="1">{
                        problem.Write(w, r, http.StatusNotFound, "https://sel.events/problems/not-found", "Not found", err, h.Env)
                        return
                }</span>
                <span class="cov0" title="0">problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return</span>
        }

        <span class="cov0" title="0">contextValue := loadDefaultContext()
        payload := map[string]any{
                "@context": contextValue,
                "@type":    "Organization",
                "name":     item.Name,
        }
        writeJSON(w, http.StatusOK, payload, contentTypeFromRequest(r))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "errors"
        "net/http"
        "strings"

        "github.com/Togather-Foundation/server/internal/api/problem"
        "github.com/Togather-Foundation/server/internal/domain/places"
)

type PlacesHandler struct {
        Service *places.Service
        Env     string
}

func NewPlacesHandler(service *places.Service, env string) *PlacesHandler <span class="cov8" title="1">{
        return &amp;PlacesHandler{Service: service, Env: env}
}</span>

type placeListResponse struct {
        Items      []map[string]any `json:"items"`
        NextCursor string           `json:"next_cursor"`
}

func (h *PlacesHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">filters, pagination, err := places.ParseFilters(r.URL.Query())
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">result, err := h.Service.List(r.Context(), filters, pagination)
        if err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return
        }</span>

        <span class="cov8" title="1">contextValue := loadDefaultContext()
        items := make([]map[string]any, 0, len(result.Places))
        for _, place := range result.Places </span><span class="cov8" title="1">{
                items = append(items, map[string]any{
                        "@context": contextValue,
                        "@type":    "Place",
                        "name":     place.Name,
                })
        }</span>

        <span class="cov8" title="1">writeJSON(w, http.StatusOK, placeListResponse{Items: items, NextCursor: result.NextCursor}, contentTypeFromRequest(r))</span>
}

func (h *PlacesHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h == nil || h.Service == nil </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", nil, h.Env)
                return
        }</span>

        <span class="cov8" title="1">ulidValue := strings.TrimSpace(pathParam(r, "id"))
        if ulidValue == "" </span><span class="cov0" title="0">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", places.FilterError{Field: "id", Message: "missing"}, h.Env)
                return
        }</span>
        <span class="cov8" title="1">if err := places.ValidateULID(ulidValue); err != nil </span><span class="cov8" title="1">{
                problem.Write(w, r, http.StatusBadRequest, "https://sel.events/problems/validation-error", "Invalid request", places.FilterError{Field: "id", Message: "invalid ULID"}, h.Env)
                return
        }</span>

        <span class="cov8" title="1">item, err := h.Service.GetByULID(r.Context(), ulidValue)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, places.ErrNotFound) </span><span class="cov8" title="1">{
                        problem.Write(w, r, http.StatusNotFound, "https://sel.events/problems/not-found", "Not found", err, h.Env)
                        return
                }</span>
                <span class="cov0" title="0">problem.Write(w, r, http.StatusInternalServerError, "https://sel.events/problems/server-error", "Server error", err, h.Env)
                return</span>
        }

        <span class="cov0" title="0">contextValue := loadDefaultContext()
        payload := map[string]any{
                "@context": contextValue,
                "@type":    "Place",
                "name":     item.Name,
        }
        writeJSON(w, http.StatusOK, payload, contentTypeFromRequest(r))</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"

        "github.com/Togather-Foundation/server/internal/api/problem"
        "github.com/Togather-Foundation/server/internal/auth"
)

const AdminAuthCookieName = "sel_admin_token"

type contextKeyAuth string

const adminClaimsKey contextKeyAuth = "adminClaims"

func AdminAuthCookie(manager *auth.JWTManager) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if manager == nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">cookie, err := r.Cookie(AdminAuthCookieName)
                        if err != nil || strings.TrimSpace(cookie.Value) == "" </span><span class="cov0" title="0">{
                                http.Redirect(w, r, "/admin/login", http.StatusFound)
                                return
                        }</span>

                        <span class="cov0" title="0">claims, err := manager.Validate(cookie.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Redirect(w, r, "/admin/login", http.StatusFound)
                                return
                        }</span>

                        <span class="cov0" title="0">ctx := r.Context()
                        ctx = contextWithAdminClaims(ctx, claims)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

func contextWithAdminClaims(ctx context.Context, claims *auth.Claims) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, adminClaimsKey, claims)
}</span>

func AdminClaims(r *http.Request) *auth.Claims <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if claims, ok := r.Context().Value(adminClaimsKey).(*auth.Claims); ok </span><span class="cov0" title="0">{
                return claims
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type contextKeyAgent string

const agentKey contextKeyAgent = "agentKey"

func AgentAuth(store auth.APIKeyStore) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if store == nil </span><span class="cov0" title="0">{
                                problem.Write(w, r, http.StatusUnauthorized, "https://sel.events/problems/unauthorized", "Unauthorized", problem.ErrUnauthorized, "")
                                return
                        }</span>
                        <span class="cov0" title="0">key, err := auth.ValidateAPIKey(r.Context(), store, r.Header.Get("Authorization"))
                        if err != nil </span><span class="cov0" title="0">{
                                problem.Write(w, r, http.StatusUnauthorized, "https://sel.events/problems/unauthorized", "Unauthorized", err, "")
                                return
                        }</span>
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), agentKey, key)
                        next.ServeHTTP(w, r.WithContext(ctx))</span>
                })
        }
}

func AgentKey(r *http.Request) *auth.APIKey <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if key, ok := r.Context().Value(agentKey).(*auth.APIKey); ok </span><span class="cov0" title="0">{
                return key
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strings"
)

type idempotencyKey string

const (
        IdempotencyHeader          = "Idempotency-Key"
        idempotencyContextKey      = idempotencyKey("idempotencyKey")
        maxIdempotencyKeyLength    = 128
        trimmedIdempotencyKeyLimit = 128
)

func Idempotency(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                key := strings.TrimSpace(r.Header.Get(IdempotencyHeader))
                if key != "" </span><span class="cov0" title="0">{
                        if len(key) &gt; maxIdempotencyKeyLength </span><span class="cov0" title="0">{
                                key = key[:trimmedIdempotencyKeyLimit]
                        }</span>
                        <span class="cov0" title="0">ctx := context.WithValue(r.Context(), idempotencyContextKey, key)
                        next.ServeHTTP(w, r.WithContext(ctx))
                        return</span>
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func IdempotencyKey(r *http.Request) string <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if value, ok := r.Context().Value(idempotencyContextKey).(string); ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/rs/zerolog"
)

type responseWriter struct {
        http.ResponseWriter
        status int
        bytes  int
}

func (w *responseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.status = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        if w.status == 0 </span><span class="cov0" title="0">{
                w.status = http.StatusOK
        }</span>
        <span class="cov0" title="0">n, err := w.ResponseWriter.Write(p)
        w.bytes += n
        return n, err</span>
}

func RequestLogging(logger zerolog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()
                        rw := &amp;responseWriter{ResponseWriter: w}

                        next.ServeHTTP(rw, r)

                        duration := time.Since(start)
                        logger.Info().
                                Str("method", r.Method).
                                Str("path", r.URL.Path).
                                Int("status", rw.status).
                                Int("bytes", rw.bytes).
                                Dur("duration", duration).
                                Msg("request")
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"
        "net/http"
        "strconv"
        "strings"
)

type contextKey string

const contentTypeKey contextKey = "negotiatedContentType"

const (
        contentJSONLD = "application/ld+json"
        contentJSON   = "application/json"
        contentHTML   = "text/html"
        contentTurtle = "text/turtle"
)

func ContentNegotiation(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                contentType := negotiateContentType(r)
                ctx := context.WithValue(r.Context(), contentTypeKey, contentType)
                w.Header().Set("Vary", "Accept")
                next.ServeHTTP(w, r.WithContext(ctx))
        }</span>)
}

func NegotiatedContentType(r *http.Request) string <span class="cov8" title="1">{
        if r == nil </span><span class="cov8" title="1">{
                return contentJSON
        }</span>
        <span class="cov8" title="1">if value, ok := r.Context().Value(contentTypeKey).(string); ok &amp;&amp; value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return negotiateContentType(r)</span>
}

func negotiateContentType(r *http.Request) string <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return contentJSON
        }</span>

        <span class="cov8" title="1">if format := strings.ToLower(strings.TrimSpace(r.URL.Query().Get("format"))); format != "" </span><span class="cov8" title="1">{
                switch format </span>{
                case "jsonld", "ld+json", "application/ld+json":<span class="cov0" title="0">
                        return contentJSONLD</span>
                case "json", "application/json":<span class="cov0" title="0">
                        return contentJSONLD</span>
                case "html", "text/html":<span class="cov8" title="1">
                        return contentHTML</span>
                case "turtle", "text/turtle":<span class="cov0" title="0">
                        return contentTurtle</span>
                }
        }

        <span class="cov8" title="1">accept := r.Header.Get("Accept")
        if strings.TrimSpace(accept) == "" </span><span class="cov8" title="1">{
                return contentJSON
        }</span>

        <span class="cov8" title="1">bestType := ""
        bestQ := -1.0
        for _, part := range strings.Split(accept, ",") </span><span class="cov8" title="1">{
                mediaType := strings.TrimSpace(part)
                if mediaType == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">q := 1.0
                if strings.Contains(mediaType, ";") </span><span class="cov8" title="1">{
                        segments := strings.Split(mediaType, ";")
                        mediaType = strings.TrimSpace(segments[0])
                        for _, seg := range segments[1:] </span><span class="cov8" title="1">{
                                seg = strings.TrimSpace(seg)
                                if strings.HasPrefix(seg, "q=") </span><span class="cov8" title="1">{
                                        if parsed, err := strconv.ParseFloat(strings.TrimPrefix(seg, "q="), 64); err == nil </span><span class="cov8" title="1">{
                                                q = parsed
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">candidate := normalizeMediaType(mediaType)
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if q &gt; bestQ </span><span class="cov8" title="1">{
                        bestQ = q
                        bestType = candidate
                }</span>
        }

        <span class="cov8" title="1">if bestType == "" </span><span class="cov0" title="0">{
                return contentJSON
        }</span>
        <span class="cov8" title="1">return bestType</span>
}

func normalizeMediaType(mediaType string) string <span class="cov8" title="1">{
        mediaType = strings.ToLower(strings.TrimSpace(mediaType))
        if mediaType == "*/*" </span><span class="cov8" title="1">{
                return contentJSON
        }</span>

        <span class="cov8" title="1">switch mediaType </span>{
        case contentJSONLD, contentJSON:<span class="cov8" title="1">
                return contentJSONLD</span>
        case contentHTML:<span class="cov8" title="1">
                return contentHTML</span>
        case contentTurtle:<span class="cov8" title="1">
                return contentTurtle</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "context"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/Togather-Foundation/server/internal/config"
        "golang.org/x/time/rate"
)

type RateLimitTier string

const (
        TierPublic RateLimitTier = "public"
        TierAgent  RateLimitTier = "agent"
        TierAdmin  RateLimitTier = "admin"
)

type rateLimitKey string

const rateLimitTierKey rateLimitKey = "rateLimitTier"

func WithRateLimitTier(ctx context.Context, tier RateLimitTier) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, rateLimitTierKey, tier)
}</span>

func WithRateLimitTierHandler(tier RateLimitTier) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := WithRateLimitTier(r.Context(), tier)
                        next.ServeHTTP(w, r.WithContext(ctx))
                }</span>)
        }
}

func RateLimit(cfg config.RateLimitConfig) func(http.Handler) http.Handler <span class="cov0" title="0">{
        store := newLimiterStore(cfg)
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if r.URL.Path == "/healthz" || r.URL.Path == "/readyz" </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">tier := TierPublic
                        if value, ok := r.Context().Value(rateLimitTierKey).(RateLimitTier); ok </span><span class="cov0" title="0">{
                                tier = value
                        }</span>

                        <span class="cov0" title="0">limiter := store.limiter(tier, clientKey(r))
                        if limiter == nil </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">if !limiter.Allow() </span><span class="cov0" title="0">{
                                w.Header().Set("Retry-After", "60")
                                w.WriteHeader(http.StatusTooManyRequests)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

type limiterStore struct {
        mu        sync.Mutex
        limiters  map[string]*rate.Limiter
        perMinute map[RateLimitTier]int
}

func newLimiterStore(cfg config.RateLimitConfig) *limiterStore <span class="cov0" title="0">{
        return &amp;limiterStore{
                limiters: make(map[string]*rate.Limiter),
                perMinute: map[RateLimitTier]int{
                        TierPublic: cfg.PublicPerMinute,
                        TierAgent:  cfg.AgentPerMinute,
                        TierAdmin:  cfg.AdminPerMinute,
                },
        }
}</span>

func (s *limiterStore) limiter(tier RateLimitTier, key string) *rate.Limiter <span class="cov0" title="0">{
        limit := s.perMinute[tier]
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">lookup := string(tier) + ":" + key
        if key == "" </span><span class="cov0" title="0">{
                lookup = string(tier)
        }</span>

        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        if limiter, ok := s.limiters[lookup]; ok </span><span class="cov0" title="0">{
                return limiter
        }</span>

        <span class="cov0" title="0">interval := time.Minute / time.Duration(limit)
        limiter := rate.NewLimiter(rate.Every(interval), limit)
        s.limiters[lookup] = limiter
        return limiter</span>
}

func clientKey(r *http.Request) string <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov0" title="0">{
                parts := strings.Split(forwarded, ",")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(parts[0])
                }</span>
        }
        <span class="cov0" title="0">if realIP := r.Header.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(realIP)
        }</span>
        <span class="cov0" title="0">if host, _, err := net.SplitHostPort(r.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                return host
        }</span>
        <span class="cov0" title="0">return r.RemoteAddr</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "net/http"
        "os"
        "path/filepath"
        "runtime"
        "sync"

        "sigs.k8s.io/yaml"
)

const openAPISourcePath = "specs/001-sel-backend/contracts/openapi.yaml"

var (
        openAPIJSON    []byte
        openAPIJSONErr error
        openAPIOnce    sync.Once
)

func OpenAPIHandler() http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov0" title="0">openAPIOnce.Do(func() </span><span class="cov0" title="0">{
                        data, err := os.ReadFile(openAPISourcePath)
                        if err != nil </span><span class="cov0" title="0">{
                                data, err = os.ReadFile(resolveOpenAPIPath())
                                if err != nil </span><span class="cov0" title="0">{
                                        openAPIJSONErr = err
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">openAPIJSON, openAPIJSONErr = yaml.YAMLToJSON(data)</span>
                })

                <span class="cov0" title="0">if openAPIJSONErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, "openapi unavailable", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write(openAPIJSON)</span>
        }
}

func resolveOpenAPIPath() string <span class="cov0" title="0">{
        root, err := repoRoot()
        if err != nil </span><span class="cov0" title="0">{
                return openAPISourcePath
        }</span>
        <span class="cov0" title="0">return filepath.Join(root, openAPISourcePath)</span>
}

func repoRoot() (string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(cwd, "go.mod")); err == nil </span><span class="cov0" title="0">{
                        return cwd, nil
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(cwd)
                if parent == cwd </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cwd = parent</span>
        }
        <span class="cov0" title="0">_, file, _, ok := runtime.Caller(0)
        if !ok </span><span class="cov0" title="0">{
                return "", os.ErrNotExist
        }</span>
        <span class="cov0" title="0">base := filepath.Dir(file)
        return filepath.Join(base, "..", "..", ".."), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package pagination

import (
        "encoding/base64"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"
)

var ErrInvalidCursor = errors.New("invalid cursor")

// EventCursor encodes a timestamp + ULID for stable event ordering.
type EventCursor struct {
        Timestamp time.Time
        ULID      string
}

// EncodeEventCursor encodes the cursor as base64(ts_unix_nano:ULID).
func EncodeEventCursor(timestamp time.Time, ulid string) string <span class="cov8" title="1">{
        value := fmt.Sprintf("%d:%s", timestamp.UTC().UnixNano(), strings.ToUpper(strings.TrimSpace(ulid)))
        return base64.RawURLEncoding.EncodeToString([]byte(value))
}</span>

// DecodeEventCursor decodes base64(ts_unix_nano:ULID) into an EventCursor.
func DecodeEventCursor(cursor string) (EventCursor, error) <span class="cov8" title="1">{
        cursor = strings.TrimSpace(cursor)
        if cursor == "" </span><span class="cov8" title="1">{
                return EventCursor{}, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">decoded, err := base64.RawURLEncoding.DecodeString(cursor)
        if err != nil </span><span class="cov0" title="0">{
                return EventCursor{}, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">parts := strings.SplitN(string(decoded), ":", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return EventCursor{}, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">unixNano, err := strconv.ParseInt(parts[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return EventCursor{}, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(parts[1]) == "" </span><span class="cov0" title="0">{
                return EventCursor{}, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">return EventCursor{Timestamp: time.Unix(0, unixNano).UTC(), ULID: strings.ToUpper(strings.TrimSpace(parts[1]))}, nil</span>
}

// EncodeChangeCursor encodes a BIGSERIAL sequence number for change feeds.
func EncodeChangeCursor(sequence int64) string <span class="cov8" title="1">{
        value := fmt.Sprintf("seq_%d", sequence)
        return base64.RawURLEncoding.EncodeToString([]byte(value))
}</span>

// DecodeChangeCursor decodes base64(seq_&lt;number&gt;) into a sequence number.
func DecodeChangeCursor(cursor string) (int64, error) <span class="cov8" title="1">{
        cursor = strings.TrimSpace(cursor)
        if cursor == "" </span><span class="cov8" title="1">{
                return 0, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">decoded, err := base64.RawURLEncoding.DecodeString(cursor)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">value := string(decoded)
        if !strings.HasPrefix(value, "seq_") </span><span class="cov8" title="1">{
                return 0, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">seq, err := strconv.ParseInt(strings.TrimPrefix(value, "seq_"), 10, 64)
        if err != nil || seq &lt; 0 </span><span class="cov8" title="1">{
                return 0, ErrInvalidCursor
        }</span>
        <span class="cov8" title="1">return seq, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package problem

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
)

const contentType = "application/problem+json"

type ProblemDetails struct {
        Type     string                 `json:"type"`
        Title    string                 `json:"title"`
        Status   int                    `json:"status"`
        Detail   string                 `json:"detail,omitempty"`
        Instance string                 `json:"instance,omitempty"`
        Errors   map[string]interface{} `json:"errors,omitempty"`
}

type Option func(*ProblemDetails)

func WithDetail(detail string) Option <span class="cov0" title="0">{
        return func(p *ProblemDetails) </span><span class="cov0" title="0">{
                p.Detail = detail
        }</span>
}

func WithInstance(instance string) Option <span class="cov0" title="0">{
        return func(p *ProblemDetails) </span><span class="cov0" title="0">{
                p.Instance = instance
        }</span>
}

func WithErrors(errs map[string]interface{}) Option <span class="cov0" title="0">{
        return func(p *ProblemDetails) </span><span class="cov0" title="0">{
                p.Errors = errs
        }</span>
}

func Write(w http.ResponseWriter, r *http.Request, status int, typ, title string, err error, env string, opts ...Option) <span class="cov8" title="1">{
        problem := ProblemDetails{
                Type:   typ,
                Title:  title,
                Status: status,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(&amp;problem)
        }</span>

        <span class="cov8" title="1">if problem.Detail == "" &amp;&amp; err != nil </span><span class="cov8" title="1">{
                if env == "development" || env == "test" </span><span class="cov8" title="1">{
                        problem.Detail = err.Error()
                }</span> else<span class="cov8" title="1"> {
                        problem.Detail = http.StatusText(status)
                }</span>
        }

        <span class="cov8" title="1">if problem.Instance == "" &amp;&amp; r != nil </span><span class="cov8" title="1">{
                problem.Instance = r.URL.Path
        }</span>

        <span class="cov8" title="1">WriteProblem(w, problem)</span>
}

func WriteProblem(w http.ResponseWriter, problem ProblemDetails) <span class="cov8" title="1">{
        payload, err := json.Marshal(problem)
        if err != nil </span><span class="cov0" title="0">{
                fallback := fmt.Sprintf("{\"type\":\"about:blank\",\"title\":\"%s\",\"status\":500}", http.StatusText(http.StatusInternalServerError))
                w.Header().Set("Content-Type", contentType)
                w.WriteHeader(http.StatusInternalServerError)
                _, _ = w.Write([]byte(fallback))
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", contentType)
        w.WriteHeader(problem.Status)
        _, _ = w.Write(payload)</span>
}

var (
        ErrNotFound     = errors.New("not found")
        ErrUnauthorized = errors.New("unauthorized")
        ErrForbidden    = errors.New("forbidden")
        ErrConflict     = errors.New("conflict")
)
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"
        "net/http"
        "sort"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/api/handlers"
        "github.com/Togather-Foundation/server/internal/api/middleware"
        "github.com/Togather-Foundation/server/internal/config"
        "github.com/Togather-Foundation/server/internal/domain/events"
        "github.com/Togather-Foundation/server/internal/domain/organizations"
        "github.com/Togather-Foundation/server/internal/domain/places"
        "github.com/Togather-Foundation/server/internal/storage/postgres"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/rs/zerolog"
)

func NewRouter(cfg config.Config, logger zerolog.Logger) http.Handler <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        pool, err := pgxpool.New(ctx, cfg.Database.URL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("database connection failed")
                return http.NewServeMux()
        }</span>

        <span class="cov0" title="0">repo, err := postgres.NewRepository(pool)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error().Err(err).Msg("repository init failed")
                return http.NewServeMux()
        }</span>

        <span class="cov0" title="0">eventsService := events.NewService(repo.Events())
        ingestService := events.NewIngestService(repo.Events(), cfg.Server.BaseURL)
        placesService := places.NewService(repo.Places())
        orgService := organizations.NewService(repo.Organizations())

        eventsHandler := handlers.NewEventsHandler(eventsService, ingestService, cfg.Environment, cfg.Server.BaseURL)
        placesHandler := handlers.NewPlacesHandler(placesService, cfg.Environment)
        orgHandler := handlers.NewOrganizationsHandler(orgService, cfg.Environment)

        mux := http.NewServeMux()
        mux.Handle("/healthz", handlers.Healthz())
        mux.Handle("/readyz", handlers.Readyz())
        mux.Handle("/api/v1/openapi.json", OpenAPIHandler())
        apiKeyRepo := repo.Auth().APIKeys()
        apiKeyAuth := middleware.AgentAuth(apiKeyRepo)
        rateLimitAgent := middleware.WithRateLimitTierHandler(middleware.TierAgent)

        publicEvents := http.HandlerFunc(eventsHandler.List)
        createEvents := apiKeyAuth(rateLimitAgent(http.HandlerFunc(eventsHandler.Create)))

        mux.Handle("/api/v1/events", methodMux(map[string]http.Handler{
                http.MethodGet:  publicEvents,
                http.MethodPost: createEvents,
        }))
        mux.Handle("/api/v1/events/{id}", http.HandlerFunc(eventsHandler.Get))
        mux.Handle("/api/v1/places", http.HandlerFunc(placesHandler.List))
        mux.Handle("/api/v1/places/{id}", http.HandlerFunc(placesHandler.Get))
        mux.Handle("/api/v1/organizations", http.HandlerFunc(orgHandler.List))
        mux.Handle("/api/v1/organizations/{id}", http.HandlerFunc(orgHandler.Get))
        return mux</span>
}

func methodMux(handlers map[string]http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if handler, ok := handlers[r.Method]; ok </span><span class="cov0" title="0">{
                        handler.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Allow", allowedMethods(handlers))
                w.WriteHeader(http.StatusMethodNotAllowed)</span>
        })
}

func allowedMethods(handlers map[string]http.Handler) string <span class="cov0" title="0">{
        methods := make([]string, 0, len(handlers))
        for method := range handlers </span><span class="cov0" title="0">{
                methods = append(methods, method)
        }</span>
        <span class="cov0" title="0">sort.Strings(methods)
        return strings.Join(methods, ", ")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package auth

import (
        "context"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "errors"
        "net/http"
        "strings"
        "time"
        "unicode/utf8"
)

type APIKey struct {
        ID            string
        Prefix        string
        Hash          string
        Name          string
        SourceID      string
        Role          string
        RateLimitTier string
        IsActive      bool
        ExpiresAt     *time.Time
}

type APIKeyStore interface {
        LookupByPrefix(ctx context.Context, prefix string) (*APIKey, error)
        UpdateLastUsed(ctx context.Context, id string) error
}

var (
        ErrMissingAPIKey = errors.New("missing api key")
        ErrInvalidAPIKey = errors.New("invalid api key")
)

func APIKeyFromRequest(r *http.Request) (string, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return "", ErrMissingAPIKey
        }</span>
        <span class="cov8" title="1">return APIKeyFromHeader(r.Header.Get("Authorization"))</span>
}

func APIKeyFromHeader(authHeader string) (string, error) <span class="cov8" title="1">{
        parts := strings.Fields(authHeader)
        if len(parts) != 2 || !strings.EqualFold(parts[0], "bearer") </span><span class="cov8" title="1">{
                return "", ErrMissingAPIKey
        }</span>
        <span class="cov8" title="1">key := strings.TrimSpace(parts[1])
        if key == "" || !utf8.ValidString(key) </span><span class="cov0" title="0">{
                return "", ErrInvalidAPIKey
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

func ValidateAPIKey(ctx context.Context, store APIKeyStore, authHeader string) (*APIKey, error) <span class="cov8" title="1">{
        if store == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidAPIKey
        }</span>

        <span class="cov8" title="1">key, err := APIKeyFromHeader(authHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(key) &lt; 8 </span><span class="cov0" title="0">{
                return nil, ErrInvalidAPIKey
        }</span>

        <span class="cov8" title="1">prefix := key[:8]
        stored, err := store.LookupByPrefix(ctx, prefix)
        if err != nil || stored == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidAPIKey
        }</span>
        <span class="cov8" title="1">if !stored.IsActive </span><span class="cov8" title="1">{
                return nil, ErrInvalidAPIKey
        }</span>
        <span class="cov8" title="1">if stored.ExpiresAt != nil &amp;&amp; stored.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                return nil, ErrInvalidAPIKey
        }</span>

        <span class="cov8" title="1">providedHash := HashAPIKey(key)
        if subtle.ConstantTimeCompare([]byte(providedHash), []byte(stored.Hash)) != 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidAPIKey
        }</span>

        <span class="cov8" title="1">_ = store.UpdateLastUsed(ctx, stored.ID)
        return stored, nil</span>
}

func HashAPIKey(key string) string <span class="cov8" title="1">{
        sum := sha256.Sum256([]byte(key))
        return hex.EncodeToString(sum[:])
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package auth

import (
        "errors"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
        Role string `json:"role"`
        jwt.RegisteredClaims
}

type JWTManager struct {
        secret []byte
        expiry time.Duration
        issuer string
}

var (
        ErrMissingToken = errors.New("missing token")
        ErrInvalidToken = errors.New("invalid token")
)

func NewJWTManager(secret string, expiry time.Duration, issuer string) *JWTManager <span class="cov8" title="1">{
        return &amp;JWTManager{
                secret: []byte(secret),
                expiry: expiry,
                issuer: issuer,
        }
}</span>

func (m *JWTManager) Generate(subject, role string) (string, error) <span class="cov8" title="1">{
        if subject == "" || role == "" </span><span class="cov8" title="1">{
                return "", ErrInvalidToken
        }</span>

        <span class="cov8" title="1">now := time.Now()
        claims := &amp;Claims{
                Role: role,
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   subject,
                        Issuer:    m.issuer,
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(m.expiry)),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(m.secret)</span>
}

func (m *JWTManager) Validate(tokenString string) (*Claims, error) <span class="cov8" title="1">{
        if strings.TrimSpace(tokenString) == "" </span><span class="cov8" title="1">{
                return nil, ErrMissingToken
        }</span>

        <span class="cov8" title="1">parsed, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, ErrInvalidToken
                }</span>
                <span class="cov8" title="1">return m.secret, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov8" title="1">claims, ok := parsed.Claims.(*Claims)
        if !ok || !parsed.Valid </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}

func TokenFromHeader(authHeader string) (string, error) <span class="cov8" title="1">{
        parts := strings.Fields(authHeader)
        if len(parts) != 2 || !strings.EqualFold(parts[0], "bearer") </span><span class="cov8" title="1">{
                return "", ErrMissingToken
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(parts[1]), nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package auth

import "strings"

type Role string

const (
        RoleAdmin  Role = "admin"
        RoleEditor Role = "editor"
        RoleViewer Role = "viewer"
        RoleAgent  Role = "agent"
)

func NormalizeRole(role string) Role <span class="cov0" title="0">{
        switch strings.ToLower(strings.TrimSpace(role)) </span>{
        case string(RoleAdmin):<span class="cov0" title="0">
                return RoleAdmin</span>
        case string(RoleEditor):<span class="cov0" title="0">
                return RoleEditor</span>
        case string(RoleViewer):<span class="cov0" title="0">
                return RoleViewer</span>
        case string(RoleAgent):<span class="cov0" title="0">
                return RoleAgent</span>
        default:<span class="cov0" title="0">
                return RoleViewer</span>
        }
}

func HasRole(role string, allowed ...Role) bool <span class="cov0" title="0">{
        if len(allowed) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">current := NormalizeRole(role)
        for _, candidate := range allowed </span><span class="cov0" title="0">{
                if current == candidate </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func IsAdmin(role string) bool <span class="cov0" title="0">{
        return NormalizeRole(role) == RoleAdmin
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

type Config struct {
        Server         ServerConfig
        Database       DatabaseConfig
        Auth           AuthConfig
        RateLimit      RateLimitConfig
        AdminBootstrap AdminBootstrapConfig
        Jobs           JobsConfig
        Logging        LoggingConfig
        Environment    string
}

type ServerConfig struct {
        Host    string
        Port    int
        BaseURL string
}

type DatabaseConfig struct {
        URL            string
        MaxConnections int
        MaxIdle        int
}

type AuthConfig struct {
        JWTSecret string
        JWTExpiry time.Duration
}

type RateLimitConfig struct {
        PublicPerMinute int
        AgentPerMinute  int
        AdminPerMinute  int
}

type AdminBootstrapConfig struct {
        Username string
        Password string
        Email    string
}

type JobsConfig struct {
        RetryDeduplication  int
        RetryReconciliation int
        RetryEnrichment     int
}

type LoggingConfig struct {
        Level  string
        Format string
}

func Load() (Config, error) <span class="cov0" title="0">{
        cfg := Config{
                Server: ServerConfig{
                        Host:    getEnv("SERVER_HOST", "0.0.0.0"),
                        Port:    getEnvInt("SERVER_PORT", 8080),
                        BaseURL: getEnv("SERVER_BASE_URL", "http://localhost:8080"),
                },
                Database: DatabaseConfig{
                        URL:            getEnv("DATABASE_URL", ""),
                        MaxConnections: getEnvInt("DATABASE_MAX_CONNECTIONS", 25),
                        MaxIdle:        getEnvInt("DATABASE_MAX_IDLE_CONNECTIONS", 5),
                },
                Auth: AuthConfig{
                        JWTSecret: getEnv("JWT_SECRET", ""),
                        JWTExpiry: time.Duration(getEnvInt("JWT_EXPIRY_HOURS", 24)) * time.Hour,
                },
                RateLimit: RateLimitConfig{
                        PublicPerMinute: getEnvInt("RATE_LIMIT_PUBLIC", 60),
                        AgentPerMinute:  getEnvInt("RATE_LIMIT_AGENT", 300),
                        AdminPerMinute:  getEnvInt("RATE_LIMIT_ADMIN", 0),
                },
                AdminBootstrap: AdminBootstrapConfig{
                        Username: getEnv("ADMIN_USERNAME", ""),
                        Password: getEnv("ADMIN_PASSWORD", ""),
                        Email:    getEnv("ADMIN_EMAIL", ""),
                },
                Jobs: JobsConfig{
                        RetryDeduplication:  getEnvInt("JOB_RETRY_DEDUPLICATION", 1),
                        RetryReconciliation: getEnvInt("JOB_RETRY_RECONCILIATION", 5),
                        RetryEnrichment:     getEnvInt("JOB_RETRY_ENRICHMENT", 10),
                },
                Logging: LoggingConfig{
                        Level:  getEnv("LOG_LEVEL", "info"),
                        Format: getEnv("LOG_FORMAT", "json"),
                },
                Environment: getEnv("ENVIRONMENT", "development"),
        }

        if cfg.Database.URL == "" </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("DATABASE_URL is required")
        }</span>
        <span class="cov0" title="0">if cfg.Auth.JWTSecret == "" </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("JWT_SECRET is required")
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}

func getEnv(key, fallback string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

func getEnvInt(key string, fallback int) int <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">parsed, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">return parsed</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "io"
        "os"
        "strings"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func NewLogger(cfg LoggingConfig) zerolog.Logger <span class="cov0" title="0">{
        zerolog.TimeFieldFormat = time.RFC3339Nano

        level, err := zerolog.ParseLevel(strings.ToLower(cfg.Level))
        if err != nil </span><span class="cov0" title="0">{
                level = zerolog.InfoLevel
        }</span>

        <span class="cov0" title="0">var output io.Writer = os.Stdout
        if strings.EqualFold(cfg.Format, "console") </span><span class="cov0" title="0">{
                output = zerolog.ConsoleWriter{
                        Out:        os.Stdout,
                        TimeFormat: time.RFC3339,
                }
        }</span>

        <span class="cov0" title="0">logger := zerolog.New(output).Level(level).With().Timestamp().Logger()
        log.Logger = logger
        return logger</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package events

import (
        "crypto/sha256"
        "encoding/hex"
        "strings"
)

type DedupCandidate struct {
        Name      string
        VenueID   string
        StartDate string
}

func BuildDedupHash(candidate DedupCandidate) string <span class="cov0" title="0">{
        name := strings.ToLower(strings.TrimSpace(candidate.Name))
        venue := strings.ToLower(strings.TrimSpace(candidate.VenueID))
        start := strings.TrimSpace(candidate.StartDate)
        payload := strings.Join([]string{name, venue, start}, "|")
        sum := sha256.Sum256([]byte(payload))
        return hex.EncodeToString(sum[:])
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package events

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/domain/ids"
)

type IngestResult struct {
        Event       *Event
        IsDuplicate bool
        NeedsReview bool
}

type IngestService struct {
        repo       Repository
        nodeDomain string
        defaultTZ  string
}

func NewIngestService(repo Repository, nodeDomain string) *IngestService <span class="cov0" title="0">{
        return &amp;IngestService{repo: repo, nodeDomain: nodeDomain, defaultTZ: "America/Toronto"}
}</span>

func (s *IngestService) Ingest(ctx context.Context, input EventInput) (*IngestResult, error) <span class="cov0" title="0">{
        return s.IngestWithIdempotency(ctx, input, "")
}</span>

func (s *IngestService) IngestWithIdempotency(ctx context.Context, input EventInput, idempotencyKey string) (*IngestResult, error) <span class="cov0" title="0">{
        if s == nil || s.repo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ingest: repository not configured")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(idempotencyKey) != "" </span><span class="cov0" title="0">{
                keyEntry, err := s.repo.GetIdempotencyKey(ctx, idempotencyKey)
                if err == nil &amp;&amp; keyEntry != nil </span><span class="cov0" title="0">{
                        if keyEntry.EventULID == nil || *keyEntry.EventULID == "" </span><span class="cov0" title="0">{
                                return nil, ErrConflict
                        }</span>
                        <span class="cov0" title="0">item, err := s.repo.GetByULID(ctx, *keyEntry.EventULID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">payloadHash, err := hashInput(normalizedInputForHash(input))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if payloadHash != keyEntry.RequestHash </span><span class="cov0" title="0">{
                                return nil, ErrConflict
                        }</span>
                        <span class="cov0" title="0">return &amp;IngestResult{Event: item, IsDuplicate: true}, nil</span>
                }
                <span class="cov0" title="0">if err != nil &amp;&amp; err != ErrNotFound </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">payloadHash, err := hashInput(normalizedInputForHash(input))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">_, err = s.repo.InsertIdempotencyKey(ctx, IdempotencyKeyCreateParams{
                        Key:         idempotencyKey,
                        RequestHash: payloadHash,
                        EventID:     "",
                        EventULID:   "",
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">validated, err := ValidateEventInput(input, s.nodeDomain)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">normalized := NormalizeEventInput(validated)

        var sourceID string
        if normalized.Source != nil &amp;&amp; normalized.Source.URL != "" </span><span class="cov0" title="0">{
                sourceID, err = s.repo.GetOrCreateSource(ctx, SourceLookupParams{
                        Name:        sourceName(normalized.Source, normalized.Name),
                        SourceType:  "api",
                        BaseURL:     sourceBaseURL(normalized.Source.URL),
                        LicenseURL:  licenseURL(sourceLicense(normalized)),
                        LicenseType: sourceLicenseType(normalized),
                        TrustLevel:  5,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">existing, err := s.repo.FindBySourceExternalID(ctx, sourceID, normalized.Source.EventID)
                if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                        return &amp;IngestResult{Event: existing, IsDuplicate: true}, nil
                }</span>
                <span class="cov0" title="0">if err != nil &amp;&amp; err != ErrNotFound </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">dedupHash := BuildDedupHash(DedupCandidate{
                Name:      normalized.Name,
                VenueID:   primaryVenueKey(normalized),
                StartDate: normalized.StartDate,
        })
        if dedupHash != "" </span><span class="cov0" title="0">{
                existing, err := s.repo.FindByDedupHash(ctx, dedupHash)
                if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                        return &amp;IngestResult{Event: existing, IsDuplicate: true}, nil
                }</span>
                <span class="cov0" title="0">if err != nil &amp;&amp; err != ErrNotFound </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">ulidValue, err := ids.NewULID()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate ulid: %w", err)
        }</span>

        <span class="cov0" title="0">needsReview := needsReview(normalized, nil)
        params := EventCreateParams{
                ULID:           ulidValue,
                Name:           normalized.Name,
                Description:    normalized.Description,
                LifecycleState: "published",
                EventDomain:    "arts",
                OrganizerID:    nil,
                PrimaryVenueID: nil,
                VirtualURL:     virtualURL(normalized),
                ImageURL:       normalized.Image,
                PublicURL:      normalized.URL,
                Keywords:       normalized.Keywords,
                LicenseURL:     licenseURL(normalized.License),
                LicenseStatus:  "cc0",
                Confidence:     floatPtr(reviewConfidence(normalized, needsReview)),
                OriginNodeID:   nil,
        }

        if normalized.Location != nil &amp;&amp; normalized.Location.Name != "" </span><span class="cov0" title="0">{
                placeULID, err := ids.NewULID()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generate place ulid: %w", err)
                }</span>
                <span class="cov0" title="0">place, err := s.repo.UpsertPlace(ctx, PlaceCreateParams{
                        ULID:            placeULID,
                        Name:            normalized.Location.Name,
                        AddressLocality: normalized.Location.AddressLocality,
                        AddressRegion:   normalized.Location.AddressRegion,
                        AddressCountry:  normalized.Location.AddressCountry,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">params.PrimaryVenueID = &amp;place.ID</span>
        }

        <span class="cov0" title="0">if normalized.Organizer != nil &amp;&amp; normalized.Organizer.Name != "" </span><span class="cov0" title="0">{
                orgULID, err := ids.NewULID()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("generate organizer ulid: %w", err)
                }</span>
                <span class="cov0" title="0">addressLocality := ""
                addressRegion := ""
                addressCountry := ""
                if normalized.Location != nil </span><span class="cov0" title="0">{
                        addressLocality = normalized.Location.AddressLocality
                        addressRegion = normalized.Location.AddressRegion
                        addressCountry = normalized.Location.AddressCountry
                }</span>
                <span class="cov0" title="0">org, err := s.repo.UpsertOrganization(ctx, OrganizationCreateParams{
                        ULID:            orgULID,
                        Name:            normalized.Organizer.Name,
                        AddressLocality: addressLocality,
                        AddressRegion:   addressRegion,
                        AddressCountry:  addressCountry,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">params.OrganizerID = &amp;org.ID</span>
        }

        <span class="cov0" title="0">event, err := s.repo.Create(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.createOccurrences(ctx, event, normalized); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.recordSource(ctx, event, normalized, sourceID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(idempotencyKey) != "" </span><span class="cov0" title="0">{
                if err := s.repo.UpdateIdempotencyKeyEvent(ctx, idempotencyKey, event.ID, event.ULID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;IngestResult{Event: event, NeedsReview: needsReview}, nil</span>
}

func (s *IngestService) createOccurrences(ctx context.Context, event *Event, input EventInput) error <span class="cov0" title="0">{
        if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create occurrences: missing event")
        }</span>

        <span class="cov0" title="0">if len(input.Occurrences) == 0 </span><span class="cov0" title="0">{
                start, err := time.Parse(time.RFC3339, strings.TrimSpace(input.StartDate))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parse startDate: %w", err)
                }</span>
                <span class="cov0" title="0">end, err := parseRFC3339Optional("endDate", input.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">venueID := event.PrimaryVenueID
                virtual := nullableString(virtualURL(input))
                if venueID == nil &amp;&amp; virtual == nil &amp;&amp; event.VirtualURL != "" </span><span class="cov0" title="0">{
                        virtual = nullableString(event.VirtualURL)
                }</span>
                <span class="cov0" title="0">occurrence := OccurrenceCreateParams{
                        EventID:    event.ID,
                        StartTime:  start,
                        EndTime:    end,
                        Timezone:   s.defaultTZ,
                        VenueID:    venueID,
                        VirtualURL: virtual,
                }
                return s.repo.CreateOccurrence(ctx, occurrence)</span>
        }

        <span class="cov0" title="0">for _, occ := range input.Occurrences </span><span class="cov0" title="0">{
                start, err := time.Parse(time.RFC3339, strings.TrimSpace(occ.StartDate))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parse occurrence startDate: %w", err)
                }</span>
                <span class="cov0" title="0">end, err := parseRFC3339Optional("endDate", occ.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">var door *time.Time
                if occ.DoorTime != "" </span><span class="cov0" title="0">{
                        value, err := time.Parse(time.RFC3339, strings.TrimSpace(occ.DoorTime))
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("parse occurrence doorTime: %w", err)
                        }</span>
                        <span class="cov0" title="0">door = &amp;value</span>
                }
                <span class="cov0" title="0">tz := strings.TrimSpace(occ.Timezone)
                if tz == "" </span><span class="cov0" title="0">{
                        tz = s.defaultTZ
                }</span>
                <span class="cov0" title="0">occurrence := OccurrenceCreateParams{
                        EventID:    event.ID,
                        StartTime:  start,
                        EndTime:    end,
                        Timezone:   tz,
                        DoorTime:   door,
                        VenueID:    nullableString(occ.VenueID),
                        VirtualURL: nullableString(occ.VirtualURL),
                }
                if err := s.repo.CreateOccurrence(ctx, occurrence); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *IngestService) recordSource(ctx context.Context, event *Event, input EventInput, sourceID string) error <span class="cov0" title="0">{
        if input.Source == nil || input.Source.URL == "" || sourceID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">payload, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source payload: %w", err)
        }</span>
        <span class="cov0" title="0">payloadHash := sha256.Sum256(payload)

        params := EventSourceCreateParams{
                EventID:       event.ID,
                SourceID:      sourceID,
                SourceURL:     input.Source.URL,
                SourceEventID: input.Source.EventID,
                Payload:       payload,
                PayloadHash:   hex.EncodeToString(payloadHash[:]),
        }

        return s.repo.CreateSource(ctx, params)</span>
}

func primaryVenueKey(input EventInput) string <span class="cov0" title="0">{
        if input.Location != nil </span><span class="cov0" title="0">{
                if input.Location.ID != "" </span><span class="cov0" title="0">{
                        return input.Location.ID
                }</span>
                <span class="cov0" title="0">return input.Location.Name</span>
        }
        <span class="cov0" title="0">if input.VirtualLocation != nil </span><span class="cov0" title="0">{
                return input.VirtualLocation.URL
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func locationID(place *PlaceInput) string <span class="cov0" title="0">{
        if place == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(place.ID)</span>
}

func virtualURL(input EventInput) string <span class="cov0" title="0">{
        if input.VirtualLocation == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(input.VirtualLocation.URL)</span>
}

func sourceName(source *SourceInput, fallback string) string <span class="cov0" title="0">{
        if source == nil </span><span class="cov0" title="0">{
                return fallbackOrUnknown(fallback)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(source.Name) != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(source.Name)
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(source.EventID) != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(source.EventID)
        }</span>
        <span class="cov0" title="0">return fallbackOrUnknown(fallback)</span>
}

func sourceLicense(input EventInput) string <span class="cov0" title="0">{
        if input.Source != nil </span><span class="cov0" title="0">{
                if strings.TrimSpace(input.Source.License) != "" </span><span class="cov0" title="0">{
                        return input.Source.License
                }</span>
        }
        <span class="cov0" title="0">return input.License</span>
}

func sourceLicenseType(input EventInput) string <span class="cov0" title="0">{
        license := strings.TrimSpace(strings.ToLower(sourceLicense(input)))
        if license == "" </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">if strings.Contains(license, "creativecommons.org/publicdomain/zero") || license == "cc0" || license == "cc0-1.0" </span><span class="cov0" title="0">{
                return "CC0"
        }</span>
        <span class="cov0" title="0">if strings.Contains(license, "creativecommons.org/licenses/by") || strings.Contains(license, "cc-by") </span><span class="cov0" title="0">{
                return "CC-BY"
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

func fallbackOrUnknown(value string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return trimmed</span>
}

func sourceBaseURL(value string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">parsed, err := url.Parse(trimmed)
        if err != nil || parsed.Scheme == "" || parsed.Host == "" </span><span class="cov0" title="0">{
                return trimmed
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s://%s", parsed.Scheme, parsed.Host)</span>
}

func licenseURL(value string) string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return "https://creativecommons.org/publicdomain/zero/1.0/"
        }</span>
        <span class="cov0" title="0">return trimmed</span>
}

func nullableString(value string) *string <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;trimmed</span>
}

func needsReview(input EventInput, linkStatuses map[string]int) bool <span class="cov0" title="0">{
        if reviewConfidence(input, false) &lt; 0.6 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.Description) == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.Image) == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if isTooFarFuture(input.StartDate, 730) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if linkStatuses != nil </span><span class="cov0" title="0">{
                for _, code := range linkStatuses </span><span class="cov0" title="0">{
                        if code &gt;= 400 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func reviewConfidence(input EventInput, flagged bool) float64 <span class="cov0" title="0">{
        confidence := 0.9
        if strings.TrimSpace(input.Description) == "" </span><span class="cov0" title="0">{
                confidence -= 0.2
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.Image) == "" </span><span class="cov0" title="0">{
                confidence -= 0.2
        }</span>
        <span class="cov0" title="0">if isTooFarFuture(input.StartDate, 730) </span><span class="cov0" title="0">{
                confidence -= 0.2
        }</span>
        <span class="cov0" title="0">if flagged </span><span class="cov0" title="0">{
                confidence -= 0.1
        }</span>
        <span class="cov0" title="0">if confidence &lt; 0 </span><span class="cov0" title="0">{
                confidence = 0
        }</span>
        <span class="cov0" title="0">return confidence</span>
}

func isTooFarFuture(startDate string, days int) bool <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(startDate)
        if trimmed == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">parsed, err := time.Parse(time.RFC3339, trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return parsed.After(time.Now().Add(time.Duration(days) * 24 * time.Hour))</span>
}

func floatPtr(value float64) *float64 <span class="cov0" title="0">{
        return &amp;value
}</span>

func normalizedInputForHash(input EventInput) EventInput <span class="cov0" title="0">{
        return NormalizeEventInput(input)
}</span>

func hashInput(input EventInput) (string, error) <span class="cov0" title="0">{
        payload, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("hash input: %w", err)
        }</span>
        <span class="cov0" title="0">sum := sha256.Sum256(payload)
        return hex.EncodeToString(sum[:]), nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package events

import (
        "sort"
        "strings"
)

// NormalizeEventInput trims and normalizes values for consistent storage and hashing.
func NormalizeEventInput(input EventInput) EventInput <span class="cov0" title="0">{
        input.Name = strings.TrimSpace(input.Name)
        input.Description = strings.TrimSpace(input.Description)
        input.StartDate = strings.TrimSpace(input.StartDate)
        input.EndDate = strings.TrimSpace(input.EndDate)
        input.DoorTime = strings.TrimSpace(input.DoorTime)
        input.Image = strings.TrimSpace(input.Image)
        input.URL = strings.TrimSpace(input.URL)
        input.License = strings.TrimSpace(input.License)

        input.Keywords = normalizeStringSlice(input.Keywords, true)
        input.InLanguage = normalizeStringSlice(input.InLanguage, true)
        input.SameAs = normalizeStringSlice(input.SameAs, false)

        if input.Location != nil </span><span class="cov0" title="0">{
                input.Location = normalizePlaceInput(*input.Location)
        }</span>
        <span class="cov0" title="0">if input.VirtualLocation != nil </span><span class="cov0" title="0">{
                input.VirtualLocation = normalizeVirtualLocationInput(*input.VirtualLocation)
        }</span>
        <span class="cov0" title="0">if input.Organizer != nil </span><span class="cov0" title="0">{
                input.Organizer = normalizeOrganizationInput(*input.Organizer)
        }</span>
        <span class="cov0" title="0">if input.Offers != nil </span><span class="cov0" title="0">{
                input.Offers = normalizeOfferInput(*input.Offers)
        }</span>
        <span class="cov0" title="0">if input.Source != nil </span><span class="cov0" title="0">{
                input.Source = normalizeSourceInput(*input.Source)
        }</span>
        <span class="cov0" title="0">if len(input.Occurrences) &gt; 0 </span><span class="cov0" title="0">{
                input.Occurrences = normalizeOccurrences(input.Occurrences)
        }</span>

        <span class="cov0" title="0">return input</span>
}

func normalizePlaceInput(place PlaceInput) *PlaceInput <span class="cov0" title="0">{
        place.ID = strings.TrimSpace(place.ID)
        place.Name = strings.TrimSpace(place.Name)
        place.StreetAddress = strings.TrimSpace(place.StreetAddress)
        place.AddressLocality = strings.TrimSpace(place.AddressLocality)
        place.AddressRegion = strings.TrimSpace(place.AddressRegion)
        place.PostalCode = strings.TrimSpace(place.PostalCode)
        place.AddressCountry = strings.TrimSpace(place.AddressCountry)
        return &amp;place
}</span>

func normalizeVirtualLocationInput(location VirtualLocationInput) *VirtualLocationInput <span class="cov0" title="0">{
        location.Type = strings.TrimSpace(location.Type)
        location.URL = strings.TrimSpace(location.URL)
        location.Name = strings.TrimSpace(location.Name)
        return &amp;location
}</span>

func normalizeOrganizationInput(org OrganizationInput) *OrganizationInput <span class="cov0" title="0">{
        org.ID = strings.TrimSpace(org.ID)
        org.Name = strings.TrimSpace(org.Name)
        org.URL = strings.TrimSpace(org.URL)
        return &amp;org
}</span>

func normalizeOfferInput(offer OfferInput) *OfferInput <span class="cov0" title="0">{
        offer.URL = strings.TrimSpace(offer.URL)
        offer.Price = strings.TrimSpace(offer.Price)
        offer.PriceCurrency = strings.TrimSpace(offer.PriceCurrency)
        return &amp;offer
}</span>

func normalizeSourceInput(source SourceInput) *SourceInput <span class="cov0" title="0">{
        source.URL = strings.TrimSpace(source.URL)
        source.EventID = strings.TrimSpace(source.EventID)
        return &amp;source
}</span>

func normalizeOccurrences(values []OccurrenceInput) []OccurrenceInput <span class="cov0" title="0">{
        result := make([]OccurrenceInput, 0, len(values))
        for _, occ := range values </span><span class="cov0" title="0">{
                occ.StartDate = strings.TrimSpace(occ.StartDate)
                occ.EndDate = strings.TrimSpace(occ.EndDate)
                occ.DoorTime = strings.TrimSpace(occ.DoorTime)
                occ.Timezone = strings.TrimSpace(occ.Timezone)
                occ.VenueID = strings.TrimSpace(occ.VenueID)
                occ.VirtualURL = strings.TrimSpace(occ.VirtualURL)
                result = append(result, occ)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func normalizeStringSlice(values []string, lower bool) []string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">set := make(map[string]struct{}, len(values))
        for _, value := range values </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(value)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if lower </span><span class="cov0" title="0">{
                        trimmed = strings.ToLower(trimmed)
                }</span>
                <span class="cov0" title="0">set[trimmed] = struct{}{}</span>
        }
        <span class="cov0" title="0">if len(set) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">result := make([]string, 0, len(set))
        for value := range set </span><span class="cov0" title="0">{
                result = append(result, value)
        }</span>
        <span class="cov0" title="0">sort.Strings(result)
        return result</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package events

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/domain/ids"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{repo: repo}
}</span>

func (s *Service) List(ctx context.Context, filters Filters, pagination Pagination) (ListResult, error) <span class="cov0" title="0">{
        return s.repo.List(ctx, filters, pagination)
}</span>

func (s *Service) GetByULID(ctx context.Context, ulid string) (*Event, error) <span class="cov0" title="0">{
        return s.repo.GetByULID(ctx, ulid)
}</span>

type FilterError struct {
        Field   string
        Message string
}

func (e FilterError) Error() string <span class="cov0" title="0">{
        if e.Field == "" </span><span class="cov0" title="0">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("invalid %s: %s", e.Field, e.Message)</span>
}

func ParseFilters(values url.Values) (Filters, Pagination, error) <span class="cov8" title="1">{
        filters := Filters{}
        pagination := Pagination{Limit: 50}

        startDate, err := parseDate("startDate", values.Get("startDate"))
        if err != nil </span><span class="cov8" title="1">{
                return filters, pagination, err
        }</span>
        <span class="cov8" title="1">endDate, err := parseDate("endDate", values.Get("endDate"))
        if err != nil </span><span class="cov0" title="0">{
                return filters, pagination, err
        }</span>
        <span class="cov8" title="1">if startDate != nil &amp;&amp; endDate != nil &amp;&amp; endDate.Before(*startDate) </span><span class="cov8" title="1">{
                return filters, pagination, FilterError{Field: "endDate", Message: "must be on or after startDate"}
        }</span>
        <span class="cov8" title="1">filters.StartDate = startDate
        filters.EndDate = endDate

        filters.City = strings.TrimSpace(values.Get("city"))
        filters.Region = strings.TrimSpace(values.Get("region"))

        filters.VenueULID = strings.TrimSpace(values.Get("venueId"))
        if filters.VenueULID != "" </span><span class="cov8" title="1">{
                if err := ids.ValidateULID(filters.VenueULID); err != nil </span><span class="cov8" title="1">{
                        return filters, pagination, FilterError{Field: "venueId", Message: "invalid ULID"}
                }</span>
        }

        <span class="cov8" title="1">filters.OrganizerULID = strings.TrimSpace(values.Get("organizerId"))
        if filters.OrganizerULID != "" </span><span class="cov8" title="1">{
                if err := ids.ValidateULID(filters.OrganizerULID); err != nil </span><span class="cov8" title="1">{
                        return filters, pagination, FilterError{Field: "organizerId", Message: "invalid ULID"}
                }</span>
        }

        <span class="cov8" title="1">filters.LifecycleState = parseLifecycleState(values)
        if filters.LifecycleState == "" </span><span class="cov8" title="1">{
                if err := parseLifecycleStateErr(values); err != nil </span><span class="cov8" title="1">{
                        return filters, pagination, err
                }</span>
        }

        <span class="cov8" title="1">filters.Query = strings.TrimSpace(values.Get("q"))

        filters.Domain = parseDomain(values)
        if filters.Domain == "" </span><span class="cov8" title="1">{
                if err := parseDomainErr(values); err != nil </span><span class="cov8" title="1">{
                        return filters, pagination, err
                }</span>
        }

        <span class="cov8" title="1">filters.Keywords = parseKeywords(values.Get("keywords"))

        limit, err := parseLimit(values)
        if err != nil </span><span class="cov8" title="1">{
                return filters, pagination, err
        }</span>
        <span class="cov8" title="1">pagination.Limit = limit

        pagination.After = strings.TrimSpace(values.Get("after"))

        return filters, pagination, nil</span>
}

func parseDate(field string, value string) (*time.Time, error) <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse("2006-01-02", value)
        if err != nil </span><span class="cov8" title="1">{
                return nil, FilterError{Field: field, Message: "must be ISO8601 date"}
        }</span>
        <span class="cov8" title="1">return &amp;parsed, nil</span>
}

func parseKeywords(value string) []string <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(value, ",")
        keywords := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                item := strings.TrimSpace(part)
                if item != "" </span><span class="cov8" title="1">{
                        keywords = append(keywords, item)
                }</span>
        }
        <span class="cov8" title="1">return keywords</span>
}

func parseLifecycleState(values url.Values) string <span class="cov8" title="1">{
        value := strings.TrimSpace(values.Get("state"))
        if value == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">value = strings.ToLower(value)
        if isAllowedLifecycleState(value) </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func parseLifecycleStateErr(values url.Values) error <span class="cov8" title="1">{
        value := strings.TrimSpace(values.Get("state"))
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">value = strings.ToLower(value)
        if !isAllowedLifecycleState(value) </span><span class="cov8" title="1">{
                return FilterError{Field: "state", Message: "unsupported lifecycle state"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parseDomain(values url.Values) string <span class="cov8" title="1">{
        value := strings.TrimSpace(values.Get("domain"))
        if value == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">value = strings.ToLower(value)
        if isAllowedDomain(value) </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func parseDomainErr(values url.Values) error <span class="cov8" title="1">{
        value := strings.TrimSpace(values.Get("domain"))
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">value = strings.ToLower(value)
        if !isAllowedDomain(value) </span><span class="cov8" title="1">{
                return FilterError{Field: "domain", Message: "unsupported event domain"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parseLimit(values url.Values) (int, error) <span class="cov8" title="1">{
        limit := 50
        rawLimit := strings.TrimSpace(values.Get("limit"))
        if rawLimit == "" </span><span class="cov8" title="1">{
                return limit, nil
        }</span>
        <span class="cov8" title="1">parsed, err := strconv.Atoi(rawLimit)
        if err != nil </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be a number"}
        }</span>
        <span class="cov8" title="1">if parsed &lt; 1 || parsed &gt; 200 </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be between 1 and 200"}
        }</span>
        <span class="cov8" title="1">return parsed, nil</span>
}

func isAllowedLifecycleState(value string) bool <span class="cov8" title="1">{
        switch value </span>{
        case "draft", "published", "postponed", "rescheduled", "sold_out", "cancelled", "completed":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isAllowedDomain(value string) bool <span class="cov8" title="1">{
        switch value </span>{
        case "arts", "music", "culture", "sports", "community", "education", "general":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package events

import (
        "fmt"
        "net/url"
        "strings"
        "time"
        "unicode/utf8"

        "github.com/Togather-Foundation/server/internal/domain/ids"
)

const (
        maxNameLength        = 500
        maxDescriptionLength = 10000
)

type ValidationError struct {
        Field   string
        Message string
}

func (e ValidationError) Error() string <span class="cov0" title="0">{
        if e.Field == "" </span><span class="cov0" title="0">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("invalid %s: %s", e.Field, e.Message)</span>
}

type EventInput struct {
        ID                  string                `json:"@id,omitempty"`
        Type                string                `json:"@type,omitempty"`
        Name                string                `json:"name,omitempty"`
        Description         string                `json:"description,omitempty"`
        StartDate           string                `json:"startDate,omitempty"`
        EndDate             string                `json:"endDate,omitempty"`
        DoorTime            string                `json:"doorTime,omitempty"`
        Location            *PlaceInput           `json:"location,omitempty"`
        VirtualLocation     *VirtualLocationInput `json:"virtualLocation,omitempty"`
        Organizer           *OrganizationInput    `json:"organizer,omitempty"`
        Image               string                `json:"image,omitempty"`
        URL                 string                `json:"url,omitempty"`
        Keywords            []string              `json:"keywords,omitempty"`
        InLanguage          []string              `json:"inLanguage,omitempty"`
        IsAccessibleForFree *bool                 `json:"isAccessibleForFree,omitempty"`
        Offers              *OfferInput           `json:"offers,omitempty"`
        SameAs              []string              `json:"sameAs,omitempty"`
        License             string                `json:"license,omitempty"`
        Source              *SourceInput          `json:"source,omitempty"`
        Occurrences         []OccurrenceInput     `json:"occurrences,omitempty"`
}

type PlaceInput struct {
        ID              string  `json:"@id,omitempty"`
        Name            string  `json:"name,omitempty"`
        StreetAddress   string  `json:"streetAddress,omitempty"`
        AddressLocality string  `json:"addressLocality,omitempty"`
        AddressRegion   string  `json:"addressRegion,omitempty"`
        PostalCode      string  `json:"postalCode,omitempty"`
        AddressCountry  string  `json:"addressCountry,omitempty"`
        Latitude        float64 `json:"latitude,omitempty"`
        Longitude       float64 `json:"longitude,omitempty"`
}

type VirtualLocationInput struct {
        Type string `json:"@type,omitempty"`
        URL  string `json:"url,omitempty"`
        Name string `json:"name,omitempty"`
}

type OrganizationInput struct {
        ID   string `json:"@id,omitempty"`
        Name string `json:"name,omitempty"`
        URL  string `json:"url,omitempty"`
}

type OfferInput struct {
        URL           string `json:"url,omitempty"`
        Price         string `json:"price,omitempty"`
        PriceCurrency string `json:"priceCurrency,omitempty"`
}

type SourceInput struct {
        URL     string `json:"url,omitempty"`
        EventID string `json:"eventId,omitempty"`
        Name    string `json:"name,omitempty"`
        License string `json:"license,omitempty"`
}

type OccurrenceInput struct {
        StartDate  string `json:"startDate,omitempty"`
        EndDate    string `json:"endDate,omitempty"`
        Timezone   string `json:"timezone,omitempty"`
        DoorTime   string `json:"doorTime,omitempty"`
        VenueID    string `json:"venueId,omitempty"`
        VirtualURL string `json:"virtualUrl,omitempty"`
}

func ValidateEventInput(input EventInput, nodeDomain string) (EventInput, error) <span class="cov0" title="0">{
        name := strings.TrimSpace(input.Name)
        if name == "" </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "name", Message: "required"}
        }</span>
        <span class="cov0" title="0">if utf8.RuneCountInString(name) &gt; maxNameLength </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "name", Message: "too long"}
        }</span>

        <span class="cov0" title="0">if utf8.RuneCountInString(strings.TrimSpace(input.Description)) &gt; maxDescriptionLength </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "description", Message: "too long"}
        }</span>

        <span class="cov0" title="0">startTime, err := parseRFC3339("startDate", input.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return input, err
        }</span>

        <span class="cov0" title="0">endTime, err := parseRFC3339Optional("endDate", input.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return input, err
        }</span>
        <span class="cov0" title="0">if endTime != nil &amp;&amp; endTime.Before(*startTime) </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "endDate", Message: "must be on or after startDate"}
        }</span>

        <span class="cov0" title="0">if _, err := parseRFC3339Optional("doorTime", input.DoorTime); err != nil </span><span class="cov0" title="0">{
                return input, err
        }</span>

        <span class="cov0" title="0">if input.Location == nil &amp;&amp; input.VirtualLocation == nil </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "location", Message: "location or virtualLocation required"}
        }</span>
        <span class="cov0" title="0">if input.Location != nil </span><span class="cov0" title="0">{
                if err := validatePlaceInput(*input.Location, nodeDomain); err != nil </span><span class="cov0" title="0">{
                        return input, err
                }</span>
        }
        <span class="cov0" title="0">if input.VirtualLocation != nil </span><span class="cov0" title="0">{
                if err := validateVirtualLocationInput(*input.VirtualLocation); err != nil </span><span class="cov0" title="0">{
                        return input, err
                }</span>
        }
        <span class="cov0" title="0">if input.Organizer != nil </span><span class="cov0" title="0">{
                if err := validateOrganizationInput(*input.Organizer, nodeDomain); err != nil </span><span class="cov0" title="0">{
                        return input, err
                }</span>
        }

        <span class="cov0" title="0">if input.Image != "" </span><span class="cov0" title="0">{
                if err := validateURL(input.Image); err != nil </span><span class="cov0" title="0">{
                        return input, ValidationError{Field: "image", Message: "invalid URI"}
                }</span>
        }
        <span class="cov0" title="0">if input.URL != "" </span><span class="cov0" title="0">{
                if err := validateURL(input.URL); err != nil </span><span class="cov0" title="0">{
                        return input, ValidationError{Field: "url", Message: "invalid URI"}
                }</span>
        }

        <span class="cov0" title="0">if input.ID != "" </span><span class="cov0" title="0">{
                if err := validateCanonicalURI(nodeDomain, "events", input.ID); err != nil </span><span class="cov0" title="0">{
                        return input, ValidationError{Field: "@id", Message: "invalid canonical URI"}
                }</span>
        }

        <span class="cov0" title="0">if input.License != "" &amp;&amp; !isCC0License(input.License) </span><span class="cov0" title="0">{
                return input, ValidationError{Field: "license", Message: "must be CC0"}
        }</span>

        <span class="cov0" title="0">if len(input.SameAs) &gt; 0 </span><span class="cov0" title="0">{
                normalized, err := normalizeSameAs(nodeDomain, "events", input.SameAs)
                if err != nil </span><span class="cov0" title="0">{
                        return input, err
                }</span>
                <span class="cov0" title="0">input.SameAs = normalized</span>
        }

        <span class="cov0" title="0">if input.Source != nil &amp;&amp; input.Source.URL != "" </span><span class="cov0" title="0">{
                if err := validateURL(input.Source.URL); err != nil </span><span class="cov0" title="0">{
                        return input, ValidationError{Field: "source.url", Message: "invalid URI"}
                }</span>
                <span class="cov0" title="0">if strings.TrimSpace(input.Source.EventID) == "" </span><span class="cov0" title="0">{
                        return input, ValidationError{Field: "source.eventId", Message: "required"}
                }</span>
        }

        <span class="cov0" title="0">if err := validateOccurrences(input, nodeDomain); err != nil </span><span class="cov0" title="0">{
                return input, err
        }</span>

        <span class="cov0" title="0">input.Name = name
        return input, nil</span>
}

func validateOccurrences(input EventInput, nodeDomain string) error <span class="cov0" title="0">{
        if len(input.Occurrences) == 0 </span><span class="cov0" title="0">{
                if input.StartDate == "" </span><span class="cov0" title="0">{
                        return ValidationError{Field: "occurrences", Message: "required"}
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">for i, occ := range input.Occurrences </span><span class="cov0" title="0">{
                fieldPrefix := fmt.Sprintf("occurrences[%d]", i)
                startTime, err := parseRFC3339(fieldPrefix+".startDate", occ.StartDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">endTime, err := parseRFC3339Optional(fieldPrefix+".endDate", occ.EndDate)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if endTime != nil &amp;&amp; endTime.Before(*startTime) </span><span class="cov0" title="0">{
                        return ValidationError{Field: fieldPrefix + ".endDate", Message: "must be on or after startDate"}
                }</span>
                <span class="cov0" title="0">if _, err := parseRFC3339Optional(fieldPrefix+".doorTime", occ.DoorTime); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if occ.Timezone != "" </span><span class="cov0" title="0">{
                        if _, err := time.LoadLocation(strings.TrimSpace(occ.Timezone)); err != nil </span><span class="cov0" title="0">{
                                return ValidationError{Field: fieldPrefix + ".timezone", Message: "invalid timezone"}
                        }</span>
                }
                <span class="cov0" title="0">if occ.VirtualURL != "" </span><span class="cov0" title="0">{
                        if err := validateURL(occ.VirtualURL); err != nil </span><span class="cov0" title="0">{
                                return ValidationError{Field: fieldPrefix + ".virtualUrl", Message: "invalid URI"}
                        }</span>
                }
                <span class="cov0" title="0">if occ.VenueID != "" </span><span class="cov0" title="0">{
                        if err := validateCanonicalURI(nodeDomain, "places", occ.VenueID); err != nil </span><span class="cov0" title="0">{
                                return ValidationError{Field: fieldPrefix + ".venueId", Message: "invalid canonical URI"}
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func validatePlaceInput(place PlaceInput, nodeDomain string) error <span class="cov0" title="0">{
        if place.ID == "" &amp;&amp; strings.TrimSpace(place.Name) == "" </span><span class="cov0" title="0">{
                return ValidationError{Field: "location.name", Message: "required"}
        }</span>
        <span class="cov0" title="0">if place.ID != "" </span><span class="cov0" title="0">{
                if err := validateCanonicalURI(nodeDomain, "places", place.ID); err != nil </span><span class="cov0" title="0">{
                        return ValidationError{Field: "location.@id", Message: "invalid canonical URI"}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func validateOrganizationInput(org OrganizationInput, nodeDomain string) error <span class="cov0" title="0">{
        if org.ID == "" &amp;&amp; strings.TrimSpace(org.Name) == "" </span><span class="cov0" title="0">{
                return ValidationError{Field: "organizer.name", Message: "required"}
        }</span>
        <span class="cov0" title="0">if org.ID != "" </span><span class="cov0" title="0">{
                if err := validateCanonicalURI(nodeDomain, "organizations", org.ID); err != nil </span><span class="cov0" title="0">{
                        return ValidationError{Field: "organizer.@id", Message: "invalid canonical URI"}
                }</span>
        }
        <span class="cov0" title="0">if org.URL != "" </span><span class="cov0" title="0">{
                if err := validateURL(org.URL); err != nil </span><span class="cov0" title="0">{
                        return ValidationError{Field: "organizer.url", Message: "invalid URI"}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func validateVirtualLocationInput(location VirtualLocationInput) error <span class="cov0" title="0">{
        if strings.TrimSpace(location.URL) == "" </span><span class="cov0" title="0">{
                return ValidationError{Field: "virtualLocation.url", Message: "required"}
        }</span>
        <span class="cov0" title="0">if err := validateURL(location.URL); err != nil </span><span class="cov0" title="0">{
                return ValidationError{Field: "virtualLocation.url", Message: "invalid URI"}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateCanonicalURI(nodeDomain, entityPath, value string) error <span class="cov0" title="0">{
        parsed, err := ids.ParseEntityURI(nodeDomain, entityPath, value, "")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if parsed.Role != ids.RoleCanonical </span><span class="cov0" title="0">{
                return ids.ErrInvalidURI
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func normalizeSameAs(nodeDomain, entityPath string, values []string) ([]string, error) <span class="cov0" title="0">{
        result := make([]string, 0, len(values))
        for _, value := range values </span><span class="cov0" title="0">{
                normalized, err := ids.NormalizeSameAs(nodeDomain, entityPath, value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, ValidationError{Field: "sameAs", Message: "invalid URI"}
                }</span>
                <span class="cov0" title="0">result = append(result, normalized)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

func parseRFC3339(field, value string) (*time.Time, error) <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil, ValidationError{Field: field, Message: "required"}
        }</span>
        <span class="cov0" title="0">parsed, err := time.Parse(time.RFC3339, trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ValidationError{Field: field, Message: "invalid date-time"}
        }</span>
        <span class="cov0" title="0">return &amp;parsed, nil</span>
}

func parseRFC3339Optional(field, value string) (*time.Time, error) <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">parsed, err := time.Parse(time.RFC3339, trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ValidationError{Field: field, Message: "invalid date-time"}
        }</span>
        <span class="cov0" title="0">return &amp;parsed, nil</span>
}

func validateURL(raw string) error <span class="cov0" title="0">{
        parsed, err := url.Parse(strings.TrimSpace(raw))
        if err != nil || parsed.Scheme == "" || parsed.Host == "" </span><span class="cov0" title="0">{
                return ids.ErrInvalidURI
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func isCC0License(value string) bool <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(strings.ToLower(value))
        switch trimmed </span>{
        case "https://creativecommons.org/publicdomain/zero/1.0/",
                "http://creativecommons.org/publicdomain/zero/1.0/",
                "cc0",
                "cc0-1.0":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package ids

import (
        "crypto/rand"
        "errors"
        "fmt"
        "net/url"
        "path"
        "regexp"
        "strings"
        "time"

        "github.com/oklog/ulid/v2"
)

var (
        ulidRegex = regexp.MustCompile(`(?i)^[0-9A-HJKMNP-TV-Z]{26}$`)

        ErrInvalidULID          = errors.New("invalid ULID")
        ErrInvalidURI           = errors.New("invalid URI")
        ErrMissingOriginNodeID  = errors.New("origin node id required for foreign identifiers")
        ErrUnsupportedSameAs    = errors.New("unsupported sameAs value")
        ErrInvalidNodeDomain    = errors.New("invalid node domain")
        ErrInvalidEntityPath    = errors.New("invalid entity path")
        ErrMismatchedEntityPath = errors.New("entity path does not match")
)

// IdentifierRole describes how a URI should be treated in SEL.
// canonical = local entity minted by this node
// foreign = federated entity with origin_node_id
// alias = sameAs link to another canonical URI
//
// Role is derived from URI host + origin_node_id presence.
type IdentifierRole string

const (
        RoleCanonical IdentifierRole = "canonical"
        RoleForeign   IdentifierRole = "foreign"
        RoleAlias     IdentifierRole = "alias"
)

// EntityURI is a parsed, validated SEL URI.
type EntityURI struct {
        URI  string
        ULID string
        Role IdentifierRole
        Host string
        Path string
}

// NewULID generates a new ULID string.
func NewULID() (string, error) <span class="cov8" title="1">{
        entropy := ulid.Monotonic(rand.Reader, 0)
        id, err := ulid.New(ulid.Timestamp(time.Now()), entropy)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return id.String(), nil</span>
}

// IsULID returns true when value is a valid ULID (case-insensitive Crockford Base32).
func IsULID(value string) bool <span class="cov8" title="1">{
        return ulidRegex.MatchString(strings.TrimSpace(value))
}</span>

// ValidateULID validates a ULID string.
func ValidateULID(value string) error <span class="cov8" title="1">{
        if !IsULID(value) </span><span class="cov8" title="1">{
                return ErrInvalidULID
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BuildCanonicalURI creates a canonical URI for a local entity.
func BuildCanonicalURI(nodeDomain, entityPath, ulid string) (string, error) <span class="cov8" title="1">{
        if err := ValidateULID(ulid); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">scheme, host, err := normalizeNodeDomain(nodeDomain)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">cleanEntityPath, err := normalizeEntityPath(entityPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s://%s/%s/%s", scheme, host, cleanEntityPath, strings.ToUpper(ulid)), nil</span>
}

// ParseEntityURI validates a URI and derives role + ULID.
// originNodeID is required for foreign identifiers.
func ParseEntityURI(nodeDomain, entityPath, uri, originNodeID string) (EntityURI, error) <span class="cov8" title="1">{
        parsed, err := url.Parse(strings.TrimSpace(uri))
        if err != nil || parsed.Scheme == "" || parsed.Host == "" </span><span class="cov8" title="1">{
                return EntityURI{}, ErrInvalidURI
        }</span>

        <span class="cov8" title="1">cleanEntityPath, err := normalizeEntityPath(entityPath)
        if err != nil </span><span class="cov0" title="0">{
                return EntityURI{}, err
        }</span>

        <span class="cov8" title="1">cleanPath := path.Clean(parsed.Path)
        pathParts := strings.Split(strings.TrimPrefix(cleanPath, "/"), "/")
        if len(pathParts) &lt; 2 </span><span class="cov0" title="0">{
                return EntityURI{}, ErrInvalidURI
        }</span>
        <span class="cov8" title="1">if pathParts[0] != cleanEntityPath </span><span class="cov8" title="1">{
                return EntityURI{}, ErrMismatchedEntityPath
        }</span>

        <span class="cov8" title="1">id := strings.ToUpper(pathParts[1])
        if err := ValidateULID(id); err != nil </span><span class="cov0" title="0">{
                return EntityURI{}, err
        }</span>

        <span class="cov8" title="1">_, host, err := normalizeNodeDomain(nodeDomain)
        if err != nil </span><span class="cov0" title="0">{
                return EntityURI{}, err
        }</span>

        <span class="cov8" title="1">role := RoleForeign
        if strings.EqualFold(parsed.Host, host) </span><span class="cov8" title="1">{
                role = RoleCanonical
        }</span> else<span class="cov8" title="1"> if originNodeID == "" </span><span class="cov8" title="1">{
                return EntityURI{}, ErrMissingOriginNodeID
        }</span>

        <span class="cov8" title="1">return EntityURI{
                URI:  parsed.String(),
                ULID: id,
                Role: role,
                Host: parsed.Host,
                Path: cleanPath,
        }, nil</span>
}

// NormalizeSameAs ensures sameAs values resolve to full canonical URIs.
func NormalizeSameAs(nodeDomain, entityPath, value string) (string, error) <span class="cov8" title="1">{
        candidate := strings.TrimSpace(value)
        if candidate == "" </span><span class="cov8" title="1">{
                return "", ErrUnsupportedSameAs
        }</span>

        <span class="cov8" title="1">parsed, err := url.Parse(candidate)
        if err == nil &amp;&amp; parsed.Scheme != "" &amp;&amp; parsed.Host != "" </span><span class="cov8" title="1">{
                return parsed.String(), nil
        }</span>

        <span class="cov8" title="1">cleanEntityPath, err := normalizeEntityPath(entityPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(candidate, "/") </span><span class="cov8" title="1">{
                return buildAbsoluteURI(nodeDomain, candidate)
        }</span>

        <span class="cov8" title="1">if IsULID(candidate) </span><span class="cov8" title="1">{
                return BuildCanonicalURI(nodeDomain, cleanEntityPath, candidate)
        }</span>

        <span class="cov8" title="1">prefix := cleanEntityPath + "/"
        if strings.HasPrefix(candidate, prefix) </span><span class="cov8" title="1">{
                return BuildCanonicalURI(nodeDomain, cleanEntityPath, strings.TrimPrefix(candidate, prefix))
        }</span>

        <span class="cov8" title="1">return "", ErrUnsupportedSameAs</span>
}

func normalizeNodeDomain(nodeDomain string) (string, string, error) <span class="cov8" title="1">{
        value := strings.TrimSpace(nodeDomain)
        if value == "" </span><span class="cov8" title="1">{
                return "", "", ErrInvalidNodeDomain
        }</span>

        <span class="cov8" title="1">if strings.Contains(value, "://") </span><span class="cov0" title="0">{
                parsed, err := url.Parse(value)
                if err != nil || parsed.Host == "" </span><span class="cov0" title="0">{
                        return "", "", ErrInvalidNodeDomain
                }</span>
                <span class="cov0" title="0">if parsed.Path != "" &amp;&amp; parsed.Path != "/" </span><span class="cov0" title="0">{
                        return "", "", ErrInvalidNodeDomain
                }</span>
                <span class="cov0" title="0">return parsed.Scheme, parsed.Host, nil</span>
        }

        <span class="cov8" title="1">if strings.Contains(value, "/") </span><span class="cov0" title="0">{
                return "", "", ErrInvalidNodeDomain
        }</span>

        <span class="cov8" title="1">return "https", value, nil</span>
}

func normalizeEntityPath(entityPath string) (string, error) <span class="cov8" title="1">{
        cleaned := strings.Trim(strings.TrimSpace(entityPath), "/")
        if cleaned == "" </span><span class="cov8" title="1">{
                return "", ErrInvalidEntityPath
        }</span>
        <span class="cov8" title="1">return cleaned, nil</span>
}

func buildAbsoluteURI(nodeDomain, relativePath string) (string, error) <span class="cov8" title="1">{
        scheme, host, err := normalizeNodeDomain(nodeDomain)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">cleanPath := path.Clean("/" + strings.TrimSpace(relativePath))
        return fmt.Sprintf("%s://%s%s", scheme, host, cleanPath), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package organizations

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
        "strings"

        "github.com/Togather-Foundation/server/internal/domain/ids"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{repo: repo}
}</span>

func (s *Service) List(ctx context.Context, filters Filters, pagination Pagination) (ListResult, error) <span class="cov0" title="0">{
        return s.repo.List(ctx, filters, pagination)
}</span>

func (s *Service) GetByULID(ctx context.Context, ulid string) (*Organization, error) <span class="cov0" title="0">{
        return s.repo.GetByULID(ctx, ulid)
}</span>

type FilterError struct {
        Field   string
        Message string
}

func (e FilterError) Error() string <span class="cov0" title="0">{
        if e.Field == "" </span><span class="cov0" title="0">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("invalid %s: %s", e.Field, e.Message)</span>
}

func ParseFilters(values url.Values) (Filters, Pagination, error) <span class="cov8" title="1">{
        filters := Filters{}
        pagination := Pagination{Limit: 50}

        filters.Query = strings.TrimSpace(values.Get("q"))

        limit, err := parseLimit(values)
        if err != nil </span><span class="cov8" title="1">{
                return filters, pagination, err
        }</span>
        <span class="cov8" title="1">pagination.Limit = limit

        pagination.After = strings.TrimSpace(values.Get("after"))

        return filters, pagination, nil</span>
}

func parseLimit(values url.Values) (int, error) <span class="cov8" title="1">{
        limit := 50
        rawLimit := strings.TrimSpace(values.Get("limit"))
        if rawLimit == "" </span><span class="cov8" title="1">{
                return limit, nil
        }</span>
        <span class="cov8" title="1">parsed, err := strconv.Atoi(rawLimit)
        if err != nil </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be a number"}
        }</span>
        <span class="cov8" title="1">if parsed &lt; 1 || parsed &gt; 200 </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be between 1 and 200"}
        }</span>
        <span class="cov8" title="1">return parsed, nil</span>
}

func ValidateULID(ulid string) error <span class="cov0" title="0">{
        return ids.ValidateULID(ulid)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package places

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
        "strings"

        "github.com/Togather-Foundation/server/internal/domain/ids"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{repo: repo}
}</span>

func (s *Service) List(ctx context.Context, filters Filters, pagination Pagination) (ListResult, error) <span class="cov0" title="0">{
        return s.repo.List(ctx, filters, pagination)
}</span>

func (s *Service) GetByULID(ctx context.Context, ulid string) (*Place, error) <span class="cov0" title="0">{
        return s.repo.GetByULID(ctx, ulid)
}</span>

type FilterError struct {
        Field   string
        Message string
}

func (e FilterError) Error() string <span class="cov0" title="0">{
        if e.Field == "" </span><span class="cov0" title="0">{
                return e.Message
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("invalid %s: %s", e.Field, e.Message)</span>
}

func ParseFilters(values url.Values) (Filters, Pagination, error) <span class="cov8" title="1">{
        filters := Filters{}
        pagination := Pagination{Limit: 50}

        filters.City = strings.TrimSpace(values.Get("city"))
        filters.Query = strings.TrimSpace(values.Get("q"))

        limit, err := parseLimit(values)
        if err != nil </span><span class="cov8" title="1">{
                return filters, pagination, err
        }</span>
        <span class="cov8" title="1">pagination.Limit = limit

        pagination.After = strings.TrimSpace(values.Get("after"))

        return filters, pagination, nil</span>
}

func parseLimit(values url.Values) (int, error) <span class="cov8" title="1">{
        limit := 50
        rawLimit := strings.TrimSpace(values.Get("limit"))
        if rawLimit == "" </span><span class="cov8" title="1">{
                return limit, nil
        }</span>
        <span class="cov8" title="1">parsed, err := strconv.Atoi(rawLimit)
        if err != nil </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be a number"}
        }</span>
        <span class="cov8" title="1">if parsed &lt; 1 || parsed &gt; 200 </span><span class="cov8" title="1">{
                return 0, FilterError{Field: "limit", Message: "must be between 1 and 200"}
        }</span>
        <span class="cov8" title="1">return parsed, nil</span>
}

func ValidateULID(ulid string) error <span class="cov8" title="1">{
        return ids.ValidateULID(ulid)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package provenance

import (
        "context"
        "fmt"
        "strings"
)

type Service struct {
        repo Repository
}

func NewService(repo Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{repo: repo}
}</span>

func (s *Service) GetOrCreateSource(ctx context.Context, params CreateSourceParams) (*Source, error) <span class="cov0" title="0">{
        if s == nil || s.repo == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provenance service not configured")
        }</span>

        <span class="cov0" title="0">baseURL := strings.TrimSpace(params.BaseURL)
        if baseURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("source base url required")
        }</span>

        <span class="cov0" title="0">if existing, err := s.repo.GetByBaseURL(ctx, baseURL); err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        <span class="cov0" title="0">params.BaseURL = baseURL
        return s.repo.Create(ctx, params)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package jobs

import (
        "context"
        "fmt"
        "log/slog"

        "github.com/riverqueue/river"
        "github.com/riverqueue/river/rivertype"
)

// AlertFunc is invoked when a job fails or panics.
type AlertFunc func(ctx context.Context, job *rivertype.JobRow, err error)

// AlertingErrorHandler logs and forwards job failures for alerting.
type AlertingErrorHandler struct {
        Logger *slog.Logger
        Notify AlertFunc
}

// NewAlertingErrorHandler builds an ErrorHandler that logs and forwards errors.
func NewAlertingErrorHandler(logger *slog.Logger, notify AlertFunc) *AlertingErrorHandler <span class="cov0" title="0">{
        return &amp;AlertingErrorHandler{
                Logger: logger,
                Notify: notify,
        }
}</span>

func (h *AlertingErrorHandler) HandleError(ctx context.Context, job *rivertype.JobRow, err error) *river.ErrorHandlerResult <span class="cov0" title="0">{
        if h.Logger != nil </span><span class="cov0" title="0">{
                h.Logger.Error("job failed", "job_id", job.ID, "kind", job.Kind, "attempt", job.Attempt, "error", err)
        }</span>
        <span class="cov0" title="0">if h.Notify != nil </span><span class="cov0" title="0">{
                h.Notify(ctx, job, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (h *AlertingErrorHandler) HandlePanic(ctx context.Context, job *rivertype.JobRow, panicVal any, trace string) *river.ErrorHandlerResult <span class="cov0" title="0">{
        panicErr := fmt.Errorf("panic: %v", panicVal)
        if h.Logger != nil </span><span class="cov0" title="0">{
                h.Logger.Error("job panicked", "job_id", job.ID, "kind", job.Kind, "attempt", job.Attempt, "error", panicErr, "trace", trace)
        }</span>
        <span class="cov0" title="0">if h.Notify != nil </span><span class="cov0" title="0">{
                h.Notify(ctx, job, panicErr)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package jobs

import (
        "log/slog"
        "math"
        "time"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/riverqueue/river"
        "github.com/riverqueue/river/riverdriver/riverpgxv5"
        "github.com/riverqueue/river/rivertype"
)

const (
        JobKindDeduplication  = "deduplication"
        JobKindReconciliation = "reconciliation"
        JobKindEnrichment     = "enrichment"
)

const (
        DeduplicationMaxAttempts  = 1
        ReconciliationMaxAttempts = 5
        EnrichmentMaxAttempts     = 10
)

// RetryConfig controls per-kind retry behavior.
type RetryConfig struct {
        MaxAttempts int
        BaseDelay   time.Duration
        MaxDelay    time.Duration
}

// RetryPolicy implements River's ClientRetryPolicy with per-kind exponential backoff.
type RetryPolicy struct {
        Default RetryConfig
        ByKind  map[string]RetryConfig
}

// NewRetryPolicy returns the default retry policy configuration.
func NewRetryPolicy() *RetryPolicy <span class="cov0" title="0">{
        return &amp;RetryPolicy{
                Default: RetryConfig{
                        MaxAttempts: ReconciliationMaxAttempts,
                        BaseDelay:   30 * time.Second,
                        MaxDelay:    30 * time.Minute,
                },
                ByKind: map[string]RetryConfig{
                        JobKindDeduplication: {
                                MaxAttempts: DeduplicationMaxAttempts,
                                BaseDelay:   0,
                                MaxDelay:    0,
                        },
                        JobKindReconciliation: {
                                MaxAttempts: ReconciliationMaxAttempts,
                                BaseDelay:   1 * time.Minute,
                                MaxDelay:    1 * time.Hour,
                        },
                        JobKindEnrichment: {
                                MaxAttempts: EnrichmentMaxAttempts,
                                BaseDelay:   2 * time.Minute,
                                MaxDelay:    2 * time.Hour,
                        },
                },
        }
}</span>

// NextRetry determines the next retry time for a failed job.
func (p *RetryPolicy) NextRetry(job *rivertype.JobRow) time.Time <span class="cov0" title="0">{
        config := p.configFor(job.Kind)
        if config.BaseDelay == 0 </span><span class="cov0" title="0">{
                return time.Now()
        }</span>

        <span class="cov0" title="0">attempt := job.Attempt
        if attempt &lt; 1 </span><span class="cov0" title="0">{
                attempt = 1
        }</span>

        <span class="cov0" title="0">delay := time.Duration(float64(config.BaseDelay) * math.Pow(2, float64(attempt-1)))
        if config.MaxDelay &gt; 0 &amp;&amp; delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                delay = config.MaxDelay
        }</span>

        <span class="cov0" title="0">if job.AttemptedAt != nil </span><span class="cov0" title="0">{
                return job.AttemptedAt.Add(delay)
        }</span>

        <span class="cov0" title="0">return time.Now().Add(delay)</span>
}

// InsertOptsForKind returns default insert options for a job kind.
func InsertOptsForKind(kind string) river.InsertOpts <span class="cov0" title="0">{
        config := NewRetryPolicy().configFor(kind)
        return river.InsertOpts{MaxAttempts: config.MaxAttempts}
}</span>

// NewClientConfig builds a River client configuration with retry policy.
func NewClientConfig(workers *river.Workers, logger *slog.Logger) *river.Config <span class="cov0" title="0">{
        policy := NewRetryPolicy()
        config := &amp;river.Config{
                Workers:     workers,
                RetryPolicy: policy,
                MaxAttempts: policy.Default.MaxAttempts,
                Queues: map[string]river.QueueConfig{
                        river.QueueDefault: {MaxWorkers: 10},
                },
        }
        if logger != nil </span><span class="cov0" title="0">{
                config.Logger = logger
                config.ErrorHandler = NewAlertingErrorHandler(logger, nil)
        }</span>
        <span class="cov0" title="0">return config</span>
}

// NewClient creates a River client using pgx v5.
func NewClient(pool *pgxpool.Pool, workers *river.Workers, logger *slog.Logger) (*river.Client[pgx.Tx], error) <span class="cov0" title="0">{
        return river.NewClient(riverpgxv5.New(pool), NewClientConfig(workers, logger))
}</span>

func (p *RetryPolicy) configFor(kind string) RetryConfig <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return RetryConfig{MaxAttempts: ReconciliationMaxAttempts, BaseDelay: 1 * time.Minute, MaxDelay: 1 * time.Hour}
        }</span>
        <span class="cov0" title="0">if config, ok := p.ByKind[kind]; ok </span><span class="cov0" title="0">{
                return config
        }</span>
        <span class="cov0" title="0">return p.Default</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package jobs

import (
        "context"
        "fmt"

        "github.com/riverqueue/river"
)

type DeduplicationArgs struct {
        EventID string `json:"event_id"`
}

func (DeduplicationArgs) Kind() string <span class="cov0" title="0">{ return JobKindDeduplication }</span>

type ReconciliationArgs struct {
        EventID string `json:"event_id"`
}

func (ReconciliationArgs) Kind() string <span class="cov0" title="0">{ return JobKindReconciliation }</span>

type EnrichmentArgs struct {
        EventID string `json:"event_id"`
}

func (EnrichmentArgs) Kind() string <span class="cov0" title="0">{ return JobKindEnrichment }</span>

type DeduplicationWorker struct {
        river.WorkerDefaults[DeduplicationArgs]
}

func (DeduplicationWorker) Kind() string <span class="cov0" title="0">{ return JobKindDeduplication }</span>

func (DeduplicationWorker) Work(ctx context.Context, job *river.Job[DeduplicationArgs]) error <span class="cov0" title="0">{
        if job == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("deduplication job missing")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReconciliationWorker struct {
        river.WorkerDefaults[ReconciliationArgs]
}

func (ReconciliationWorker) Kind() string <span class="cov0" title="0">{ return JobKindReconciliation }</span>

func (ReconciliationWorker) Work(ctx context.Context, job *river.Job[ReconciliationArgs]) error <span class="cov0" title="0">{
        if job == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reconciliation job missing")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EnrichmentWorker struct {
        river.WorkerDefaults[EnrichmentArgs]
}

func (EnrichmentWorker) Kind() string <span class="cov0" title="0">{ return JobKindEnrichment }</span>

func (EnrichmentWorker) Work(ctx context.Context, job *river.Job[EnrichmentArgs]) error <span class="cov0" title="0">{
        if job == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("enrichment job missing")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewWorkers() *river.Workers <span class="cov0" title="0">{
        workers := river.NewWorkers()
        river.AddWorker[DeduplicationArgs](workers, DeduplicationWorker{})
        river.AddWorker[ReconciliationArgs](workers, ReconciliationWorker{})
        river.AddWorker[EnrichmentArgs](workers, EnrichmentWorker{})
        return workers
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package jsonld

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

const (
        DefaultContextVersion = "v0.1"
        DefaultContextDir     = "contexts/sel"
)

var (
        ErrContextNotFound = errors.New("context not found")
        ErrInvalidVersion  = errors.New("invalid context version")
)

// ContextLoader loads versioned JSON-LD contexts with in-memory caching.
type ContextLoader struct {
        mu      sync.RWMutex
        cache   map[string]map[string]any
        baseDir string
}

// NewContextLoader creates a loader rooted at baseDir. If baseDir is empty, DefaultContextDir is used.
func NewContextLoader(baseDir string) *ContextLoader <span class="cov8" title="1">{
        if baseDir == "" </span><span class="cov8" title="1">{
                baseDir = resolveDefaultContextDir()
        }</span>
        <span class="cov8" title="1">return &amp;ContextLoader{
                cache:   make(map[string]map[string]any),
                baseDir: baseDir,
        }</span>
}

// Load returns the JSON-LD context document for the requested version.
func (l *ContextLoader) Load(version string) (map[string]any, error) <span class="cov8" title="1">{
        if version == "" </span><span class="cov8" title="1">{
                return nil, ErrInvalidVersion
        }</span>

        <span class="cov8" title="1">l.mu.RLock()
        if cached, ok := l.cache[version]; ok </span><span class="cov8" title="1">{
                l.mu.RUnlock()
                return cached, nil
        }</span>
        <span class="cov8" title="1">l.mu.RUnlock()

        path := filepath.Join(l.baseDir, fmt.Sprintf("%s.jsonld", version))
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, ErrContextNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">var doc map[string]any
        if err := json.Unmarshal(data, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">l.mu.Lock()
        l.cache[version] = doc
        l.mu.Unlock()

        return doc, nil</span>
}

// LoadContext loads the specified context version using the default loader.
func LoadContext(version string) (map[string]any, error) <span class="cov0" title="0">{
        return defaultLoader.Load(version)
}</span>

// LoadDefaultContext loads the default context version.
func LoadDefaultContext() (map[string]any, error) <span class="cov0" title="0">{
        return defaultLoader.Load(DefaultContextVersion)
}</span>

var defaultLoader = NewContextLoader("")

func resolveDefaultContextDir() string <span class="cov8" title="1">{
        if existsContextDir(DefaultContextDir) </span><span class="cov8" title="1">{
                return DefaultContextDir
        }</span>

        <span class="cov8" title="1">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return DefaultContextDir
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                candidate := filepath.Join(cwd, DefaultContextDir)
                if existsContextDir(candidate) </span><span class="cov8" title="1">{
                        return candidate
                }</span>
                <span class="cov8" title="1">parent := filepath.Dir(cwd)
                if parent == cwd </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">cwd = parent</span>
        }

        <span class="cov0" title="0">return DefaultContextDir</span>
}

func existsContextDir(dir string) bool <span class="cov8" title="1">{
        path := filepath.Join(dir, fmt.Sprintf("%s.jsonld", DefaultContextVersion))
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return !info.IsDir()</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package jsonld

import (
        "errors"

        "github.com/piprate/json-gold/ld"
)

var (
        ErrInvalidFrame   = errors.New("invalid JSON-LD frame")
        ErrMissingContext = errors.New("context document missing @context")
)

// NewFrameOptions returns default JSON-LD framing options.
func NewFrameOptions(base string) *ld.JsonLdOptions <span class="cov8" title="1">{
        opts := ld.NewJsonLdOptions(base)
        opts.Embed = "@always"
        opts.OmitGraph = true
        return opts
}</span>

// Frame applies a JSON-LD frame to a document.
func Frame(document any, frame map[string]any, opts *ld.JsonLdOptions) (map[string]any, error) <span class="cov8" title="1">{
        if frame == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidFrame
        }</span>
        <span class="cov8" title="1">if opts == nil </span><span class="cov0" title="0">{
                opts = NewFrameOptions("")
        }</span>

        <span class="cov8" title="1">processor := ld.NewJsonLdProcessor()
        result, err := processor.Frame(document, frame, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// EntityFrame builds a frame for a single entity type (Event, Place, Organization).
func EntityFrame(contextDoc map[string]any, entityType string) (map[string]any, error) <span class="cov8" title="1">{
        ctx, err := extractContext(contextDoc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return map[string]any{
                "@context": ctx,
                "@type":    entityType,
        }, nil</span>
}

// EntityListFrame builds a frame for list responses of a given type.
func EntityListFrame(contextDoc map[string]any, entityType string) (map[string]any, error) <span class="cov8" title="1">{
        return EntityFrame(contextDoc, entityType)
}</span>

func extractContext(contextDoc map[string]any) (any, error) <span class="cov8" title="1">{
        ctx, ok := contextDoc["@context"]
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrMissingContext
        }</span>
        <span class="cov8" title="1">return ctx, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package jsonld

import (
        "errors"

        "github.com/piprate/json-gold/ld"
)

var ErrInvalidDocument = errors.New("invalid JSON-LD document")

// Serializer handles JSON-LD compaction and framing using versioned contexts.
type Serializer struct {
        loader *ContextLoader
}

// NewSerializer constructs a serializer with the provided context loader.
func NewSerializer(loader *ContextLoader) *Serializer <span class="cov8" title="1">{
        if loader == nil </span><span class="cov8" title="1">{
                loader = defaultLoader
        }</span>
        <span class="cov8" title="1">return &amp;Serializer{loader: loader}</span>
}

// Compact compacts a JSON-LD document using the specified context version.
func (s *Serializer) Compact(document any, version string) (map[string]any, error) <span class="cov8" title="1">{
        ctxDoc, err := s.loader.Load(version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctx, err := extractContext(ctxDoc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">processor := ld.NewJsonLdProcessor()
        opts := ld.NewJsonLdOptions("")
        opts.CompactArrays = true

        result, err := processor.Compact(document, ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Frame applies a JSON-LD frame to a document with optional framing options.
func (s *Serializer) Frame(document any, frame map[string]any, opts *ld.JsonLdOptions) (map[string]any, error) <span class="cov0" title="0">{
        return Frame(document, frame, opts)
}</span>

// FrameAndCompact frames a document and then compacts the result with the specified context version.
func (s *Serializer) FrameAndCompact(document any, frame map[string]any, version string) (map[string]any, error) <span class="cov8" title="1">{
        framed, err := Frame(document, frame, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return s.Compact(framed, version)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package postgres

import (
        "context"
        "fmt"
        "time"

        "github.com/Togather-Foundation/server/internal/auth"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"
)

type APIKeyRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

func (r *APIKeyRepository) LookupByPrefix(ctx context.Context, prefix string) (*auth.APIKey, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
SELECT id, prefix, key_hash, name, source_id, role, rate_limit_tier, is_active, expires_at
  FROM api_keys
 WHERE prefix = $1
 LIMIT 1
`, prefix)

        var data struct {
                ID            string
                Prefix        string
                Hash          string
                Name          string
                SourceID      *string
                Role          string
                RateLimitTier string
                IsActive      bool
                ExpiresAt     *time.Time
        }
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.Prefix,
                &amp;data.Hash,
                &amp;data.Name,
                &amp;data.SourceID,
                &amp;data.Role,
                &amp;data.RateLimitTier,
                &amp;data.IsActive,
                &amp;data.ExpiresAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, auth.ErrInvalidAPIKey
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("lookup api key: %w", err)</span>
        }

        <span class="cov0" title="0">key := &amp;auth.APIKey{
                ID:            data.ID,
                Prefix:        data.Prefix,
                Hash:          data.Hash,
                Name:          data.Name,
                Role:          data.Role,
                RateLimitTier: data.RateLimitTier,
                IsActive:      data.IsActive,
                ExpiresAt:     data.ExpiresAt,
        }
        if data.SourceID != nil </span><span class="cov0" title="0">{
                key.SourceID = *data.SourceID
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}

func (r *APIKeyRepository) UpdateLastUsed(ctx context.Context, id string) error <span class="cov0" title="0">{
        queryer := r.queryer()
        _, err := queryer.Exec(ctx, `UPDATE api_keys SET last_used_at = now() WHERE id = $1`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update api key last used: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type apiKeyQueryer interface {
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
        Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error)
}

func (r *APIKeyRepository) queryer() apiKeyQueryer <span class="cov0" title="0">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return r.tx
        }</span>
        <span class="cov0" title="0">return r.pool</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package postgres

import (
        "context"
        "fmt"

        "github.com/Togather-Foundation/server/internal/storage"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
)

type Repository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

func NewRepository(pool *pgxpool.Pool) (*Repository, error) <span class="cov0" title="0">{
        if pool == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("postgres repository: pool is nil")
        }</span>
        <span class="cov0" title="0">return &amp;Repository{pool: pool}, nil</span>
}

func (r *Repository) Events() storage.EventRepository <span class="cov0" title="0">{
        return &amp;EventRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Places() storage.PlaceRepository <span class="cov0" title="0">{
        return &amp;PlaceRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Organizations() storage.OrganizationRepository <span class="cov0" title="0">{
        return &amp;OrganizationRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Sources() storage.SourceRepository <span class="cov0" title="0">{
        return &amp;SourceRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Provenance() storage.ProvenanceRepository <span class="cov0" title="0">{
        return &amp;ProvenanceRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Federation() storage.FederationRepository <span class="cov0" title="0">{
        return &amp;FederationRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) Auth() storage.AuthRepository <span class="cov0" title="0">{
        return &amp;AuthRepository{pool: r.pool, tx: r.tx}
}</span>

func (r *Repository) WithTx(ctx context.Context, fn func(context.Context, storage.Repository) error) error <span class="cov0" title="0">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return fn(ctx, r)
        }</span>

        <span class="cov0" title="0">tx, err := r.pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin tx: %w", err)
        }</span>

        <span class="cov0" title="0">wrapped := &amp;Repository{pool: r.pool, tx: tx}
        if err := fn(ctx, wrapped); err != nil </span><span class="cov0" title="0">{
                _ = tx.Rollback(ctx)
                return err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit tx: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EventRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type PlaceRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type OrganizationRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type SourceRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type ProvenanceRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type FederationRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

type AuthRepository struct {
        pool *pgxpool.Pool
        tx   pgx.Tx
}

func (r *AuthRepository) APIKeys() storage.APIKeyRepository <span class="cov0" title="0">{
        return &amp;APIKeyRepository{pool: r.pool, tx: r.tx}
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/api/pagination"
        "github.com/Togather-Foundation/server/internal/domain/events"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgtype"
)

var _ events.Repository = (*EventRepository)(nil)

type eventRow struct {
        ID             string
        ULID           string
        Name           string
        Description    *string
        LicenseURL     *string
        LicenseStatus  *string
        DedupHash      *string
        LifecycleState string
        EventDomain    string
        OrganizerID    *string
        PrimaryVenueID *string
        VirtualURL     *string
        ImageURL       *string
        PublicURL      *string
        Confidence     *float64
        QualityScore   *int32
        Keywords       []string
        CreatedAt      pgtype.Timestamptz
        UpdatedAt      pgtype.Timestamptz
        StartTime      pgtype.Timestamptz
}

func (r *EventRepository) List(ctx context.Context, filters events.Filters, paginationArgs events.Pagination) (events.ListResult, error) <span class="cov8" title="1">{
        queryer := r.queryer()

        var cursorTimestamp *time.Time
        var cursorULID *string
        if strings.TrimSpace(paginationArgs.After) != "" </span><span class="cov0" title="0">{
                cursor, err := pagination.DecodeEventCursor(paginationArgs.After)
                if err != nil </span><span class="cov0" title="0">{
                        return events.ListResult{}, err
                }</span>
                <span class="cov0" title="0">value := cursor.Timestamp.UTC()
                cursorTimestamp = &amp;value
                ulid := strings.ToUpper(cursor.ULID)
                cursorULID = &amp;ulid</span>
        }

        <span class="cov8" title="1">limit := paginationArgs.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov8" title="1">limitPlusOne := limit + 1

        var keywordArray any
        if len(filters.Keywords) &gt; 0 </span><span class="cov8" title="1">{
                keywordArray = filters.Keywords
        }</span>

        <span class="cov8" title="1">rows, err := queryer.Query(ctx, `
SELECT e.id, e.ulid, e.name, e.description, e.license_url, e.license_status, e.dedup_hash,
           e.lifecycle_state, e.event_domain, e.organizer_id, e.primary_venue_id,
           e.virtual_url, e.image_url, e.public_url, e.confidence, e.quality_score,
           e.keywords, e.created_at, e.updated_at, o.start_time
          FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
  LEFT JOIN places p ON p.id = COALESCE(o.venue_id, e.primary_venue_id)
  LEFT JOIN organizations org ON org.id = e.organizer_id
  WHERE ($1::timestamptz IS NULL OR o.start_time &gt;= $1::timestamptz)
    AND ($2::timestamptz IS NULL OR o.start_time &lt;= $2::timestamptz)
    AND ($3 = '' OR p.address_locality ILIKE '%' || $3 || '%')
    AND ($4 = '' OR p.address_region ILIKE '%' || $4 || '%')
    AND ($5 = '' OR p.ulid = $5)
    AND ($6 = '' OR org.ulid = $6)
    AND ($7 = '' OR e.lifecycle_state = $7)
    AND ($8 = '' OR e.event_domain = $8)
    AND ($9 = '' OR (e.name ILIKE '%' || $9 || '%' OR e.description ILIKE '%' || $9 || '%'))
    AND (coalesce(cardinality($10::text[]), 0) = 0 OR e.keywords &amp;&amp; $10::text[])
    AND (
      $11::timestamptz IS NULL OR
      o.start_time &gt; $11::timestamptz OR
      (o.start_time = $11::timestamptz AND e.ulid &gt; $12)
    )
 ORDER BY o.start_time ASC, e.ulid ASC
 LIMIT $13
`,
                filters.StartDate,
                filters.EndDate,
                filters.City,
                filters.Region,
                filters.VenueULID,
                filters.OrganizerULID,
                filters.LifecycleState,
                filters.Domain,
                filters.Query,
                keywordArray,
                cursorTimestamp,
                cursorULID,
                limitPlusOne,
        )
        if err != nil </span><span class="cov0" title="0">{
                return events.ListResult{}, fmt.Errorf("list events: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        items := make([]events.Event, 0, limitPlusOne)
        for rows.Next() </span><span class="cov8" title="1">{
                var row eventRow
                if err := rows.Scan(
                        &amp;row.ID,
                        &amp;row.ULID,
                        &amp;row.Name,
                        &amp;row.Description,
                        &amp;row.LicenseURL,
                        &amp;row.LicenseStatus,
                        &amp;row.DedupHash,
                        &amp;row.LifecycleState,
                        &amp;row.EventDomain,
                        &amp;row.OrganizerID,
                        &amp;row.PrimaryVenueID,
                        &amp;row.VirtualURL,
                        &amp;row.ImageURL,
                        &amp;row.PublicURL,
                        &amp;row.Confidence,
                        &amp;row.QualityScore,
                        &amp;row.Keywords,
                        &amp;row.CreatedAt,
                        &amp;row.UpdatedAt,
                        &amp;row.StartTime,
                ); err != nil </span><span class="cov0" title="0">{
                        return events.ListResult{}, fmt.Errorf("scan events: %w", err)
                }</span>
                <span class="cov8" title="1">event := events.Event{
                        ID:             row.ID,
                        ULID:           row.ULID,
                        Name:           row.Name,
                        Description:    derefString(row.Description),
                        LicenseURL:     derefString(row.LicenseURL),
                        LicenseStatus:  derefString(row.LicenseStatus),
                        DedupHash:      derefString(row.DedupHash),
                        LifecycleState: row.LifecycleState,
                        EventDomain:    row.EventDomain,
                        OrganizerID:    row.OrganizerID,
                        PrimaryVenueID: row.PrimaryVenueID,
                        VirtualURL:     derefString(row.VirtualURL),
                        ImageURL:       derefString(row.ImageURL),
                        PublicURL:      derefString(row.PublicURL),
                        Confidence:     row.Confidence,
                        QualityScore:   intPtr(row.QualityScore),
                        Keywords:       row.Keywords,
                        CreatedAt:      time.Time{},
                        UpdatedAt:      time.Time{},
                }
                if row.CreatedAt.Valid </span><span class="cov8" title="1">{
                        event.CreatedAt = row.CreatedAt.Time
                }</span>
                <span class="cov8" title="1">if row.UpdatedAt.Valid </span><span class="cov8" title="1">{
                        event.UpdatedAt = row.UpdatedAt.Time
                }</span>
                <span class="cov8" title="1">if row.StartTime.Valid </span><span class="cov8" title="1">{
                        event.Occurrences = []events.Occurrence{{StartTime: row.StartTime.Time}}
                }</span>
                <span class="cov8" title="1">items = append(items, event)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return events.ListResult{}, fmt.Errorf("iterate events: %w", err)
        }</span>

        <span class="cov8" title="1">result := events.ListResult{}
        if len(items) &gt; limit </span><span class="cov0" title="0">{
                items = items[:limit]
                last := items[len(items)-1]
                if len(last.Occurrences) &gt; 0 </span><span class="cov0" title="0">{
                        result.NextCursor = pagination.EncodeEventCursor(last.Occurrences[0].StartTime, last.ULID)
                }</span>
        }
        <span class="cov8" title="1">result.Events = items
        return result, nil</span>
}

func (r *EventRepository) GetByULID(ctx context.Context, ulid string) (*events.Event, error) <span class="cov8" title="1">{
        queryer := r.queryer()

        rows, err := queryer.Query(ctx, `
SELECT e.id, e.ulid, e.name, e.description, e.license_url, e.license_status, e.dedup_hash,
           e.lifecycle_state, e.event_domain, e.organizer_id, e.primary_venue_id,
           e.virtual_url, e.image_url, e.public_url, e.confidence, e.quality_score,
           e.keywords, e.created_at, e.updated_at, o.id, o.start_time, o.end_time, o.timezone, o.door_time, o.venue_id, o.virtual_url
          FROM events e
          LEFT JOIN event_occurrences o ON o.event_id = e.id
         WHERE e.ulid = $1
 ORDER BY o.start_time ASC
`, ulid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get event: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var event *events.Event
        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        eventID        string
                        eventULID      string
                        name           string
                        description    *string
                        licenseURL     *string
                        licenseStatus  *string
                        dedupHash      *string
                        lifecycleState string
                        eventDomain    string
                        organizerID    *string
                        primaryVenueID *string
                        virtualURL     *string
                        imageURL       *string
                        publicURL      *string
                        confidence     *float64
                        qualityScore   *int32
                        keywords       []string
                        createdAt      pgtype.Timestamptz
                        updatedAt      pgtype.Timestamptz
                        occurrenceID   *string
                        startTime      pgtype.Timestamptz
                        endTime        pgtype.Timestamptz
                        timezone       *string
                        doorTime       pgtype.Timestamptz
                        venueID        *string
                        occurrenceURL  *string
                )
                if err := rows.Scan(
                        &amp;eventID,
                        &amp;eventULID,
                        &amp;name,
                        &amp;description,
                        &amp;licenseURL,
                        &amp;licenseStatus,
                        &amp;dedupHash,
                        &amp;lifecycleState,
                        &amp;eventDomain,
                        &amp;organizerID,
                        &amp;primaryVenueID,
                        &amp;virtualURL,
                        &amp;imageURL,
                        &amp;publicURL,
                        &amp;confidence,
                        &amp;qualityScore,
                        &amp;keywords,
                        &amp;createdAt,
                        &amp;updatedAt,
                        &amp;occurrenceID,
                        &amp;startTime,
                        &amp;endTime,
                        &amp;timezone,
                        &amp;doorTime,
                        &amp;venueID,
                        &amp;occurrenceURL,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan event: %w", err)
                }</span>

                <span class="cov8" title="1">if event == nil </span><span class="cov8" title="1">{
                        event = &amp;events.Event{
                                ID:             eventID,
                                ULID:           eventULID,
                                Name:           name,
                                Description:    derefString(description),
                                LicenseURL:     derefString(licenseURL),
                                LicenseStatus:  derefString(licenseStatus),
                                DedupHash:      derefString(dedupHash),
                                LifecycleState: lifecycleState,
                                EventDomain:    eventDomain,
                                OrganizerID:    organizerID,
                                PrimaryVenueID: primaryVenueID,
                                VirtualURL:     derefString(virtualURL),
                                ImageURL:       derefString(imageURL),
                                PublicURL:      derefString(publicURL),
                                Confidence:     confidence,
                                QualityScore:   intPtr(qualityScore),
                                Keywords:       keywords,
                                CreatedAt:      time.Time{},
                                UpdatedAt:      time.Time{},
                        }
                        if createdAt.Valid </span><span class="cov8" title="1">{
                                event.CreatedAt = createdAt.Time
                        }</span>
                        <span class="cov8" title="1">if updatedAt.Valid </span><span class="cov8" title="1">{
                                event.UpdatedAt = updatedAt.Time
                        }</span>
                }

                <span class="cov8" title="1">if occurrenceID != nil </span><span class="cov8" title="1">{
                        occ := events.Occurrence{
                                ID:         *occurrenceID,
                                Timezone:   derefString(timezone),
                                VenueID:    venueID,
                                VirtualURL: occurrenceURL,
                        }
                        if startTime.Valid </span><span class="cov8" title="1">{
                                occ.StartTime = startTime.Time
                        }</span>
                        <span class="cov8" title="1">if endTime.Valid </span><span class="cov8" title="1">{
                                value := endTime.Time
                                occ.EndTime = &amp;value
                        }</span>
                        <span class="cov8" title="1">if doorTime.Valid </span><span class="cov0" title="0">{
                                value := doorTime.Time
                                occ.DoorTime = &amp;value
                        }</span>
                        <span class="cov8" title="1">event.Occurrences = append(event.Occurrences, occ)</span>
                }
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("iterate event: %w", err)
        }</span>
        <span class="cov8" title="1">if event == nil </span><span class="cov8" title="1">{
                return nil, events.ErrNotFound
        }</span>
        <span class="cov8" title="1">return event, nil</span>
}

func (r *EventRepository) Create(ctx context.Context, params events.EventCreateParams) (*events.Event, error) <span class="cov0" title="0">{
        queryer := r.queryer()

        row := queryer.QueryRow(ctx, `
INSERT INTO events (
        ulid,
        name,
        description,
        lifecycle_state,
        event_domain,
        organizer_id,
        primary_venue_id,
        virtual_url,
        image_url,
        public_url,
        keywords,
        license_url,
        license_status,
        confidence,
        quality_score
) VALUES (
        $1,
        $2,
        NULLIF($3, ''),
        $4,
        $5,
        $6,
        $7,
        NULLIF($8, ''),
        NULLIF($9, ''),
        NULLIF($10, ''),
        $11,
        $12,
        $13,
        $14,
        $15
)
RETURNING id, ulid, name, description, license_url, license_status, dedup_hash,
          lifecycle_state, event_domain, organizer_id, primary_venue_id,
          virtual_url, image_url, public_url, confidence, quality_score,
          keywords, created_at, updated_at
`,
                params.ULID,
                params.Name,
                params.Description,
                params.LifecycleState,
                params.EventDomain,
                params.OrganizerID,
                params.PrimaryVenueID,
                params.VirtualURL,
                params.ImageURL,
                params.PublicURL,
                params.Keywords,
                params.LicenseURL,
                params.LicenseStatus,
                params.Confidence,
                params.QualityScore,
        )

        var data eventRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.ULID,
                &amp;data.Name,
                &amp;data.Description,
                &amp;data.LicenseURL,
                &amp;data.LicenseStatus,
                &amp;data.DedupHash,
                &amp;data.LifecycleState,
                &amp;data.EventDomain,
                &amp;data.OrganizerID,
                &amp;data.PrimaryVenueID,
                &amp;data.VirtualURL,
                &amp;data.ImageURL,
                &amp;data.PublicURL,
                &amp;data.Confidence,
                &amp;data.QualityScore,
                &amp;data.Keywords,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, events.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("create event: %w", err)</span>
        }

        <span class="cov0" title="0">event := &amp;events.Event{
                ID:             data.ID,
                ULID:           data.ULID,
                Name:           data.Name,
                Description:    derefString(data.Description),
                LicenseURL:     derefString(data.LicenseURL),
                LicenseStatus:  derefString(data.LicenseStatus),
                DedupHash:      derefString(data.DedupHash),
                LifecycleState: data.LifecycleState,
                EventDomain:    data.EventDomain,
                OrganizerID:    data.OrganizerID,
                PrimaryVenueID: data.PrimaryVenueID,
                VirtualURL:     derefString(data.VirtualURL),
                ImageURL:       derefString(data.ImageURL),
                PublicURL:      derefString(data.PublicURL),
                Confidence:     data.Confidence,
                QualityScore:   intPtr(data.QualityScore),
                Keywords:       data.Keywords,
        }
        if data.CreatedAt.Valid </span><span class="cov0" title="0">{
                event.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov0" title="0">if data.UpdatedAt.Valid </span><span class="cov0" title="0">{
                event.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov0" title="0">return event, nil</span>
}

func (r *EventRepository) CreateOccurrence(ctx context.Context, params events.OccurrenceCreateParams) error <span class="cov0" title="0">{
        queryer := r.queryer()

        _, err := queryer.Exec(ctx, `
INSERT INTO event_occurrences (
        event_id,
        start_time,
        end_time,
        timezone,
        door_time,
        venue_id,
        virtual_url
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`,
                params.EventID,
                params.StartTime,
                params.EndTime,
                params.Timezone,
                params.DoorTime,
                params.VenueID,
                params.VirtualURL,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create occurrence: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *EventRepository) CreateSource(ctx context.Context, params events.EventSourceCreateParams) error <span class="cov0" title="0">{
        queryer := r.queryer()

        _, err := queryer.Exec(ctx, `
INSERT INTO event_sources (
        event_id,
        source_id,
        source_url,
        source_event_id,
        payload,
        payload_hash,
        confidence
) VALUES ($1, $2, $3, NULLIF($4, ''), $5, $6, $7)
`,
                params.EventID,
                params.SourceID,
                params.SourceURL,
                params.SourceEventID,
                params.Payload,
                params.PayloadHash,
                params.Confidence,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create event source: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *EventRepository) FindBySourceExternalID(ctx context.Context, sourceID string, sourceEventID string) (*events.Event, error) <span class="cov0" title="0">{
        if strings.TrimSpace(sourceID) == "" || strings.TrimSpace(sourceEventID) == "" </span><span class="cov0" title="0">{
                return nil, events.ErrNotFound
        }</span>
        <span class="cov0" title="0">queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
SELECT e.id, e.ulid, e.name, e.description, e.license_url, e.license_status, e.dedup_hash,
           e.lifecycle_state, e.event_domain, e.organizer_id, e.primary_venue_id,
           e.virtual_url, e.image_url, e.public_url, e.keywords, e.created_at, e.updated_at
  FROM events e
  JOIN event_sources es ON es.event_id = e.id
 WHERE es.source_id = $1 AND es.source_event_id = $2
 LIMIT 1
`, sourceID, sourceEventID)

        var data eventRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.ULID,
                &amp;data.Name,
                &amp;data.Description,
                &amp;data.LicenseURL,
                &amp;data.LicenseStatus,
                &amp;data.DedupHash,
                &amp;data.LifecycleState,
                &amp;data.EventDomain,
                &amp;data.OrganizerID,
                &amp;data.PrimaryVenueID,
                &amp;data.VirtualURL,
                &amp;data.ImageURL,
                &amp;data.PublicURL,
                &amp;data.Keywords,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, events.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("find event by source: %w", err)</span>
        }

        <span class="cov0" title="0">event := &amp;events.Event{
                ID:             data.ID,
                ULID:           data.ULID,
                Name:           data.Name,
                Description:    derefString(data.Description),
                LicenseURL:     derefString(data.LicenseURL),
                LicenseStatus:  derefString(data.LicenseStatus),
                DedupHash:      derefString(data.DedupHash),
                LifecycleState: data.LifecycleState,
                EventDomain:    data.EventDomain,
                OrganizerID:    data.OrganizerID,
                PrimaryVenueID: data.PrimaryVenueID,
                VirtualURL:     derefString(data.VirtualURL),
                ImageURL:       derefString(data.ImageURL),
                PublicURL:      derefString(data.PublicURL),
                Keywords:       data.Keywords,
        }
        if data.CreatedAt.Valid </span><span class="cov0" title="0">{
                event.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov0" title="0">if data.UpdatedAt.Valid </span><span class="cov0" title="0">{
                event.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov0" title="0">return event, nil</span>
}

func (r *EventRepository) FindByDedupHash(ctx context.Context, dedupHash string) (*events.Event, error) <span class="cov0" title="0">{
        if strings.TrimSpace(dedupHash) == "" </span><span class="cov0" title="0">{
                return nil, events.ErrNotFound
        }</span>
        <span class="cov0" title="0">queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
SELECT e.id, e.ulid, e.name, e.description, e.license_url, e.license_status, e.dedup_hash,
           e.lifecycle_state, e.event_domain, e.organizer_id, e.primary_venue_id,
           e.virtual_url, e.image_url, e.public_url, e.keywords, e.created_at, e.updated_at
  FROM events e
 WHERE e.dedup_hash = $1
 LIMIT 1
`, dedupHash)

        var data eventRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.ULID,
                &amp;data.Name,
                &amp;data.Description,
                &amp;data.LicenseURL,
                &amp;data.LicenseStatus,
                &amp;data.DedupHash,
                &amp;data.LifecycleState,
                &amp;data.EventDomain,
                &amp;data.OrganizerID,
                &amp;data.PrimaryVenueID,
                &amp;data.VirtualURL,
                &amp;data.ImageURL,
                &amp;data.PublicURL,
                &amp;data.Keywords,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, events.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("find event by dedup hash: %w", err)</span>
        }

        <span class="cov0" title="0">event := &amp;events.Event{
                ID:             data.ID,
                ULID:           data.ULID,
                Name:           data.Name,
                Description:    derefString(data.Description),
                LicenseURL:     derefString(data.LicenseURL),
                LicenseStatus:  derefString(data.LicenseStatus),
                DedupHash:      derefString(data.DedupHash),
                LifecycleState: data.LifecycleState,
                EventDomain:    data.EventDomain,
                OrganizerID:    data.OrganizerID,
                PrimaryVenueID: data.PrimaryVenueID,
                VirtualURL:     derefString(data.VirtualURL),
                ImageURL:       derefString(data.ImageURL),
                PublicURL:      derefString(data.PublicURL),
                Keywords:       data.Keywords,
        }
        if data.CreatedAt.Valid </span><span class="cov0" title="0">{
                event.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov0" title="0">if data.UpdatedAt.Valid </span><span class="cov0" title="0">{
                event.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov0" title="0">return event, nil</span>
}

func (r *EventRepository) GetOrCreateSource(ctx context.Context, params events.SourceLookupParams) (string, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
SELECT id
  FROM sources
 WHERE base_url = $1
 LIMIT 1
`, strings.TrimSpace(params.BaseURL))

        var id string
        if err := row.Scan(&amp;id); err == nil </span><span class="cov0" title="0">{
                return id, nil
        }</span> else<span class="cov0" title="0"> if err != pgx.ErrNoRows </span><span class="cov0" title="0">{
                return "", fmt.Errorf("get source: %w", err)
        }</span>

        <span class="cov0" title="0">row = queryer.QueryRow(ctx, `
INSERT INTO sources (
        name,
        source_type,
        base_url,
        license_url,
        license_type,
        trust_level
) VALUES ($1, $2, NULLIF($3, ''), $4, $5, $6)
RETURNING id
`,
                params.Name,
                params.SourceType,
                params.BaseURL,
                params.LicenseURL,
                params.LicenseType,
                params.TrustLevel,
        )
        if err := row.Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("create source: %w", err)
        }</span>
        <span class="cov0" title="0">return id, nil</span>
}

func (r *EventRepository) GetIdempotencyKey(ctx context.Context, key string) (*events.IdempotencyKey, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
SELECT key, request_hash, event_id, event_ulid
  FROM idempotency_keys
 WHERE key = $1
`, strings.TrimSpace(key))

        var (
                id     *string
                ulid   *string
                result events.IdempotencyKey
        )
        if err := row.Scan(&amp;result.Key, &amp;result.RequestHash, &amp;id, &amp;ulid); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, events.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get idempotency key: %w", err)</span>
        }
        <span class="cov0" title="0">result.EventID = id
        result.EventULID = ulid
        return &amp;result, nil</span>
}

func (r *EventRepository) InsertIdempotencyKey(ctx context.Context, params events.IdempotencyKeyCreateParams) (*events.IdempotencyKey, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
INSERT INTO idempotency_keys (key, request_hash, event_id, event_ulid)
VALUES ($1, $2, NULLIF($3, '')::uuid, NULLIF($4, ''))
RETURNING key, request_hash, event_id, event_ulid
`,
                params.Key,
                params.RequestHash,
                params.EventID,
                params.EventULID,
        )
        var (
                id     *string
                ulid   *string
                result events.IdempotencyKey
        )
        if err := row.Scan(&amp;result.Key, &amp;result.RequestHash, &amp;id, &amp;ulid); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insert idempotency key: %w", err)
        }</span>
        <span class="cov0" title="0">result.EventID = id
        result.EventULID = ulid
        return &amp;result, nil</span>
}

func (r *EventRepository) UpdateIdempotencyKeyEvent(ctx context.Context, key string, eventID string, eventULID string) error <span class="cov0" title="0">{
        queryer := r.queryer()
        command, err := queryer.Exec(ctx, `
UPDATE idempotency_keys
   SET event_id = $2, event_ulid = $3
 WHERE key = $1
`, strings.TrimSpace(key), eventID, eventULID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update idempotency key: %w", err)
        }</span>
        <span class="cov0" title="0">if command.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return events.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *EventRepository) UpsertPlace(ctx context.Context, params events.PlaceCreateParams) (*events.PlaceRecord, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
INSERT INTO places (ulid, name, address_locality, address_region, address_country)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (ulid) DO UPDATE
SET name = EXCLUDED.name
RETURNING id, ulid
`,
                params.ULID,
                params.Name,
                params.AddressLocality,
                params.AddressRegion,
                params.AddressCountry,
        )
        var record events.PlaceRecord
        if err := row.Scan(&amp;record.ID, &amp;record.ULID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("upsert place: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;record, nil</span>
}

func (r *EventRepository) UpsertOrganization(ctx context.Context, params events.OrganizationCreateParams) (*events.OrganizationRecord, error) <span class="cov0" title="0">{
        queryer := r.queryer()
        row := queryer.QueryRow(ctx, `
INSERT INTO organizations (ulid, name, address_locality, address_region, address_country)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (ulid) DO UPDATE
SET name = EXCLUDED.name
RETURNING id, ulid
`,
                params.ULID,
                params.Name,
                params.AddressLocality,
                params.AddressRegion,
                params.AddressCountry,
        )
        var record events.OrganizationRecord
        if err := row.Scan(&amp;record.ID, &amp;record.ULID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("upsert organization: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;record, nil</span>
}

type queryer interface {
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
        Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error)
}

func (r *EventRepository) queryer() queryer <span class="cov8" title="1">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return r.tx
        }</span>
        <span class="cov8" title="1">return r.pool</span>
}

func derefString(value *string) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return *value</span>
}

func intPtr(value *int32) *int <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">converted := int(*value)
        return &amp;converted</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package postgres

import (
        "errors"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

const DefaultMigrationsPath = "internal/storage/postgres/migrations"

func MigrateUp(databaseURL string, migrationsPath string) error <span class="cov8" title="1">{
        m, err := newMigrator(databaseURL, migrationsPath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                sourceErr, dbErr := m.Close()
                if sourceErr != nil </span><span class="cov0" title="0">{
                        _ = sourceErr
                }</span>
                <span class="cov8" title="1">if dbErr != nil </span><span class="cov0" title="0">{
                        _ = dbErr
                }</span>
        }()

        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate up: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func MigrateDown(databaseURL string, migrationsPath string, steps int) error <span class="cov0" title="0">{
        if steps &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate down: steps must be &gt; 0")
        }</span>
        <span class="cov0" title="0">m, err := newMigrator(databaseURL, migrationsPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                sourceErr, dbErr := m.Close()
                if sourceErr != nil </span><span class="cov0" title="0">{
                        _ = sourceErr
                }</span>
                <span class="cov0" title="0">if dbErr != nil </span><span class="cov0" title="0">{
                        _ = dbErr
                }</span>
        }()

        <span class="cov0" title="0">if err := m.Steps(-steps); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate down: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func newMigrator(databaseURL string, migrationsPath string) (*migrate.Migrate, error) <span class="cov8" title="1">{
        if migrationsPath == "" </span><span class="cov0" title="0">{
                migrationsPath = DefaultMigrationsPath
        }</span>
        <span class="cov8" title="1">m, err := migrate.New("file://"+migrationsPath, databaseURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("init migrator: %w", err)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/api/pagination"
        "github.com/Togather-Foundation/server/internal/domain/organizations"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"
)

var _ organizations.Repository = (*OrganizationRepository)(nil)

type organizationRow struct {
        ID        string
        ULID      string
        Name      string
        LegalName *string
        URL       *string
        CreatedAt pgtype.Timestamptz
        UpdatedAt pgtype.Timestamptz
}

func (r *OrganizationRepository) List(ctx context.Context, filters organizations.Filters, paginationArgs organizations.Pagination) (organizations.ListResult, error) <span class="cov8" title="1">{
        queryer := r.queryer()
        query := strings.TrimSpace(filters.Query)
        limit := paginationArgs.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov8" title="1">limitPlusOne := limit + 1

        var cursorTime *time.Time
        var cursorULID *string
        if strings.TrimSpace(paginationArgs.After) != "" </span><span class="cov8" title="1">{
                cursor, err := pagination.DecodeEventCursor(paginationArgs.After)
                if err != nil </span><span class="cov0" title="0">{
                        return organizations.ListResult{}, err
                }</span>
                <span class="cov8" title="1">value := cursor.Timestamp.UTC()
                cursorTime = &amp;value
                ulid := strings.ToUpper(strings.TrimSpace(cursor.ULID))
                cursorULID = &amp;ulid</span>
        }

        <span class="cov8" title="1">rows, err := queryer.Query(ctx, `
SELECT o.id, o.ulid, o.name, o.legal_name, o.url, o.created_at, o.updated_at
  FROM organizations o
 WHERE ($1 = '' OR o.name ILIKE '%' || $1 || '%' OR o.legal_name ILIKE '%' || $1 || '%')
   AND (
     $2::timestamptz IS NULL OR
     o.created_at &gt; $2::timestamptz OR
     (o.created_at = $2::timestamptz AND o.ulid &gt; $3)
   )
 ORDER BY o.created_at ASC, o.ulid ASC
 LIMIT $4
`,
                query,
                cursorTime,
                cursorULID,
                limitPlusOne,
        )
        if err != nil </span><span class="cov0" title="0">{
                return organizations.ListResult{}, fmt.Errorf("list organizations: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        items := make([]organizations.Organization, 0, limitPlusOne)
        for rows.Next() </span><span class="cov8" title="1">{
                var row organizationRow
                if err := rows.Scan(
                        &amp;row.ID,
                        &amp;row.ULID,
                        &amp;row.Name,
                        &amp;row.LegalName,
                        &amp;row.URL,
                        &amp;row.CreatedAt,
                        &amp;row.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return organizations.ListResult{}, fmt.Errorf("scan organizations: %w", err)
                }</span>
                <span class="cov8" title="1">org := organizations.Organization{
                        ID:        row.ID,
                        ULID:      row.ULID,
                        Name:      row.Name,
                        LegalName: derefString(row.LegalName),
                        URL:       derefString(row.URL),
                        CreatedAt: time.Time{},
                        UpdatedAt: time.Time{},
                }
                if row.CreatedAt.Valid </span><span class="cov8" title="1">{
                        org.CreatedAt = row.CreatedAt.Time
                }</span>
                <span class="cov8" title="1">if row.UpdatedAt.Valid </span><span class="cov8" title="1">{
                        org.UpdatedAt = row.UpdatedAt.Time
                }</span>
                <span class="cov8" title="1">items = append(items, org)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return organizations.ListResult{}, fmt.Errorf("iterate organizations: %w", err)
        }</span>

        <span class="cov8" title="1">result := organizations.ListResult{}
        if len(items) &gt; limit </span><span class="cov8" title="1">{
                items = items[:limit]
                last := items[len(items)-1]
                result.NextCursor = pagination.EncodeEventCursor(last.CreatedAt, last.ULID)
        }</span>
        <span class="cov8" title="1">result.Organizations = items
        return result, nil</span>
}

func (r *OrganizationRepository) GetByULID(ctx context.Context, ulid string) (*organizations.Organization, error) <span class="cov8" title="1">{
        queryer := r.queryer()

        row := queryer.QueryRow(ctx, `
SELECT o.id, o.ulid, o.name, o.legal_name, o.url, o.created_at, o.updated_at
  FROM organizations o
 WHERE o.ulid = $1
`, ulid)

        var data organizationRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.ULID,
                &amp;data.Name,
                &amp;data.LegalName,
                &amp;data.URL,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, organizations.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get organization: %w", err)</span>
        }

        <span class="cov8" title="1">org := &amp;organizations.Organization{
                ID:        data.ID,
                ULID:      data.ULID,
                Name:      data.Name,
                LegalName: derefString(data.LegalName),
                URL:       derefString(data.URL),
                CreatedAt: time.Time{},
                UpdatedAt: time.Time{},
        }
        if data.CreatedAt.Valid </span><span class="cov8" title="1">{
                org.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov8" title="1">if data.UpdatedAt.Valid </span><span class="cov8" title="1">{
                org.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov8" title="1">return org, nil</span>
}

type organizationQueryer interface {
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

func (r *OrganizationRepository) queryer() organizationQueryer <span class="cov8" title="1">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return r.tx
        }</span>
        <span class="cov8" title="1">return r.pool</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/api/pagination"
        "github.com/Togather-Foundation/server/internal/domain/places"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"
)

var _ places.Repository = (*PlaceRepository)(nil)

type placeRow struct {
        ID          string
        ULID        string
        Name        string
        Description *string
        City        *string
        Region      *string
        Country     *string
        CreatedAt   pgtype.Timestamptz
        UpdatedAt   pgtype.Timestamptz
}

func (r *PlaceRepository) List(ctx context.Context, filters places.Filters, paginationArgs places.Pagination) (places.ListResult, error) <span class="cov8" title="1">{
        queryer := r.queryer()

        var cursorTimestamp *time.Time
        var cursorULID *string
        if strings.TrimSpace(paginationArgs.After) != "" </span><span class="cov8" title="1">{
                cursor, err := pagination.DecodeEventCursor(paginationArgs.After)
                if err != nil </span><span class="cov0" title="0">{
                        return places.ListResult{}, err
                }</span>
                <span class="cov8" title="1">value := cursor.Timestamp.UTC()
                cursorTimestamp = &amp;value
                ulid := strings.ToUpper(cursor.ULID)
                cursorULID = &amp;ulid</span>
        }

        <span class="cov8" title="1">limit := paginationArgs.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov8" title="1">limitPlusOne := limit + 1

        rows, err := queryer.Query(ctx, `
SELECT p.id, p.ulid, p.name, p.description, p.address_locality, p.address_region, p.address_country,
       p.created_at, p.updated_at
  FROM places p
 WHERE ($1 = '' OR p.address_locality ILIKE '%' || $1 || '%')
   AND ($2 = '' OR p.name ILIKE '%' || $2 || '%' OR p.description ILIKE '%' || $2 || '%')
   AND (
     $3::timestamptz IS NULL OR
     p.created_at &gt; $3::timestamptz OR
     (p.created_at = $3::timestamptz AND p.ulid &gt; $4)
   )
 ORDER BY p.created_at ASC, p.ulid ASC
 LIMIT $5
`,
                filters.City,
                filters.Query,
                cursorTimestamp,
                cursorULID,
                limitPlusOne,
        )
        if err != nil </span><span class="cov0" title="0">{
                return places.ListResult{}, fmt.Errorf("list places: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        items := make([]places.Place, 0, limitPlusOne)
        for rows.Next() </span><span class="cov8" title="1">{
                var row placeRow
                if err := rows.Scan(
                        &amp;row.ID,
                        &amp;row.ULID,
                        &amp;row.Name,
                        &amp;row.Description,
                        &amp;row.City,
                        &amp;row.Region,
                        &amp;row.Country,
                        &amp;row.CreatedAt,
                        &amp;row.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return places.ListResult{}, fmt.Errorf("scan places: %w", err)
                }</span>
                <span class="cov8" title="1">place := places.Place{
                        ID:          row.ID,
                        ULID:        row.ULID,
                        Name:        row.Name,
                        Description: derefString(row.Description),
                        City:        derefString(row.City),
                        Region:      derefString(row.Region),
                        Country:     derefString(row.Country),
                        CreatedAt:   time.Time{},
                        UpdatedAt:   time.Time{},
                }
                if row.CreatedAt.Valid </span><span class="cov8" title="1">{
                        place.CreatedAt = row.CreatedAt.Time
                }</span>
                <span class="cov8" title="1">if row.UpdatedAt.Valid </span><span class="cov8" title="1">{
                        place.UpdatedAt = row.UpdatedAt.Time
                }</span>
                <span class="cov8" title="1">items = append(items, place)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return places.ListResult{}, fmt.Errorf("iterate places: %w", err)
        }</span>

        <span class="cov8" title="1">result := places.ListResult{}
        if len(items) &gt; limit </span><span class="cov8" title="1">{
                items = items[:limit]
                last := items[len(items)-1]
                if !last.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                        result.NextCursor = pagination.EncodeEventCursor(last.CreatedAt, last.ULID)
                }</span>
        }
        <span class="cov8" title="1">result.Places = items
        return result, nil</span>
}

func (r *PlaceRepository) GetByULID(ctx context.Context, ulid string) (*places.Place, error) <span class="cov8" title="1">{
        queryer := r.queryer()

        row := queryer.QueryRow(ctx, `
SELECT p.id, p.ulid, p.name, p.description, p.address_locality, p.address_region, p.address_country,
       p.created_at, p.updated_at
  FROM places p
 WHERE p.ulid = $1
`, ulid)

        var data placeRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.ULID,
                &amp;data.Name,
                &amp;data.Description,
                &amp;data.City,
                &amp;data.Region,
                &amp;data.Country,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if err == pgx.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, places.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get place: %w", err)</span>
        }

        <span class="cov8" title="1">place := &amp;places.Place{
                ID:          data.ID,
                ULID:        data.ULID,
                Name:        data.Name,
                Description: derefString(data.Description),
                City:        derefString(data.City),
                Region:      derefString(data.Region),
                Country:     derefString(data.Country),
                CreatedAt:   time.Time{},
                UpdatedAt:   time.Time{},
        }
        if data.CreatedAt.Valid </span><span class="cov8" title="1">{
                place.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov8" title="1">if data.UpdatedAt.Valid </span><span class="cov8" title="1">{
                place.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov8" title="1">return place, nil</span>
}

type placeQueryer interface {
        Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

func (r *PlaceRepository) queryer() placeQueryer <span class="cov8" title="1">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return r.tx
        }</span>
        <span class="cov8" title="1">return r.pool</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package postgres

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/Togather-Foundation/server/internal/domain/provenance"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgtype"
)

var _ provenance.Repository = (*ProvenanceRepository)(nil)

type sourceRow struct {
        ID          string
        Name        string
        SourceType  string
        BaseURL     *string
        LicenseURL  string
        LicenseType string
        TrustLevel  int
        IsActive    bool
        CreatedAt   pgtype.Timestamptz
        UpdatedAt   pgtype.Timestamptz
}

func (r *ProvenanceRepository) GetByBaseURL(ctx context.Context, baseURL string) (*provenance.Source, error) <span class="cov0" title="0">{
        queryer := r.queryer()

        row := queryer.QueryRow(ctx, `
SELECT id, name, source_type, base_url, license_url, license_type, trust_level, is_active, created_at, updated_at
  FROM sources
 WHERE base_url = $1
 LIMIT 1
`, strings.TrimSpace(baseURL))

        var data sourceRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.Name,
                &amp;data.SourceType,
                &amp;data.BaseURL,
                &amp;data.LicenseURL,
                &amp;data.LicenseType,
                &amp;data.TrustLevel,
                &amp;data.IsActive,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == pgx.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, provenance.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get source by base url: %w", err)</span>
        }

        <span class="cov0" title="0">return mapSourceRow(data), nil</span>
}

func (r *ProvenanceRepository) Create(ctx context.Context, params provenance.CreateSourceParams) (*provenance.Source, error) <span class="cov0" title="0">{
        queryer := r.queryer()

        row := queryer.QueryRow(ctx, `
INSERT INTO sources (
        name,
        source_type,
        base_url,
        license_url,
        license_type,
        trust_level
) VALUES ($1, $2, NULLIF($3, ''), $4, $5, $6)
RETURNING id, name, source_type, base_url, license_url, license_type, trust_level, is_active, created_at, updated_at
`,
                params.Name,
                params.SourceType,
                params.BaseURL,
                params.LicenseURL,
                params.LicenseType,
                params.TrustLevel,
        )

        var data sourceRow
        if err := row.Scan(
                &amp;data.ID,
                &amp;data.Name,
                &amp;data.SourceType,
                &amp;data.BaseURL,
                &amp;data.LicenseURL,
                &amp;data.LicenseType,
                &amp;data.TrustLevel,
                &amp;data.IsActive,
                &amp;data.CreatedAt,
                &amp;data.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create source: %w", err)
        }</span>

        <span class="cov0" title="0">return mapSourceRow(data), nil</span>
}

type provenanceQueryer interface {
        QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

func (r *ProvenanceRepository) queryer() provenanceQueryer <span class="cov0" title="0">{
        if r.tx != nil </span><span class="cov0" title="0">{
                return r.tx
        }</span>
        <span class="cov0" title="0">return r.pool</span>
}

func mapSourceRow(data sourceRow) *provenance.Source <span class="cov0" title="0">{
        source := &amp;provenance.Source{
                ID:          data.ID,
                Name:        data.Name,
                SourceType:  data.SourceType,
                LicenseURL:  data.LicenseURL,
                LicenseType: data.LicenseType,
                TrustLevel:  data.TrustLevel,
                IsActive:    data.IsActive,
                CreatedAt:   time.Time{},
                UpdatedAt:   time.Time{},
        }
        if data.BaseURL != nil </span><span class="cov0" title="0">{
                source.BaseURL = *data.BaseURL
        }</span>
        <span class="cov0" title="0">if data.CreatedAt.Valid </span><span class="cov0" title="0">{
                source.CreatedAt = data.CreatedAt.Time
        }</span>
        <span class="cov0" title="0">if data.UpdatedAt.Valid </span><span class="cov0" title="0">{
                source.UpdatedAt = data.UpdatedAt.Time
        }</span>
        <span class="cov0" title="0">return source</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
