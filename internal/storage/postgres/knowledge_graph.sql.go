// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: knowledge_graph.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredCache = `-- name: CleanupExpiredCache :execresult
DELETE FROM reconciliation_cache WHERE expires_at <= now()
`

// Delete expired cache entries
func (q *Queries) CleanupExpiredCache(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, cleanupExpiredCache)
}

const countUnreconciledEntities = `-- name: CountUnreconciledEntities :one
SELECT COUNT(DISTINCT e.ulid)::bigint
FROM (
    SELECT ulid FROM places WHERE deleted_at IS NULL
    UNION ALL
    SELECT ulid FROM organizations WHERE deleted_at IS NULL
) e
LEFT JOIN entity_identifiers ei ON ei.entity_id = e.ulid
WHERE ei.id IS NULL
`

// Count entities of a type that have no external identifiers
func (q *Queries) CountUnreconciledEntities(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUnreconciledEntities)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteEntityIdentifier = `-- name: DeleteEntityIdentifier :exec
DELETE FROM entity_identifiers WHERE id = $1
`

// Delete a specific entity identifier
func (q *Queries) DeleteEntityIdentifier(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEntityIdentifier, id)
	return err
}

const getActiveAuthorities = `-- name: GetActiveAuthorities :many

SELECT id, authority_code, authority_name, base_uri_pattern, reconciliation_endpoint, applicable_domains, trust_level, priority_order, rate_limit_per_minute, rate_limit_per_day, is_active, documentation_url, created_at, updated_at FROM knowledge_graph_authorities
WHERE is_active = true
ORDER BY priority_order ASC
`

// SQLc queries for knowledge graph reconciliation.
// Get active knowledge graph authorities ordered by priority
func (q *Queries) GetActiveAuthorities(ctx context.Context) ([]KnowledgeGraphAuthority, error) {
	rows, err := q.db.Query(ctx, getActiveAuthorities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KnowledgeGraphAuthority{}
	for rows.Next() {
		var i KnowledgeGraphAuthority
		if err := rows.Scan(
			&i.ID,
			&i.AuthorityCode,
			&i.AuthorityName,
			&i.BaseUriPattern,
			&i.ReconciliationEndpoint,
			&i.ApplicableDomains,
			&i.TrustLevel,
			&i.PriorityOrder,
			&i.RateLimitPerMinute,
			&i.RateLimitPerDay,
			&i.IsActive,
			&i.DocumentationUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthoritiesForDomain = `-- name: GetAuthoritiesForDomain :many
SELECT id, authority_code, authority_name, base_uri_pattern, reconciliation_endpoint, applicable_domains, trust_level, priority_order, rate_limit_per_minute, rate_limit_per_day, is_active, documentation_url, created_at, updated_at FROM knowledge_graph_authorities
WHERE is_active = true AND $1::text = ANY(applicable_domains)
ORDER BY priority_order ASC
`

// Get active authorities applicable to a given event domain
func (q *Queries) GetAuthoritiesForDomain(ctx context.Context, domain string) ([]KnowledgeGraphAuthority, error) {
	rows, err := q.db.Query(ctx, getAuthoritiesForDomain, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KnowledgeGraphAuthority{}
	for rows.Next() {
		var i KnowledgeGraphAuthority
		if err := rows.Scan(
			&i.ID,
			&i.AuthorityCode,
			&i.AuthorityName,
			&i.BaseUriPattern,
			&i.ReconciliationEndpoint,
			&i.ApplicableDomains,
			&i.TrustLevel,
			&i.PriorityOrder,
			&i.RateLimitPerMinute,
			&i.RateLimitPerDay,
			&i.IsActive,
			&i.DocumentationUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorityByCode = `-- name: GetAuthorityByCode :one
SELECT id, authority_code, authority_name, base_uri_pattern, reconciliation_endpoint, applicable_domains, trust_level, priority_order, rate_limit_per_minute, rate_limit_per_day, is_active, documentation_url, created_at, updated_at FROM knowledge_graph_authorities
WHERE authority_code = $1
`

func (q *Queries) GetAuthorityByCode(ctx context.Context, authorityCode string) (KnowledgeGraphAuthority, error) {
	row := q.db.QueryRow(ctx, getAuthorityByCode, authorityCode)
	var i KnowledgeGraphAuthority
	err := row.Scan(
		&i.ID,
		&i.AuthorityCode,
		&i.AuthorityName,
		&i.BaseUriPattern,
		&i.ReconciliationEndpoint,
		&i.ApplicableDomains,
		&i.TrustLevel,
		&i.PriorityOrder,
		&i.RateLimitPerMinute,
		&i.RateLimitPerDay,
		&i.IsActive,
		&i.DocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEntityIdentifiers = `-- name: GetEntityIdentifiers :many
SELECT id, entity_type, entity_id, authority_code, identifier_uri, confidence, reconciliation_method, is_canonical, metadata, created_at, updated_at FROM entity_identifiers
WHERE entity_type = $1 AND entity_id = $2
ORDER BY confidence DESC
`

type GetEntityIdentifiersParams struct {
	EntityType string `json:"entity_type"`
	EntityID   string `json:"entity_id"`
}

// Get all external identifiers for an entity
func (q *Queries) GetEntityIdentifiers(ctx context.Context, arg GetEntityIdentifiersParams) ([]EntityIdentifier, error) {
	rows, err := q.db.Query(ctx, getEntityIdentifiers, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityIdentifier{}
	for rows.Next() {
		var i EntityIdentifier
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorityCode,
			&i.IdentifierUri,
			&i.Confidence,
			&i.ReconciliationMethod,
			&i.IsCanonical,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityIdentifiersByAuthority = `-- name: GetEntityIdentifiersByAuthority :many
SELECT id, entity_type, entity_id, authority_code, identifier_uri, confidence, reconciliation_method, is_canonical, metadata, created_at, updated_at FROM entity_identifiers
WHERE entity_type = $1 AND entity_id = $2 AND authority_code = $3
ORDER BY confidence DESC
`

type GetEntityIdentifiersByAuthorityParams struct {
	EntityType    string `json:"entity_type"`
	EntityID      string `json:"entity_id"`
	AuthorityCode string `json:"authority_code"`
}

// Get identifiers for an entity from a specific authority
func (q *Queries) GetEntityIdentifiersByAuthority(ctx context.Context, arg GetEntityIdentifiersByAuthorityParams) ([]EntityIdentifier, error) {
	rows, err := q.db.Query(ctx, getEntityIdentifiersByAuthority, arg.EntityType, arg.EntityID, arg.AuthorityCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityIdentifier{}
	for rows.Next() {
		var i EntityIdentifier
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.AuthorityCode,
			&i.IdentifierUri,
			&i.Confidence,
			&i.ReconciliationMethod,
			&i.IsCanonical,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReconciliationCache = `-- name: GetReconciliationCache :one
SELECT id, entity_type, authority_code, lookup_key, result_json, hit_count, is_negative, expires_at, created_at, updated_at FROM reconciliation_cache
WHERE entity_type = $1 AND authority_code = $2 AND lookup_key = $3
AND expires_at > now()
`

type GetReconciliationCacheParams struct {
	EntityType    string `json:"entity_type"`
	AuthorityCode string `json:"authority_code"`
	LookupKey     string `json:"lookup_key"`
}

// Check cache for a previous reconciliation result
func (q *Queries) GetReconciliationCache(ctx context.Context, arg GetReconciliationCacheParams) (ReconciliationCache, error) {
	row := q.db.QueryRow(ctx, getReconciliationCache, arg.EntityType, arg.AuthorityCode, arg.LookupKey)
	var i ReconciliationCache
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.AuthorityCode,
		&i.LookupKey,
		&i.ResultJson,
		&i.HitCount,
		&i.IsNegative,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUnreconciledOrganizations = `-- name: ListUnreconciledOrganizations :many
SELECT o.ulid, o.name, o.legal_name, o.url, o.address_locality, o.address_region, o.postal_code, o.address_country
FROM organizations o
LEFT JOIN entity_identifiers ei ON ei.entity_type = 'organization' AND ei.entity_id = o.ulid
WHERE o.deleted_at IS NULL AND ei.id IS NULL
ORDER BY o.created_at ASC
LIMIT $1
`

type ListUnreconciledOrganizationsRow struct {
	Ulid            string      `json:"ulid"`
	Name            string      `json:"name"`
	LegalName       pgtype.Text `json:"legal_name"`
	Url             pgtype.Text `json:"url"`
	AddressLocality pgtype.Text `json:"address_locality"`
	AddressRegion   pgtype.Text `json:"address_region"`
	PostalCode      pgtype.Text `json:"postal_code"`
	AddressCountry  pgtype.Text `json:"address_country"`
}

// Get organizations that have no external identifiers, ordered by creation date
func (q *Queries) ListUnreconciledOrganizations(ctx context.Context, maxResults int32) ([]ListUnreconciledOrganizationsRow, error) {
	rows, err := q.db.Query(ctx, listUnreconciledOrganizations, maxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUnreconciledOrganizationsRow{}
	for rows.Next() {
		var i ListUnreconciledOrganizationsRow
		if err := rows.Scan(
			&i.Ulid,
			&i.Name,
			&i.LegalName,
			&i.Url,
			&i.AddressLocality,
			&i.AddressRegion,
			&i.PostalCode,
			&i.AddressCountry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreconciledPlaces = `-- name: ListUnreconciledPlaces :many
SELECT p.ulid, p.name, p.street_address, p.address_locality, p.address_region, p.postal_code, p.address_country, p.url
FROM places p
LEFT JOIN entity_identifiers ei ON ei.entity_type = 'place' AND ei.entity_id = p.ulid
WHERE p.deleted_at IS NULL AND ei.id IS NULL
ORDER BY p.created_at ASC
LIMIT $1
`

type ListUnreconciledPlacesRow struct {
	Ulid            string      `json:"ulid"`
	Name            string      `json:"name"`
	StreetAddress   pgtype.Text `json:"street_address"`
	AddressLocality pgtype.Text `json:"address_locality"`
	AddressRegion   pgtype.Text `json:"address_region"`
	PostalCode      pgtype.Text `json:"postal_code"`
	AddressCountry  pgtype.Text `json:"address_country"`
	Url             pgtype.Text `json:"url"`
}

// Get places that have no external identifiers, ordered by creation date
func (q *Queries) ListUnreconciledPlaces(ctx context.Context, maxResults int32) ([]ListUnreconciledPlacesRow, error) {
	rows, err := q.db.Query(ctx, listUnreconciledPlaces, maxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUnreconciledPlacesRow{}
	for rows.Next() {
		var i ListUnreconciledPlacesRow
		if err := rows.Scan(
			&i.Ulid,
			&i.Name,
			&i.StreetAddress,
			&i.AddressLocality,
			&i.AddressRegion,
			&i.PostalCode,
			&i.AddressCountry,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEntityIdentifier = `-- name: UpsertEntityIdentifier :one
INSERT INTO entity_identifiers (entity_type, entity_id, authority_code, identifier_uri, confidence, reconciliation_method, is_canonical, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (entity_type, entity_id, authority_code, identifier_uri)
DO UPDATE SET
    confidence = EXCLUDED.confidence,
    reconciliation_method = EXCLUDED.reconciliation_method,
    is_canonical = EXCLUDED.is_canonical,
    metadata = EXCLUDED.metadata,
    updated_at = now()
RETURNING id, entity_type, entity_id, authority_code, identifier_uri, confidence, reconciliation_method, is_canonical, metadata, created_at, updated_at
`

type UpsertEntityIdentifierParams struct {
	EntityType           string         `json:"entity_type"`
	EntityID             string         `json:"entity_id"`
	AuthorityCode        string         `json:"authority_code"`
	IdentifierUri        string         `json:"identifier_uri"`
	Confidence           pgtype.Numeric `json:"confidence"`
	ReconciliationMethod string         `json:"reconciliation_method"`
	IsCanonical          bool           `json:"is_canonical"`
	Metadata             []byte         `json:"metadata"`
}

// Insert or update an entity identifier (sameAs link)
func (q *Queries) UpsertEntityIdentifier(ctx context.Context, arg UpsertEntityIdentifierParams) (EntityIdentifier, error) {
	row := q.db.QueryRow(ctx, upsertEntityIdentifier,
		arg.EntityType,
		arg.EntityID,
		arg.AuthorityCode,
		arg.IdentifierUri,
		arg.Confidence,
		arg.ReconciliationMethod,
		arg.IsCanonical,
		arg.Metadata,
	)
	var i EntityIdentifier
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.AuthorityCode,
		&i.IdentifierUri,
		&i.Confidence,
		&i.ReconciliationMethod,
		&i.IsCanonical,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertReconciliationCache = `-- name: UpsertReconciliationCache :one
INSERT INTO reconciliation_cache (entity_type, authority_code, lookup_key, result_json, is_negative, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (entity_type, authority_code, lookup_key)
DO UPDATE SET
    result_json = EXCLUDED.result_json,
    hit_count = reconciliation_cache.hit_count + 1,
    is_negative = EXCLUDED.is_negative,
    expires_at = EXCLUDED.expires_at,
    updated_at = now()
RETURNING id, entity_type, authority_code, lookup_key, result_json, hit_count, is_negative, expires_at, created_at, updated_at
`

type UpsertReconciliationCacheParams struct {
	EntityType    string             `json:"entity_type"`
	AuthorityCode string             `json:"authority_code"`
	LookupKey     string             `json:"lookup_key"`
	ResultJson    []byte             `json:"result_json"`
	IsNegative    bool               `json:"is_negative"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
}

// Insert or update a cache entry
func (q *Queries) UpsertReconciliationCache(ctx context.Context, arg UpsertReconciliationCacheParams) (ReconciliationCache, error) {
	row := q.db.QueryRow(ctx, upsertReconciliationCache,
		arg.EntityType,
		arg.AuthorityCode,
		arg.LookupKey,
		arg.ResultJson,
		arg.IsNegative,
		arg.ExpiresAt,
	)
	var i ReconciliationCache
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.AuthorityCode,
		&i.LookupKey,
		&i.ResultJson,
		&i.HitCount,
		&i.IsNegative,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
