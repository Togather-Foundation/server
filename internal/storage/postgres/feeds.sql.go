// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: feeds.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEventChangeByID = `-- name: GetEventChangeByID :one
SELECT ec.id,
       ec.event_id,
       ec.action,
       ec.changed_fields,
       ec.snapshot,
       ec.changed_at,
       ec.sequence_number,
       e.ulid AS event_ulid,
       e.federation_uri,
       es.retrieved_at AS source_timestamp,
       e.created_at AS received_timestamp
  FROM event_changes ec
  JOIN events e ON e.id = ec.event_id
  LEFT JOIN event_sources es ON es.event_id = ec.event_id
 WHERE ec.id = $1
 LIMIT 1
`

type GetEventChangeByIDRow struct {
	ID                pgtype.UUID        `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	Action            string             `json:"action"`
	ChangedFields     []byte             `json:"changed_fields"`
	Snapshot          []byte             `json:"snapshot"`
	ChangedAt         pgtype.Timestamptz `json:"changed_at"`
	SequenceNumber    pgtype.Int8        `json:"sequence_number"`
	EventUlid         string             `json:"event_ulid"`
	FederationUri     pgtype.Text        `json:"federation_uri"`
	SourceTimestamp   pgtype.Timestamptz `json:"source_timestamp"`
	ReceivedTimestamp pgtype.Timestamptz `json:"received_timestamp"`
}

func (q *Queries) GetEventChangeByID(ctx context.Context, id pgtype.UUID) (GetEventChangeByIDRow, error) {
	row := q.db.QueryRow(ctx, getEventChangeByID, id)
	var i GetEventChangeByIDRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Action,
		&i.ChangedFields,
		&i.Snapshot,
		&i.ChangedAt,
		&i.SequenceNumber,
		&i.EventUlid,
		&i.FederationUri,
		&i.SourceTimestamp,
		&i.ReceivedTimestamp,
	)
	return i, err
}

const getEventTombstoneByURI = `-- name: GetEventTombstoneByURI :one
SELECT et.id,
       et.event_id,
       et.event_uri,
       et.deleted_at,
       et.deletion_reason,
       et.superseded_by_uri,
       et.payload
  FROM event_tombstones et
 WHERE et.event_uri = $1
 LIMIT 1
`

func (q *Queries) GetEventTombstoneByURI(ctx context.Context, eventUri string) (EventTombstone, error) {
	row := q.db.QueryRow(ctx, getEventTombstoneByURI, eventUri)
	var i EventTombstone
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUri,
		&i.DeletedAt,
		&i.DeletionReason,
		&i.SupersededByUri,
		&i.Payload,
	)
	return i, err
}

const getLatestEventChange = `-- name: GetLatestEventChange :one
SELECT ec.sequence_number,
       ec.changed_at
  FROM event_changes ec
 ORDER BY ec.sequence_number DESC
 LIMIT 1
`

type GetLatestEventChangeRow struct {
	SequenceNumber pgtype.Int8        `json:"sequence_number"`
	ChangedAt      pgtype.Timestamptz `json:"changed_at"`
}

func (q *Queries) GetLatestEventChange(ctx context.Context) (GetLatestEventChangeRow, error) {
	row := q.db.QueryRow(ctx, getLatestEventChange)
	var i GetLatestEventChangeRow
	err := row.Scan(&i.SequenceNumber, &i.ChangedAt)
	return i, err
}

const listEventChanges = `-- name: ListEventChanges :many

SELECT ec.id,
       ec.event_id,
       ec.action,
       ec.changed_fields,
       ec.snapshot,
       ec.changed_at,
       ec.sequence_number,
       e.ulid AS event_ulid,
       e.federation_uri,
       es.retrieved_at AS source_timestamp,
       e.created_at AS received_timestamp
  FROM event_changes ec
  JOIN events e ON e.id = ec.event_id
  LEFT JOIN event_sources es ON es.event_id = ec.event_id
 WHERE ($1::bigint IS NULL OR ec.sequence_number > $1::bigint)
   AND ($2::timestamptz IS NULL OR ec.changed_at >= $2::timestamptz)
   AND ($3 = '' OR ec.action = $3)
 ORDER BY ec.sequence_number ASC
 LIMIT $4
`

type ListEventChangesParams struct {
	Column1 int64              `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
	Column3 interface{}        `json:"column_3"`
	Limit   int32              `json:"limit"`
}

type ListEventChangesRow struct {
	ID                pgtype.UUID        `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	Action            string             `json:"action"`
	ChangedFields     []byte             `json:"changed_fields"`
	Snapshot          []byte             `json:"snapshot"`
	ChangedAt         pgtype.Timestamptz `json:"changed_at"`
	SequenceNumber    pgtype.Int8        `json:"sequence_number"`
	EventUlid         string             `json:"event_ulid"`
	FederationUri     pgtype.Text        `json:"federation_uri"`
	SourceTimestamp   pgtype.Timestamptz `json:"source_timestamp"`
	ReceivedTimestamp pgtype.Timestamptz `json:"received_timestamp"`
}

// SQLc queries for change feeds.
func (q *Queries) ListEventChanges(ctx context.Context, arg ListEventChangesParams) ([]ListEventChangesRow, error) {
	rows, err := q.db.Query(ctx, listEventChanges,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventChangesRow{}
	for rows.Next() {
		var i ListEventChangesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Action,
			&i.ChangedFields,
			&i.Snapshot,
			&i.ChangedAt,
			&i.SequenceNumber,
			&i.EventUlid,
			&i.FederationUri,
			&i.SourceTimestamp,
			&i.ReceivedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventTombstones = `-- name: ListEventTombstones :many
SELECT et.id,
       et.event_id,
       et.event_uri,
       et.deleted_at,
       et.deletion_reason,
       et.superseded_by_uri,
       et.payload
  FROM event_tombstones et
 WHERE ($1::timestamptz IS NULL OR et.deleted_at >= $1::timestamptz)
 ORDER BY et.deleted_at ASC
 LIMIT $2
`

type ListEventTombstonesParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Limit   int32              `json:"limit"`
}

func (q *Queries) ListEventTombstones(ctx context.Context, arg ListEventTombstonesParams) ([]EventTombstone, error) {
	rows, err := q.db.Query(ctx, listEventTombstones, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventTombstone{}
	for rows.Next() {
		var i EventTombstone
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.EventUri,
			&i.DeletedAt,
			&i.DeletionReason,
			&i.SupersededByUri,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
