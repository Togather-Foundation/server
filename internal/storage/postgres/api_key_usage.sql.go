// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_key_usage.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAPIKeyUsage = `-- name: GetAPIKeyUsage :many
SELECT api_key_id, date, request_count, error_count FROM api_key_usage 
WHERE api_key_id = $1 AND date >= $2 AND date <= $3
ORDER BY date DESC
`

type GetAPIKeyUsageParams struct {
	ApiKeyID pgtype.UUID `json:"api_key_id"`
	Date     pgtype.Date `json:"date"`
	Date_2   pgtype.Date `json:"date_2"`
}

func (q *Queries) GetAPIKeyUsage(ctx context.Context, arg GetAPIKeyUsageParams) ([]ApiKeyUsage, error) {
	rows, err := q.db.Query(ctx, getAPIKeyUsage, arg.ApiKeyID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKeyUsage{}
	for rows.Next() {
		var i ApiKeyUsage
		if err := rows.Scan(
			&i.ApiKeyID,
			&i.Date,
			&i.RequestCount,
			&i.ErrorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAPIKeyUsageTotal = `-- name: GetAPIKeyUsageTotal :one
SELECT COALESCE(SUM(request_count), 0)::bigint AS total_requests,
       COALESCE(SUM(error_count), 0)::bigint AS total_errors
FROM api_key_usage 
WHERE api_key_id = $1 AND date >= $2 AND date <= $3
`

type GetAPIKeyUsageTotalParams struct {
	ApiKeyID pgtype.UUID `json:"api_key_id"`
	Date     pgtype.Date `json:"date"`
	Date_2   pgtype.Date `json:"date_2"`
}

type GetAPIKeyUsageTotalRow struct {
	TotalRequests int64 `json:"total_requests"`
	TotalErrors   int64 `json:"total_errors"`
}

func (q *Queries) GetAPIKeyUsageTotal(ctx context.Context, arg GetAPIKeyUsageTotalParams) (GetAPIKeyUsageTotalRow, error) {
	row := q.db.QueryRow(ctx, getAPIKeyUsageTotal, arg.ApiKeyID, arg.Date, arg.Date_2)
	var i GetAPIKeyUsageTotalRow
	err := row.Scan(&i.TotalRequests, &i.TotalErrors)
	return i, err
}

const getDeveloperUsageTotal = `-- name: GetDeveloperUsageTotal :one
SELECT COALESCE(SUM(u.request_count), 0)::bigint AS total_requests,
       COALESCE(SUM(u.error_count), 0)::bigint AS total_errors
FROM api_key_usage u
JOIN api_keys k ON u.api_key_id = k.id
WHERE k.developer_id = $1 AND u.date >= $2 AND u.date <= $3
`

type GetDeveloperUsageTotalParams struct {
	DeveloperID pgtype.UUID `json:"developer_id"`
	Date        pgtype.Date `json:"date"`
	Date_2      pgtype.Date `json:"date_2"`
}

type GetDeveloperUsageTotalRow struct {
	TotalRequests int64 `json:"total_requests"`
	TotalErrors   int64 `json:"total_errors"`
}

func (q *Queries) GetDeveloperUsageTotal(ctx context.Context, arg GetDeveloperUsageTotalParams) (GetDeveloperUsageTotalRow, error) {
	row := q.db.QueryRow(ctx, getDeveloperUsageTotal, arg.DeveloperID, arg.Date, arg.Date_2)
	var i GetDeveloperUsageTotalRow
	err := row.Scan(&i.TotalRequests, &i.TotalErrors)
	return i, err
}

const upsertAPIKeyUsage = `-- name: UpsertAPIKeyUsage :exec

INSERT INTO api_key_usage (api_key_id, date, request_count, error_count)
VALUES ($1, $2, $3, $4)
ON CONFLICT (api_key_id, date) DO UPDATE SET
    request_count = api_key_usage.request_count + EXCLUDED.request_count,
    error_count = api_key_usage.error_count + EXCLUDED.error_count
`

type UpsertAPIKeyUsageParams struct {
	ApiKeyID     pgtype.UUID `json:"api_key_id"`
	Date         pgtype.Date `json:"date"`
	RequestCount int64       `json:"request_count"`
	ErrorCount   int64       `json:"error_count"`
}

// SQLc queries for API key usage tracking.
func (q *Queries) UpsertAPIKeyUsage(ctx context.Context, arg UpsertAPIKeyUsageParams) error {
	_, err := q.db.Exec(ctx, upsertAPIKeyUsage,
		arg.ApiKeyID,
		arg.Date,
		arg.RequestCount,
		arg.ErrorCount,
	)
	return err
}
