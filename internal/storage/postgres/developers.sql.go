// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: developers.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptDeveloperInvitation = `-- name: AcceptDeveloperInvitation :exec
UPDATE developer_invitations SET accepted_at = now() WHERE id = $1
`

func (q *Queries) AcceptDeveloperInvitation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, acceptDeveloperInvitation, id)
	return err
}

const checkAPIKeyOwnership = `-- name: CheckAPIKeyOwnership :one
SELECT EXISTS(SELECT 1 FROM api_keys WHERE id = $1 AND developer_id = $2) AS owned
`

type CheckAPIKeyOwnershipParams struct {
	ID          pgtype.UUID `json:"id"`
	DeveloperID pgtype.UUID `json:"developer_id"`
}

func (q *Queries) CheckAPIKeyOwnership(ctx context.Context, arg CheckAPIKeyOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAPIKeyOwnership, arg.ID, arg.DeveloperID)
	var owned bool
	err := row.Scan(&owned)
	return owned, err
}

const countDeveloperAPIKeys = `-- name: CountDeveloperAPIKeys :one
SELECT COUNT(*) FROM api_keys 
WHERE developer_id = $1 AND is_active = true
`

func (q *Queries) CountDeveloperAPIKeys(ctx context.Context, developerID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDeveloperAPIKeys, developerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDevelopers = `-- name: CountDevelopers :one
SELECT COUNT(*) FROM developers
`

func (q *Queries) CountDevelopers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDevelopers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeveloper = `-- name: CreateDeveloper :one


INSERT INTO developers (email, name, github_id, github_username, password_hash, max_keys)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at
`

type CreateDeveloperParams struct {
	Email          string      `json:"email"`
	Name           string      `json:"name"`
	GithubID       pgtype.Int8 `json:"github_id"`
	GithubUsername pgtype.Text `json:"github_username"`
	PasswordHash   pgtype.Text `json:"password_hash"`
	MaxKeys        int32       `json:"max_keys"`
}

// SQLc queries for developer management and invitations.
// Developer CRUD operations
func (q *Queries) CreateDeveloper(ctx context.Context, arg CreateDeveloperParams) (Developer, error) {
	row := q.db.QueryRow(ctx, createDeveloper,
		arg.Email,
		arg.Name,
		arg.GithubID,
		arg.GithubUsername,
		arg.PasswordHash,
		arg.MaxKeys,
	)
	var i Developer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.GithubID,
		&i.GithubUsername,
		&i.PasswordHash,
		&i.MaxKeys,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const createDeveloperAPIKey = `-- name: CreateDeveloperAPIKey :one
INSERT INTO api_keys (prefix, key_hash, hash_version, name, developer_id, role, rate_limit_tier, is_active, expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, prefix, name, role, rate_limit_tier, is_active, created_at, expires_at
`

type CreateDeveloperAPIKeyParams struct {
	Prefix        string             `json:"prefix"`
	KeyHash       string             `json:"key_hash"`
	HashVersion   int32              `json:"hash_version"`
	Name          string             `json:"name"`
	DeveloperID   pgtype.UUID        `json:"developer_id"`
	Role          string             `json:"role"`
	RateLimitTier string             `json:"rate_limit_tier"`
	IsActive      bool               `json:"is_active"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
}

type CreateDeveloperAPIKeyRow struct {
	ID            pgtype.UUID        `json:"id"`
	Prefix        string             `json:"prefix"`
	Name          string             `json:"name"`
	Role          string             `json:"role"`
	RateLimitTier string             `json:"rate_limit_tier"`
	IsActive      bool               `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateDeveloperAPIKey(ctx context.Context, arg CreateDeveloperAPIKeyParams) (CreateDeveloperAPIKeyRow, error) {
	row := q.db.QueryRow(ctx, createDeveloperAPIKey,
		arg.Prefix,
		arg.KeyHash,
		arg.HashVersion,
		arg.Name,
		arg.DeveloperID,
		arg.Role,
		arg.RateLimitTier,
		arg.IsActive,
		arg.ExpiresAt,
	)
	var i CreateDeveloperAPIKeyRow
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.Name,
		&i.Role,
		&i.RateLimitTier,
		&i.IsActive,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createDeveloperInvitation = `-- name: CreateDeveloperInvitation :one

INSERT INTO developer_invitations (email, token_hash, invited_by, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, email, token_hash, invited_by, expires_at, accepted_at, created_at
`

type CreateDeveloperInvitationParams struct {
	Email     string             `json:"email"`
	TokenHash string             `json:"token_hash"`
	InvitedBy pgtype.UUID        `json:"invited_by"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Developer invitation operations
func (q *Queries) CreateDeveloperInvitation(ctx context.Context, arg CreateDeveloperInvitationParams) (DeveloperInvitation, error) {
	row := q.db.QueryRow(ctx, createDeveloperInvitation,
		arg.Email,
		arg.TokenHash,
		arg.InvitedBy,
		arg.ExpiresAt,
	)
	var i DeveloperInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.TokenHash,
		&i.InvitedBy,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deactivateDeveloper = `-- name: DeactivateDeveloper :exec
UPDATE developers SET is_active = false WHERE id = $1
`

func (q *Queries) DeactivateDeveloper(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deactivateDeveloper, id)
	return err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, prefix, key_hash, hash_version, name, source_id, role, rate_limit_tier, is_active, created_at, last_used_at, expires_at, developer_id FROM api_keys WHERE id = $1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id pgtype.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.Prefix,
		&i.KeyHash,
		&i.HashVersion,
		&i.Name,
		&i.SourceID,
		&i.Role,
		&i.RateLimitTier,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastUsedAt,
		&i.ExpiresAt,
		&i.DeveloperID,
	)
	return i, err
}

const getDeveloperByEmail = `-- name: GetDeveloperByEmail :one
SELECT id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at FROM developers WHERE email = $1
`

func (q *Queries) GetDeveloperByEmail(ctx context.Context, email string) (Developer, error) {
	row := q.db.QueryRow(ctx, getDeveloperByEmail, email)
	var i Developer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.GithubID,
		&i.GithubUsername,
		&i.PasswordHash,
		&i.MaxKeys,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getDeveloperByGitHubID = `-- name: GetDeveloperByGitHubID :one
SELECT id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at FROM developers WHERE github_id = $1
`

func (q *Queries) GetDeveloperByGitHubID(ctx context.Context, githubID pgtype.Int8) (Developer, error) {
	row := q.db.QueryRow(ctx, getDeveloperByGitHubID, githubID)
	var i Developer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.GithubID,
		&i.GithubUsername,
		&i.PasswordHash,
		&i.MaxKeys,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getDeveloperByID = `-- name: GetDeveloperByID :one
SELECT id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at FROM developers WHERE id = $1
`

func (q *Queries) GetDeveloperByID(ctx context.Context, id pgtype.UUID) (Developer, error) {
	row := q.db.QueryRow(ctx, getDeveloperByID, id)
	var i Developer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.GithubID,
		&i.GithubUsername,
		&i.PasswordHash,
		&i.MaxKeys,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const getDeveloperInvitationByTokenHash = `-- name: GetDeveloperInvitationByTokenHash :one
SELECT id, email, token_hash, invited_by, expires_at, accepted_at, created_at FROM developer_invitations 
WHERE token_hash = $1 AND accepted_at IS NULL
`

func (q *Queries) GetDeveloperInvitationByTokenHash(ctx context.Context, tokenHash string) (DeveloperInvitation, error) {
	row := q.db.QueryRow(ctx, getDeveloperInvitationByTokenHash, tokenHash)
	var i DeveloperInvitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.TokenHash,
		&i.InvitedBy,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveDeveloperInvitations = `-- name: ListActiveDeveloperInvitations :many
SELECT id, email, token_hash, invited_by, expires_at, accepted_at, created_at FROM developer_invitations 
WHERE accepted_at IS NULL AND expires_at > now()
ORDER BY created_at DESC
`

func (q *Queries) ListActiveDeveloperInvitations(ctx context.Context) ([]DeveloperInvitation, error) {
	rows, err := q.db.Query(ctx, listActiveDeveloperInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeveloperInvitation{}
	for rows.Next() {
		var i DeveloperInvitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.TokenHash,
			&i.InvitedBy,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeveloperAPIKeys = `-- name: ListDeveloperAPIKeys :many

SELECT id, prefix, key_hash, hash_version, name, source_id, role, rate_limit_tier, is_active, created_at, last_used_at, expires_at, developer_id FROM api_keys 
WHERE developer_id = $1 
ORDER BY created_at DESC
`

// Developer API key operations
func (q *Queries) ListDeveloperAPIKeys(ctx context.Context, developerID pgtype.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listDeveloperAPIKeys, developerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.Prefix,
			&i.KeyHash,
			&i.HashVersion,
			&i.Name,
			&i.SourceID,
			&i.Role,
			&i.RateLimitTier,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastUsedAt,
			&i.ExpiresAt,
			&i.DeveloperID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevelopers = `-- name: ListDevelopers :many
SELECT id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at FROM developers 
ORDER BY created_at DESC 
LIMIT $1 OFFSET $2
`

type ListDevelopersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDevelopers(ctx context.Context, arg ListDevelopersParams) ([]Developer, error) {
	rows, err := q.db.Query(ctx, listDevelopers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Developer{}
	for rows.Next() {
		var i Developer
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.GithubID,
			&i.GithubUsername,
			&i.PasswordHash,
			&i.MaxKeys,
			&i.IsActive,
			&i.CreatedAt,
			&i.LastLoginAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllDeveloperAPIKeys = `-- name: RevokeAllDeveloperAPIKeys :execrows
UPDATE api_keys SET is_active = false WHERE developer_id = $1 AND is_active = true
`

func (q *Queries) RevokeAllDeveloperAPIKeys(ctx context.Context, developerID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, revokeAllDeveloperAPIKeys, developerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateDeveloper = `-- name: UpdateDeveloper :one
UPDATE developers 
SET name = COALESCE($1, name),
    github_id = COALESCE($2, github_id),
    github_username = COALESCE($3, github_username),
    max_keys = COALESCE($4, max_keys),
    is_active = COALESCE($5, is_active)
WHERE id = $6
RETURNING id, email, name, github_id, github_username, password_hash, max_keys, is_active, created_at, last_login_at
`

type UpdateDeveloperParams struct {
	Name           pgtype.Text `json:"name"`
	GithubID       pgtype.Int8 `json:"github_id"`
	GithubUsername pgtype.Text `json:"github_username"`
	MaxKeys        pgtype.Int4 `json:"max_keys"`
	IsActive       pgtype.Bool `json:"is_active"`
	ID             pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateDeveloper(ctx context.Context, arg UpdateDeveloperParams) (Developer, error) {
	row := q.db.QueryRow(ctx, updateDeveloper,
		arg.Name,
		arg.GithubID,
		arg.GithubUsername,
		arg.MaxKeys,
		arg.IsActive,
		arg.ID,
	)
	var i Developer
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.GithubID,
		&i.GithubUsername,
		&i.PasswordHash,
		&i.MaxKeys,
		&i.IsActive,
		&i.CreatedAt,
		&i.LastLoginAt,
	)
	return i, err
}

const updateDeveloperLastLogin = `-- name: UpdateDeveloperLastLogin :exec
UPDATE developers SET last_login_at = now() WHERE id = $1
`

func (q *Queries) UpdateDeveloperLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateDeveloperLastLogin, id)
	return err
}
