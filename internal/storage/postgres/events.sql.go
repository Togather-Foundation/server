// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEventByULID = `-- name: GetEventByULID :many
SELECT e.id,
       e.ulid,
       e.name,
       e.description,
       e.lifecycle_state,
       e.event_domain,
       e.organizer_id,
       e.primary_venue_id,
       e.keywords,
       e.created_at,
       e.updated_at,
       o.id AS occurrence_id,
       o.start_time,
       o.end_time,
       o.timezone,
       o.venue_id,
       o.virtual_url
  FROM events e
  LEFT JOIN event_occurrences o ON o.event_id = e.id
 WHERE e.ulid = $1
  ORDER BY o.start_time ASC
`

type GetEventByULIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	OrganizerID    pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID pgtype.UUID        `json:"primary_venue_id"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	OccurrenceID   pgtype.UUID        `json:"occurrence_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Timezone       pgtype.Text        `json:"timezone"`
	VenueID        pgtype.UUID        `json:"venue_id"`
	VirtualUrl     pgtype.Text        `json:"virtual_url"`
}

func (q *Queries) GetEventByULID(ctx context.Context, ulid string) ([]GetEventByULIDRow, error) {
	rows, err := q.db.Query(ctx, getEventByULID, ulid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventByULIDRow{}
	for rows.Next() {
		var i GetEventByULIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Ulid,
			&i.Name,
			&i.Description,
			&i.LifecycleState,
			&i.EventDomain,
			&i.OrganizerID,
			&i.PrimaryVenueID,
			&i.Keywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OccurrenceID,
			&i.StartTime,
			&i.EndTime,
			&i.Timezone,
			&i.VenueID,
			&i.VirtualUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdempotencyKey = `-- name: GetIdempotencyKey :one
SELECT key,
       request_hash,
       event_id,
       event_ulid
  FROM idempotency_keys
 WHERE key = $1
`

type GetIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) GetIdempotencyKey(ctx context.Context, key string) (GetIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getIdempotencyKey, key)
	var i GetIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const insertIdempotencyKey = `-- name: InsertIdempotencyKey :one
INSERT INTO idempotency_keys (key, request_hash, event_id, event_ulid)
VALUES ($1, $2, $3, $4)
RETURNING key, request_hash, event_id, event_ulid
`

type InsertIdempotencyKeyParams struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

type InsertIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) InsertIdempotencyKey(ctx context.Context, arg InsertIdempotencyKeyParams) (InsertIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, insertIdempotencyKey,
		arg.Key,
		arg.RequestHash,
		arg.EventID,
		arg.EventUlid,
	)
	var i InsertIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many

SELECT e.id,
       e.ulid,
       e.name,
       e.description,
       e.lifecycle_state,
       e.event_domain,
       e.organizer_id,
       e.primary_venue_id,
       e.keywords,
       e.created_at,
       e.updated_at,
       o.start_time
  FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
  LEFT JOIN places p ON p.id = COALESCE(o.venue_id, e.primary_venue_id)
  LEFT JOIN organizations org ON org.id = e.organizer_id
 WHERE ($1::timestamptz IS NULL OR o.start_time >= $1::timestamptz)
   AND ($2::timestamptz IS NULL OR o.start_time <= $2::timestamptz)
   AND ($3 = '' OR p.address_locality ILIKE '%' || $3 || '%')
   AND ($4 = '' OR p.address_region ILIKE '%' || $4 || '%')
   AND ($5 = '' OR p.ulid = $5)
   AND ($6 = '' OR org.ulid = $6)
   AND ($7 = '' OR e.lifecycle_state = $7)
   AND ($8 = '' OR e.event_domain = $8)
   AND ($9 = '' OR (e.name ILIKE '%' || $9 || '%' OR e.description ILIKE '%' || $9 || '%'))
   AND (coalesce(cardinality($10::text[]), 0) = 0 OR e.keywords && $10::text[])
   AND (
     $11::timestamptz IS NULL OR
     o.start_time > $11::timestamptz OR
     (o.start_time = $11::timestamptz AND e.ulid > $12)
   )
 ORDER BY o.start_time ASC, e.ulid ASC
 LIMIT $13
`

type ListEventsParams struct {
	Column1  pgtype.Timestamptz `json:"column_1"`
	Column2  pgtype.Timestamptz `json:"column_2"`
	Column3  interface{}        `json:"column_3"`
	Column4  interface{}        `json:"column_4"`
	Column5  interface{}        `json:"column_5"`
	Column6  interface{}        `json:"column_6"`
	Column7  interface{}        `json:"column_7"`
	Column8  interface{}        `json:"column_8"`
	Column9  interface{}        `json:"column_9"`
	Column10 []string           `json:"column_10"`
	Column11 pgtype.Timestamptz `json:"column_11"`
	Ulid     string             `json:"ulid"`
	Limit    int32              `json:"limit"`
}

type ListEventsRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	OrganizerID    pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID pgtype.UUID        `json:"primary_venue_id"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// SQLc queries for events domain.
func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Ulid,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsRow{}
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ulid,
			&i.Name,
			&i.Description,
			&i.LifecycleState,
			&i.EventDomain,
			&i.OrganizerID,
			&i.PrimaryVenueID,
			&i.Keywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
