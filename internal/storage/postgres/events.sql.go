// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEventTombstone = `-- name: CreateEventTombstone :exec
INSERT INTO event_tombstones (event_id, event_uri, deleted_at, deletion_reason, superseded_by_uri, payload)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateEventTombstoneParams struct {
	EventID         pgtype.UUID        `json:"event_id"`
	EventUri        string             `json:"event_uri"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	DeletionReason  pgtype.Text        `json:"deletion_reason"`
	SupersededByUri pgtype.Text        `json:"superseded_by_uri"`
	Payload         []byte             `json:"payload"`
}

func (q *Queries) CreateEventTombstone(ctx context.Context, arg CreateEventTombstoneParams) error {
	_, err := q.db.Exec(ctx, createEventTombstone,
		arg.EventID,
		arg.EventUri,
		arg.DeletedAt,
		arg.DeletionReason,
		arg.SupersededByUri,
		arg.Payload,
	)
	return err
}

const getEventByULID = `-- name: GetEventByULID :many
SELECT e.id,
       e.ulid,
       e.name,
       e.description,
       e.lifecycle_state,
       e.event_domain,
       e.organizer_id,
       e.primary_venue_id,
       e.keywords,
       e.created_at,
       e.updated_at,
       o.id AS occurrence_id,
       o.start_time,
       o.end_time,
       o.timezone,
       o.venue_id,
       o.virtual_url
  FROM events e
  LEFT JOIN event_occurrences o ON o.event_id = e.id
 WHERE e.ulid = $1
  ORDER BY o.start_time ASC
`

type GetEventByULIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	OrganizerID    pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID pgtype.UUID        `json:"primary_venue_id"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	OccurrenceID   pgtype.UUID        `json:"occurrence_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Timezone       pgtype.Text        `json:"timezone"`
	VenueID        pgtype.UUID        `json:"venue_id"`
	VirtualUrl     pgtype.Text        `json:"virtual_url"`
}

func (q *Queries) GetEventByULID(ctx context.Context, ulid string) ([]GetEventByULIDRow, error) {
	rows, err := q.db.Query(ctx, getEventByULID, ulid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventByULIDRow{}
	for rows.Next() {
		var i GetEventByULIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Ulid,
			&i.Name,
			&i.Description,
			&i.LifecycleState,
			&i.EventDomain,
			&i.OrganizerID,
			&i.PrimaryVenueID,
			&i.Keywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OccurrenceID,
			&i.StartTime,
			&i.EndTime,
			&i.Timezone,
			&i.VenueID,
			&i.VirtualUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTombstoneByEventID = `-- name: GetEventTombstoneByEventID :one
SELECT id,
       event_id,
       event_uri,
       deleted_at,
       deletion_reason,
       superseded_by_uri,
       payload
  FROM event_tombstones
 WHERE event_id = $1
 ORDER BY deleted_at DESC
 LIMIT 1
`

func (q *Queries) GetEventTombstoneByEventID(ctx context.Context, eventID pgtype.UUID) (EventTombstone, error) {
	row := q.db.QueryRow(ctx, getEventTombstoneByEventID, eventID)
	var i EventTombstone
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUri,
		&i.DeletedAt,
		&i.DeletionReason,
		&i.SupersededByUri,
		&i.Payload,
	)
	return i, err
}

const getEventTombstoneByEventULID = `-- name: GetEventTombstoneByEventULID :one
SELECT t.id,
       t.event_id,
       t.event_uri,
       t.deleted_at,
       t.deletion_reason,
       t.superseded_by_uri,
       t.payload
  FROM event_tombstones t
  JOIN events e ON e.id = t.event_id
 WHERE e.ulid = $1
 ORDER BY t.deleted_at DESC
 LIMIT 1
`

func (q *Queries) GetEventTombstoneByEventULID(ctx context.Context, ulid string) (EventTombstone, error) {
	row := q.db.QueryRow(ctx, getEventTombstoneByEventULID, ulid)
	var i EventTombstone
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUri,
		&i.DeletedAt,
		&i.DeletionReason,
		&i.SupersededByUri,
		&i.Payload,
	)
	return i, err
}

const getIdempotencyKey = `-- name: GetIdempotencyKey :one
SELECT key,
       request_hash,
       event_id,
       event_ulid
  FROM idempotency_keys
 WHERE key = $1
`

type GetIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) GetIdempotencyKey(ctx context.Context, key string) (GetIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getIdempotencyKey, key)
	var i GetIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const insertIdempotencyKey = `-- name: InsertIdempotencyKey :one
INSERT INTO idempotency_keys (key, request_hash, event_id, event_ulid)
VALUES ($1, $2, $3, $4)
RETURNING key, request_hash, event_id, event_ulid
`

type InsertIdempotencyKeyParams struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

type InsertIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) InsertIdempotencyKey(ctx context.Context, arg InsertIdempotencyKeyParams) (InsertIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, insertIdempotencyKey,
		arg.Key,
		arg.RequestHash,
		arg.EventID,
		arg.EventUlid,
	)
	var i InsertIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many

SELECT e.id,
       e.ulid,
       e.name,
       e.description,
       e.lifecycle_state,
       e.event_domain,
       e.organizer_id,
       e.primary_venue_id,
       e.keywords,
       e.created_at,
       e.updated_at,
       o.start_time
  FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
  LEFT JOIN places p ON p.id = COALESCE(o.venue_id, e.primary_venue_id)
  LEFT JOIN organizations org ON org.id = e.organizer_id
 WHERE ($1::timestamptz IS NULL OR o.start_time >= $1::timestamptz)
   AND ($2::timestamptz IS NULL OR o.start_time <= $2::timestamptz)
   AND ($3 = '' OR p.address_locality ILIKE '%' || $3 || '%')
   AND ($4 = '' OR p.address_region ILIKE '%' || $4 || '%')
   AND ($5 = '' OR p.ulid = $5)
   AND ($6 = '' OR org.ulid = $6)
   AND ($7 = '' OR e.lifecycle_state = $7)
   AND ($8 = '' OR e.event_domain = $8)
   AND ($9 = '' OR (e.name ILIKE '%' || $9 || '%' OR e.description ILIKE '%' || $9 || '%'))
   AND (coalesce(cardinality($10::text[]), 0) = 0 OR e.keywords && $10::text[])
   AND (
     $11::timestamptz IS NULL OR
     o.start_time > $11::timestamptz OR
     (o.start_time = $11::timestamptz AND e.ulid > $12)
   )
 ORDER BY o.start_time ASC, e.ulid ASC
 LIMIT $13
`

type ListEventsParams struct {
	Column1  pgtype.Timestamptz `json:"column_1"`
	Column2  pgtype.Timestamptz `json:"column_2"`
	Column3  interface{}        `json:"column_3"`
	Column4  interface{}        `json:"column_4"`
	Column5  interface{}        `json:"column_5"`
	Column6  interface{}        `json:"column_6"`
	Column7  interface{}        `json:"column_7"`
	Column8  interface{}        `json:"column_8"`
	Column9  interface{}        `json:"column_9"`
	Column10 []string           `json:"column_10"`
	Column11 pgtype.Timestamptz `json:"column_11"`
	Ulid     string             `json:"ulid"`
	Limit    int32              `json:"limit"`
}

type ListEventsRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	OrganizerID    pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID pgtype.UUID        `json:"primary_venue_id"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
}

// SQLc queries for events domain.
func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Ulid,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsRow{}
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Ulid,
			&i.Name,
			&i.Description,
			&i.LifecycleState,
			&i.EventDomain,
			&i.OrganizerID,
			&i.PrimaryVenueID,
			&i.Keywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeEventIntoDuplicate = `-- name: MergeEventIntoDuplicate :exec
UPDATE events e1
   SET merged_into_id = (SELECT e2.id FROM events e2 WHERE e2.ulid = $2),
       deleted_at = now(),
       lifecycle_state = 'deleted',
       updated_at = now()
 WHERE e1.ulid = $1
   AND e1.deleted_at IS NULL
`

type MergeEventIntoDuplicateParams struct {
	Ulid   string `json:"ulid"`
	Ulid_2 string `json:"ulid_2"`
}

func (q *Queries) MergeEventIntoDuplicate(ctx context.Context, arg MergeEventIntoDuplicateParams) error {
	_, err := q.db.Exec(ctx, mergeEventIntoDuplicate, arg.Ulid, arg.Ulid_2)
	return err
}

const softDeleteEvent = `-- name: SoftDeleteEvent :exec
UPDATE events
   SET deleted_at = now(),
       deletion_reason = $2,
       lifecycle_state = 'deleted',
       updated_at = now()
 WHERE ulid = $1
   AND deleted_at IS NULL
`

type SoftDeleteEventParams struct {
	Ulid           string      `json:"ulid"`
	DeletionReason pgtype.Text `json:"deletion_reason"`
}

func (q *Queries) SoftDeleteEvent(ctx context.Context, arg SoftDeleteEventParams) error {
	_, err := q.db.Exec(ctx, softDeleteEvent, arg.Ulid, arg.DeletionReason)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
   SET name = COALESCE($2, name),
       description = COALESCE($3, description),
       lifecycle_state = COALESCE($4, lifecycle_state),
       image_url = COALESCE($5, image_url),
       public_url = COALESCE($6, public_url),
       event_domain = COALESCE($7, event_domain),
       keywords = COALESCE($8, keywords),
       updated_at = now()
 WHERE ulid = $1
RETURNING id, ulid, name, description, lifecycle_state, event_domain, image_url, public_url, keywords, created_at, updated_at
`

type UpdateEventParams struct {
	Ulid           string      `json:"ulid"`
	Name           pgtype.Text `json:"name"`
	Description    pgtype.Text `json:"description"`
	LifecycleState pgtype.Text `json:"lifecycle_state"`
	ImageUrl       pgtype.Text `json:"image_url"`
	PublicUrl      pgtype.Text `json:"public_url"`
	EventDomain    pgtype.Text `json:"event_domain"`
	Keywords       []string    `json:"keywords"`
}

type UpdateEventRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	PublicUrl      pgtype.Text        `json:"public_url"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (UpdateEventRow, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Ulid,
		arg.Name,
		arg.Description,
		arg.LifecycleState,
		arg.ImageUrl,
		arg.PublicUrl,
		arg.EventDomain,
		arg.Keywords,
	)
	var i UpdateEventRow
	err := row.Scan(
		&i.ID,
		&i.Ulid,
		&i.Name,
		&i.Description,
		&i.LifecycleState,
		&i.EventDomain,
		&i.ImageUrl,
		&i.PublicUrl,
		&i.Keywords,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
