// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAllEvents = `-- name: CountAllEvents :one
SELECT COUNT(*)::bigint AS count
  FROM events
 WHERE deleted_at IS NULL
`

func (q *Queries) CountAllEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByLifecycleState = `-- name: CountEventsByLifecycleState :one
SELECT COUNT(*)::bigint AS count
  FROM events
 WHERE lifecycle_state = $1
   AND deleted_at IS NULL
`

func (q *Queries) CountEventsByLifecycleState(ctx context.Context, lifecycleState string) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsByLifecycleState, lifecycleState)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsCreatedSince = `-- name: CountEventsCreatedSince :one
SELECT COUNT(*)::bigint AS count
  FROM events
 WHERE created_at >= $1
   AND deleted_at IS NULL
`

func (q *Queries) CountEventsCreatedSince(ctx context.Context, createdAt pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsCreatedSince, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPastEvents = `-- name: CountPastEvents :one
SELECT COUNT(DISTINCT e.id)::bigint AS count
  FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
 WHERE o.start_time <= NOW()
   AND e.deleted_at IS NULL
`

func (q *Queries) CountPastEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPastEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUpcomingEvents = `-- name: CountUpcomingEvents :one
SELECT COUNT(DISTINCT e.id)::bigint AS count
  FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
 WHERE o.start_time > NOW()
   AND e.deleted_at IS NULL
`

func (q *Queries) CountUpcomingEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUpcomingEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEventTombstone = `-- name: CreateEventTombstone :exec
INSERT INTO event_tombstones (event_id, event_uri, deleted_at, deletion_reason, superseded_by_uri, payload)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateEventTombstoneParams struct {
	EventID         pgtype.UUID        `json:"event_id"`
	EventUri        string             `json:"event_uri"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	DeletionReason  pgtype.Text        `json:"deletion_reason"`
	SupersededByUri pgtype.Text        `json:"superseded_by_uri"`
	Payload         []byte             `json:"payload"`
}

func (q *Queries) CreateEventTombstone(ctx context.Context, arg CreateEventTombstoneParams) error {
	_, err := q.db.Exec(ctx, createEventTombstone,
		arg.EventID,
		arg.EventUri,
		arg.DeletedAt,
		arg.DeletionReason,
		arg.SupersededByUri,
		arg.Payload,
	)
	return err
}

const getEventByULID = `-- name: GetEventByULID :many

SELECT e.id,
       e.ulid,
       e.name,
       e.description,
       e.lifecycle_state,
       e.event_domain,
       e.organizer_id,
       e.primary_venue_id,
       e.keywords,
       e.federation_uri,
       e.created_at,
       e.updated_at,
       o.id AS occurrence_id,
       o.start_time,
       o.end_time,
       o.timezone,
       o.venue_id,
       o.virtual_url
  FROM events e
  LEFT JOIN event_occurrences o ON o.event_id = e.id
 WHERE e.ulid = $1
  ORDER BY o.start_time ASC
`

type GetEventByULIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	OrganizerID    pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID pgtype.UUID        `json:"primary_venue_id"`
	Keywords       []string           `json:"keywords"`
	FederationUri  pgtype.Text        `json:"federation_uri"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	OccurrenceID   pgtype.UUID        `json:"occurrence_id"`
	StartTime      pgtype.Timestamptz `json:"start_time"`
	EndTime        pgtype.Timestamptz `json:"end_time"`
	Timezone       pgtype.Text        `json:"timezone"`
	VenueID        pgtype.UUID        `json:"venue_id"`
	VirtualUrl     pgtype.Text        `json:"virtual_url"`
}

// SQLc queries for events domain.
func (q *Queries) GetEventByULID(ctx context.Context, ulid string) ([]GetEventByULIDRow, error) {
	rows, err := q.db.Query(ctx, getEventByULID, ulid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventByULIDRow{}
	for rows.Next() {
		var i GetEventByULIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Ulid,
			&i.Name,
			&i.Description,
			&i.LifecycleState,
			&i.EventDomain,
			&i.OrganizerID,
			&i.PrimaryVenueID,
			&i.Keywords,
			&i.FederationUri,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OccurrenceID,
			&i.StartTime,
			&i.EndTime,
			&i.Timezone,
			&i.VenueID,
			&i.VirtualUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventDateRange = `-- name: GetEventDateRange :one
SELECT MIN(o.start_time) AS oldest_event_date,
       MAX(o.start_time) AS newest_event_date
  FROM events e
  JOIN event_occurrences o ON o.event_id = e.id
 WHERE e.deleted_at IS NULL
`

type GetEventDateRangeRow struct {
	OldestEventDate interface{} `json:"oldest_event_date"`
	NewestEventDate interface{} `json:"newest_event_date"`
}

func (q *Queries) GetEventDateRange(ctx context.Context) (GetEventDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getEventDateRange)
	var i GetEventDateRangeRow
	err := row.Scan(&i.OldestEventDate, &i.NewestEventDate)
	return i, err
}

const getEventTombstoneByEventID = `-- name: GetEventTombstoneByEventID :one
SELECT id,
       event_id,
       event_uri,
       deleted_at,
       deletion_reason,
       superseded_by_uri,
       payload
  FROM event_tombstones
 WHERE event_id = $1
 ORDER BY deleted_at DESC
 LIMIT 1
`

func (q *Queries) GetEventTombstoneByEventID(ctx context.Context, eventID pgtype.UUID) (EventTombstone, error) {
	row := q.db.QueryRow(ctx, getEventTombstoneByEventID, eventID)
	var i EventTombstone
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUri,
		&i.DeletedAt,
		&i.DeletionReason,
		&i.SupersededByUri,
		&i.Payload,
	)
	return i, err
}

const getEventTombstoneByEventULID = `-- name: GetEventTombstoneByEventULID :one
SELECT t.id,
       t.event_id,
       t.event_uri,
       t.deleted_at,
       t.deletion_reason,
       t.superseded_by_uri,
       t.payload
  FROM event_tombstones t
  JOIN events e ON e.id = t.event_id
 WHERE e.ulid = $1
 ORDER BY t.deleted_at DESC
 LIMIT 1
`

func (q *Queries) GetEventTombstoneByEventULID(ctx context.Context, ulid string) (EventTombstone, error) {
	row := q.db.QueryRow(ctx, getEventTombstoneByEventULID, ulid)
	var i EventTombstone
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUri,
		&i.DeletedAt,
		&i.DeletionReason,
		&i.SupersededByUri,
		&i.Payload,
	)
	return i, err
}

const getIdempotencyKey = `-- name: GetIdempotencyKey :one
SELECT key,
       request_hash,
       event_id,
       event_ulid
  FROM idempotency_keys
 WHERE key = $1
`

type GetIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) GetIdempotencyKey(ctx context.Context, key string) (GetIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, getIdempotencyKey, key)
	var i GetIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const insertIdempotencyKey = `-- name: InsertIdempotencyKey :one
INSERT INTO idempotency_keys (key, request_hash, event_id, event_ulid)
VALUES ($1, $2, $3, $4)
RETURNING key, request_hash, event_id, event_ulid
`

type InsertIdempotencyKeyParams struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

type InsertIdempotencyKeyRow struct {
	Key         string      `json:"key"`
	RequestHash string      `json:"request_hash"`
	EventID     pgtype.UUID `json:"event_id"`
	EventUlid   pgtype.Text `json:"event_ulid"`
}

func (q *Queries) InsertIdempotencyKey(ctx context.Context, arg InsertIdempotencyKeyParams) (InsertIdempotencyKeyRow, error) {
	row := q.db.QueryRow(ctx, insertIdempotencyKey,
		arg.Key,
		arg.RequestHash,
		arg.EventID,
		arg.EventUlid,
	)
	var i InsertIdempotencyKeyRow
	err := row.Scan(
		&i.Key,
		&i.RequestHash,
		&i.EventID,
		&i.EventUlid,
	)
	return i, err
}

const mergeEventIntoDuplicate = `-- name: MergeEventIntoDuplicate :exec
UPDATE events e1
   SET merged_into_id = (SELECT e2.id FROM events e2 WHERE e2.ulid = $2),
       deleted_at = now(),
       lifecycle_state = 'deleted',
       updated_at = now()
 WHERE e1.ulid = $1
   AND e1.deleted_at IS NULL
`

type MergeEventIntoDuplicateParams struct {
	Ulid   string `json:"ulid"`
	Ulid_2 string `json:"ulid_2"`
}

func (q *Queries) MergeEventIntoDuplicate(ctx context.Context, arg MergeEventIntoDuplicateParams) error {
	_, err := q.db.Exec(ctx, mergeEventIntoDuplicate, arg.Ulid, arg.Ulid_2)
	return err
}

const resolveCanonicalEventULID = `-- name: ResolveCanonicalEventULID :one
WITH RECURSIVE chain AS (
    SELECT e.id, e.ulid, e.merged_into_id, 1 AS depth
      FROM events e
     WHERE e.ulid = $1
    UNION ALL
    SELECT e.id, e.ulid, e.merged_into_id, c.depth + 1
      FROM events e
      JOIN chain c ON c.merged_into_id = e.id
     WHERE c.merged_into_id IS NOT NULL
       AND c.depth < 10
)
SELECT ulid FROM chain
 WHERE merged_into_id IS NULL
    OR depth = 10
 ORDER BY depth DESC
 LIMIT 1
`

// Follow the merged_into_id chain from a given ULID to find the final canonical event.
// Uses a recursive CTE with a max depth of 10 to prevent infinite loops.
// Returns the ULID of the final canonical event (the one that is not itself merged).
func (q *Queries) ResolveCanonicalEventULID(ctx context.Context, ulid string) (string, error) {
	row := q.db.QueryRow(ctx, resolveCanonicalEventULID, ulid)
	err := row.Scan(&ulid)
	return ulid, err
}

const softDeleteEvent = `-- name: SoftDeleteEvent :exec
UPDATE events
   SET deleted_at = now(),
       deletion_reason = $2,
       lifecycle_state = 'deleted',
       updated_at = now()
 WHERE ulid = $1
   AND deleted_at IS NULL
`

type SoftDeleteEventParams struct {
	Ulid           string      `json:"ulid"`
	DeletionReason pgtype.Text `json:"deletion_reason"`
}

func (q *Queries) SoftDeleteEvent(ctx context.Context, arg SoftDeleteEventParams) error {
	_, err := q.db.Exec(ctx, softDeleteEvent, arg.Ulid, arg.DeletionReason)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
   SET name = COALESCE($2, name),
       description = COALESCE($3, description),
       lifecycle_state = COALESCE($4, lifecycle_state),
       image_url = COALESCE($5, image_url),
       public_url = COALESCE($6, public_url),
       event_domain = COALESCE($7, event_domain),
       keywords = COALESCE($8, keywords),
       updated_at = now()
 WHERE ulid = $1
RETURNING id, ulid, name, description, lifecycle_state, event_domain, image_url, public_url, keywords, created_at, updated_at
`

type UpdateEventParams struct {
	Ulid           string      `json:"ulid"`
	Name           pgtype.Text `json:"name"`
	Description    pgtype.Text `json:"description"`
	LifecycleState pgtype.Text `json:"lifecycle_state"`
	ImageUrl       pgtype.Text `json:"image_url"`
	PublicUrl      pgtype.Text `json:"public_url"`
	EventDomain    pgtype.Text `json:"event_domain"`
	Keywords       []string    `json:"keywords"`
}

type UpdateEventRow struct {
	ID             pgtype.UUID        `json:"id"`
	Ulid           string             `json:"ulid"`
	Name           string             `json:"name"`
	Description    pgtype.Text        `json:"description"`
	LifecycleState string             `json:"lifecycle_state"`
	EventDomain    pgtype.Text        `json:"event_domain"`
	ImageUrl       pgtype.Text        `json:"image_url"`
	PublicUrl      pgtype.Text        `json:"public_url"`
	Keywords       []string           `json:"keywords"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (UpdateEventRow, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Ulid,
		arg.Name,
		arg.Description,
		arg.LifecycleState,
		arg.ImageUrl,
		arg.PublicUrl,
		arg.EventDomain,
		arg.Keywords,
	)
	var i UpdateEventRow
	err := row.Scan(
		&i.ID,
		&i.Ulid,
		&i.Name,
		&i.Description,
		&i.LifecycleState,
		&i.EventDomain,
		&i.ImageUrl,
		&i.PublicUrl,
		&i.Keywords,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMergedIntoChain = `-- name: UpdateMergedIntoChain :exec
UPDATE events e_upd
   SET merged_into_id = (SELECT e_new.id FROM events e_new WHERE e_new.ulid = $2),
       updated_at = now()
 WHERE e_upd.merged_into_id = (SELECT e_old.id FROM events e_old WHERE e_old.ulid = $1)
    AND e_upd.ulid != $2
`

type UpdateMergedIntoChainParams struct {
	Ulid   string `json:"ulid"`
	Ulid_2 string `json:"ulid_2"`
}

// Flatten existing merge chains: update all events that point to an old target
// to point to the new canonical target instead. This prevents transitive chains.
// $1 = old target event ULID (intermediate node being re-pointed)
// $2 = new canonical target event ULID (final destination)
func (q *Queries) UpdateMergedIntoChain(ctx context.Context, arg UpdateMergedIntoChainParams) error {
	_, err := q.db.Exec(ctx, updateMergedIntoChain, arg.Ulid, arg.Ulid_2)
	return err
}

const updateOccurrenceDatesByEventULID = `-- name: UpdateOccurrenceDatesByEventULID :exec
UPDATE event_occurrences
   SET start_time = $1,
       end_time = $2,
       updated_at = now()
 WHERE event_id = (SELECT id FROM events WHERE ulid = $3)
`

type UpdateOccurrenceDatesByEventULIDParams struct {
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
	EventUlid string             `json:"event_ulid"`
}

// Update the start_time and end_time of all occurrences for an event identified by ULID.
// Used by the FixReview workflow to correct occurrence dates during admin review.
func (q *Queries) UpdateOccurrenceDatesByEventULID(ctx context.Context, arg UpdateOccurrenceDatesByEventULIDParams) error {
	_, err := q.db.Exec(ctx, updateOccurrenceDatesByEventULID, arg.StartTime, arg.EndTime, arg.EventUlid)
	return err
}
