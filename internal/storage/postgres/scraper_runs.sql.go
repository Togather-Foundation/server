// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scraper_runs.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestScraperRunBySource = `-- name: GetLatestScraperRunBySource :one
SELECT id, source_name, source_url, tier, started_at, completed_at, status,
       events_found, events_new, events_dup, events_failed, error_message, metadata
  FROM scraper_runs
 WHERE source_name = $1
 ORDER BY started_at DESC
 LIMIT 1
`

// Get the most recent scraper run for a given source_name.
func (q *Queries) GetLatestScraperRunBySource(ctx context.Context, sourceName string) (ScraperRun, error) {
	row := q.db.QueryRow(ctx, getLatestScraperRunBySource, sourceName)
	var i ScraperRun
	err := row.Scan(
		&i.ID,
		&i.SourceName,
		&i.SourceUrl,
		&i.Tier,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.EventsFound,
		&i.EventsNew,
		&i.EventsDup,
		&i.EventsFailed,
		&i.ErrorMessage,
		&i.Metadata,
	)
	return i, err
}

const insertScraperRun = `-- name: InsertScraperRun :one

INSERT INTO scraper_runs (source_name, source_url, tier)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertScraperRunParams struct {
	SourceName string `json:"source_name"`
	SourceUrl  string `json:"source_url"`
	Tier       int32  `json:"tier"`
}

// SQLc queries for scraper runs tracking.
// Insert a new scraper run record and return its id.
func (q *Queries) InsertScraperRun(ctx context.Context, arg InsertScraperRunParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertScraperRun, arg.SourceName, arg.SourceUrl, arg.Tier)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listRecentScraperRuns = `-- name: ListRecentScraperRuns :many
SELECT id, source_name, source_url, tier, started_at, completed_at, status,
       events_found, events_new, events_dup, events_failed, error_message, metadata
  FROM scraper_runs
 ORDER BY started_at DESC
 LIMIT $1
`

// List the N most recent scraper runs ordered by started_at DESC.
func (q *Queries) ListRecentScraperRuns(ctx context.Context, limit int32) ([]ScraperRun, error) {
	rows, err := q.db.Query(ctx, listRecentScraperRuns, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScraperRun{}
	for rows.Next() {
		var i ScraperRun
		if err := rows.Scan(
			&i.ID,
			&i.SourceName,
			&i.SourceUrl,
			&i.Tier,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Status,
			&i.EventsFound,
			&i.EventsNew,
			&i.EventsDup,
			&i.EventsFailed,
			&i.ErrorMessage,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScraperRunCompleted = `-- name: UpdateScraperRunCompleted :exec
UPDATE scraper_runs
   SET status        = 'completed',
       completed_at  = NOW(),
       events_found  = $1,
       events_new    = $2,
       events_dup    = $3,
       events_failed = $4
 WHERE id = $5
`

type UpdateScraperRunCompletedParams struct {
	EventsFound  int32 `json:"events_found"`
	EventsNew    int32 `json:"events_new"`
	EventsDup    int32 `json:"events_dup"`
	EventsFailed int32 `json:"events_failed"`
	ID           int64 `json:"id"`
}

// Mark a scraper run as completed with event counts.
func (q *Queries) UpdateScraperRunCompleted(ctx context.Context, arg UpdateScraperRunCompletedParams) error {
	_, err := q.db.Exec(ctx, updateScraperRunCompleted,
		arg.EventsFound,
		arg.EventsNew,
		arg.EventsDup,
		arg.EventsFailed,
		arg.ID,
	)
	return err
}

const updateScraperRunFailed = `-- name: UpdateScraperRunFailed :exec
UPDATE scraper_runs
   SET status        = 'failed',
       completed_at  = NOW(),
       error_message = $1
 WHERE id = $2
`

type UpdateScraperRunFailedParams struct {
	ErrorMessage pgtype.Text `json:"error_message"`
	ID           int64       `json:"id"`
}

// Mark a scraper run as failed with an error message.
func (q *Queries) UpdateScraperRunFailed(ctx context.Context, arg UpdateScraperRunFailedParams) error {
	_, err := q.db.Exec(ctx, updateScraperRunFailed, arg.ErrorMessage, arg.ID)
	return err
}
