// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: federation.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFederationNode = `-- name: CreateFederationNode :one

INSERT INTO federation_nodes (
  node_domain,
  node_name,
  base_url,
  api_version,
  geographic_scope,
  trust_level,
  federation_status,
  sync_enabled,
  sync_direction,
  contact_email,
  contact_name,
  notes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
`

type CreateFederationNodeParams struct {
	NodeDomain       string      `json:"node_domain"`
	NodeName         string      `json:"node_name"`
	BaseUrl          string      `json:"base_url"`
	ApiVersion       string      `json:"api_version"`
	GeographicScope  pgtype.Text `json:"geographic_scope"`
	TrustLevel       int32       `json:"trust_level"`
	FederationStatus string      `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	SyncDirection    pgtype.Text `json:"sync_direction"`
	ContactEmail     pgtype.Text `json:"contact_email"`
	ContactName      pgtype.Text `json:"contact_name"`
	Notes            pgtype.Text `json:"notes"`
}

// SQLc queries for federation sync.
func (q *Queries) CreateFederationNode(ctx context.Context, arg CreateFederationNodeParams) (FederationNode, error) {
	row := q.db.QueryRow(ctx, createFederationNode,
		arg.NodeDomain,
		arg.NodeName,
		arg.BaseUrl,
		arg.ApiVersion,
		arg.GeographicScope,
		arg.TrustLevel,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.SyncDirection,
		arg.ContactEmail,
		arg.ContactName,
		arg.Notes,
	)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFederationNode = `-- name: DeleteFederationNode :exec
DELETE FROM federation_nodes
WHERE id = $1
`

func (q *Queries) DeleteFederationNode(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFederationNode, id)
	return err
}

const getFederationNodeByDomain = `-- name: GetFederationNodeByDomain :one
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE node_domain = $1
`

func (q *Queries) GetFederationNodeByDomain(ctx context.Context, nodeDomain string) (FederationNode, error) {
	row := q.db.QueryRow(ctx, getFederationNodeByDomain, nodeDomain)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFederationNodeByID = `-- name: GetFederationNodeByID :one
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE id = $1
`

func (q *Queries) GetFederationNodeByID(ctx context.Context, id pgtype.UUID) (FederationNode, error) {
	row := q.db.QueryRow(ctx, getFederationNodeByID, id)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFederationNodes = `-- name: ListFederationNodes :many
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE ($1 = '' OR federation_status = $1)
  AND ($2::boolean IS NULL OR sync_enabled = $2)
  AND ($3::boolean IS NULL OR is_online = $3)
ORDER BY node_name ASC
LIMIT $4
`

type ListFederationNodesParams struct {
	FederationStatus interface{} `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	IsOnline         pgtype.Bool `json:"is_online"`
	Limit            int32       `json:"limit"`
}

func (q *Queries) ListFederationNodes(ctx context.Context, arg ListFederationNodesParams) ([]FederationNode, error) {
	rows, err := q.db.Query(ctx, listFederationNodes,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.IsOnline,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FederationNode{}
	for rows.Next() {
		var i FederationNode
		if err := rows.Scan(
			&i.ID,
			&i.NodeDomain,
			&i.NodeName,
			&i.BaseUrl,
			&i.ApiVersion,
			&i.GeographicScope,
			&i.ServiceAreaGeojson,
			&i.TrustLevel,
			&i.FederationStatus,
			&i.SyncEnabled,
			&i.SyncDirection,
			&i.LastSyncAt,
			&i.LastSuccessfulSyncAt,
			&i.SyncCursor,
			&i.RequiresAuthentication,
			&i.ApiKeyEncrypted,
			&i.ContactEmail,
			&i.ContactName,
			&i.Config,
			&i.IsOnline,
			&i.LastHealthCheckAt,
			&i.LastErrorAt,
			&i.LastErrorMessage,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFederationNode = `-- name: UpdateFederationNode :one
UPDATE federation_nodes
SET
  node_name = COALESCE($1, node_name),
  base_url = COALESCE($2, base_url),
  api_version = COALESCE($3, api_version),
  geographic_scope = COALESCE($4, geographic_scope),
  trust_level = COALESCE($5, trust_level),
  federation_status = COALESCE($6, federation_status),
  sync_enabled = COALESCE($7, sync_enabled),
  sync_direction = COALESCE($8, sync_direction),
  contact_email = COALESCE($9, contact_email),
  contact_name = COALESCE($10, contact_name),
  notes = COALESCE($11, notes),
  updated_at = now()
WHERE id = $12
RETURNING id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
`

type UpdateFederationNodeParams struct {
	NodeName         pgtype.Text `json:"node_name"`
	BaseUrl          pgtype.Text `json:"base_url"`
	ApiVersion       pgtype.Text `json:"api_version"`
	GeographicScope  pgtype.Text `json:"geographic_scope"`
	TrustLevel       pgtype.Int4 `json:"trust_level"`
	FederationStatus pgtype.Text `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	SyncDirection    pgtype.Text `json:"sync_direction"`
	ContactEmail     pgtype.Text `json:"contact_email"`
	ContactName      pgtype.Text `json:"contact_name"`
	Notes            pgtype.Text `json:"notes"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateFederationNode(ctx context.Context, arg UpdateFederationNodeParams) (FederationNode, error) {
	row := q.db.QueryRow(ctx, updateFederationNode,
		arg.NodeName,
		arg.BaseUrl,
		arg.ApiVersion,
		arg.GeographicScope,
		arg.TrustLevel,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.SyncDirection,
		arg.ContactEmail,
		arg.ContactName,
		arg.Notes,
		arg.ID,
	)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFederationNodeHealth = `-- name: UpdateFederationNodeHealth :exec
UPDATE federation_nodes
SET
  is_online = $2,
  last_health_check_at = now(),
  updated_at = now()
WHERE id = $1
`

type UpdateFederationNodeHealthParams struct {
	ID       pgtype.UUID `json:"id"`
	IsOnline pgtype.Bool `json:"is_online"`
}

func (q *Queries) UpdateFederationNodeHealth(ctx context.Context, arg UpdateFederationNodeHealthParams) error {
	_, err := q.db.Exec(ctx, updateFederationNodeHealth, arg.ID, arg.IsOnline)
	return err
}

const updateFederationNodeSyncStatus = `-- name: UpdateFederationNodeSyncStatus :exec
UPDATE federation_nodes
SET
  last_sync_at = $2,
  last_successful_sync_at = CASE WHEN $3 THEN $2 ELSE last_successful_sync_at END,
  sync_cursor = COALESCE($4, sync_cursor),
  last_error_at = CASE WHEN NOT $3 THEN now() ELSE last_error_at END,
  last_error_message = CASE WHEN NOT $3 THEN $5 ELSE last_error_message END,
  updated_at = now()
WHERE id = $1
`

type UpdateFederationNodeSyncStatusParams struct {
	ID                   pgtype.UUID        `json:"id"`
	LastSyncAt           pgtype.Timestamptz `json:"last_sync_at"`
	LastSuccessfulSyncAt pgtype.Timestamptz `json:"last_successful_sync_at"`
	SyncCursor           pgtype.Text        `json:"sync_cursor"`
	LastErrorMessage     pgtype.Text        `json:"last_error_message"`
}

func (q *Queries) UpdateFederationNodeSyncStatus(ctx context.Context, arg UpdateFederationNodeSyncStatusParams) error {
	_, err := q.db.Exec(ctx, updateFederationNodeSyncStatus,
		arg.ID,
		arg.LastSyncAt,
		arg.LastSuccessfulSyncAt,
		arg.SyncCursor,
		arg.LastErrorMessage,
	)
	return err
}
