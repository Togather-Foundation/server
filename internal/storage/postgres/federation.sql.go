// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: federation.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFederatedEventOccurrence = `-- name: CreateFederatedEventOccurrence :exec
INSERT INTO event_occurrences (
  event_id,
  start_time,
  end_time,
  timezone,
  virtual_url
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreateFederatedEventOccurrenceParams struct {
	EventID    pgtype.UUID        `json:"event_id"`
	StartTime  pgtype.Timestamptz `json:"start_time"`
	EndTime    pgtype.Timestamptz `json:"end_time"`
	Timezone   string             `json:"timezone"`
	VirtualUrl pgtype.Text        `json:"virtual_url"`
}

func (q *Queries) CreateFederatedEventOccurrence(ctx context.Context, arg CreateFederatedEventOccurrenceParams) error {
	_, err := q.db.Exec(ctx, createFederatedEventOccurrence,
		arg.EventID,
		arg.StartTime,
		arg.EndTime,
		arg.Timezone,
		arg.VirtualUrl,
	)
	return err
}

const createFederationNode = `-- name: CreateFederationNode :one

INSERT INTO federation_nodes (
  node_domain,
  node_name,
  base_url,
  api_version,
  geographic_scope,
  trust_level,
  federation_status,
  sync_enabled,
  sync_direction,
  contact_email,
  contact_name,
  notes
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
`

type CreateFederationNodeParams struct {
	NodeDomain       string      `json:"node_domain"`
	NodeName         string      `json:"node_name"`
	BaseUrl          string      `json:"base_url"`
	ApiVersion       string      `json:"api_version"`
	GeographicScope  pgtype.Text `json:"geographic_scope"`
	TrustLevel       int32       `json:"trust_level"`
	FederationStatus string      `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	SyncDirection    pgtype.Text `json:"sync_direction"`
	ContactEmail     pgtype.Text `json:"contact_email"`
	ContactName      pgtype.Text `json:"contact_name"`
	Notes            pgtype.Text `json:"notes"`
}

// SQLc queries for federation sync.
func (q *Queries) CreateFederationNode(ctx context.Context, arg CreateFederationNodeParams) (FederationNode, error) {
	row := q.db.QueryRow(ctx, createFederationNode,
		arg.NodeDomain,
		arg.NodeName,
		arg.BaseUrl,
		arg.ApiVersion,
		arg.GeographicScope,
		arg.TrustLevel,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.SyncDirection,
		arg.ContactEmail,
		arg.ContactName,
		arg.Notes,
	)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFederationNode = `-- name: DeleteFederationNode :exec
DELETE FROM federation_nodes
WHERE id = $1
`

func (q *Queries) DeleteFederationNode(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFederationNode, id)
	return err
}

const getEventByFederationURI = `-- name: GetEventByFederationURI :one

SELECT id, ulid, name, description, lifecycle_state, event_status, attendance_mode, organizer_id, primary_venue_id, series_id, image_url, public_url, virtual_url, keywords, in_language, default_language, is_accessible_for_free, accessibility_features, event_domain, origin_node_id, federation_uri, dedup_hash, license_url, license_status, takedown_requested, takedown_requested_at, takedown_request_notes, confidence, quality_score, version, created_at, updated_at, published_at, deleted_at, merged_into_id, deletion_reason
FROM events
WHERE federation_uri = $1
LIMIT 1
`

// Federation Sync Queries
func (q *Queries) GetEventByFederationURI(ctx context.Context, federationUri pgtype.Text) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByFederationURI, federationUri)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Ulid,
		&i.Name,
		&i.Description,
		&i.LifecycleState,
		&i.EventStatus,
		&i.AttendanceMode,
		&i.OrganizerID,
		&i.PrimaryVenueID,
		&i.SeriesID,
		&i.ImageUrl,
		&i.PublicUrl,
		&i.VirtualUrl,
		&i.Keywords,
		&i.InLanguage,
		&i.DefaultLanguage,
		&i.IsAccessibleForFree,
		&i.AccessibilityFeatures,
		&i.EventDomain,
		&i.OriginNodeID,
		&i.FederationUri,
		&i.DedupHash,
		&i.LicenseUrl,
		&i.LicenseStatus,
		&i.TakedownRequested,
		&i.TakedownRequestedAt,
		&i.TakedownRequestNotes,
		&i.Confidence,
		&i.QualityScore,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
		&i.MergedIntoID,
		&i.DeletionReason,
	)
	return i, err
}

const getFederationNodeByDomain = `-- name: GetFederationNodeByDomain :one
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE node_domain = $1
`

func (q *Queries) GetFederationNodeByDomain(ctx context.Context, nodeDomain string) (FederationNode, error) {
	row := q.db.QueryRow(ctx, getFederationNodeByDomain, nodeDomain)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFederationNodeByID = `-- name: GetFederationNodeByID :one
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE id = $1
`

func (q *Queries) GetFederationNodeByID(ctx context.Context, id pgtype.UUID) (FederationNode, error) {
	row := q.db.QueryRow(ctx, getFederationNodeByID, id)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFederationNodes = `-- name: ListFederationNodes :many
SELECT id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
FROM federation_nodes
WHERE ($1 = '' OR federation_status = $1)
  AND ($2::boolean IS NULL OR sync_enabled = $2)
  AND ($3::boolean IS NULL OR is_online = $3)
ORDER BY node_name ASC
LIMIT $4
`

type ListFederationNodesParams struct {
	FederationStatus interface{} `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	IsOnline         pgtype.Bool `json:"is_online"`
	Limit            int32       `json:"limit"`
}

func (q *Queries) ListFederationNodes(ctx context.Context, arg ListFederationNodesParams) ([]FederationNode, error) {
	rows, err := q.db.Query(ctx, listFederationNodes,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.IsOnline,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FederationNode{}
	for rows.Next() {
		var i FederationNode
		if err := rows.Scan(
			&i.ID,
			&i.NodeDomain,
			&i.NodeName,
			&i.BaseUrl,
			&i.ApiVersion,
			&i.GeographicScope,
			&i.ServiceAreaGeojson,
			&i.TrustLevel,
			&i.FederationStatus,
			&i.SyncEnabled,
			&i.SyncDirection,
			&i.LastSyncAt,
			&i.LastSuccessfulSyncAt,
			&i.SyncCursor,
			&i.RequiresAuthentication,
			&i.ApiKeyEncrypted,
			&i.ContactEmail,
			&i.ContactName,
			&i.Config,
			&i.IsOnline,
			&i.LastHealthCheckAt,
			&i.LastErrorAt,
			&i.LastErrorMessage,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFederationNode = `-- name: UpdateFederationNode :one
UPDATE federation_nodes
SET
  node_name = COALESCE($1, node_name),
  base_url = COALESCE($2, base_url),
  api_version = COALESCE($3, api_version),
  geographic_scope = COALESCE($4, geographic_scope),
  trust_level = COALESCE($5, trust_level),
  federation_status = COALESCE($6, federation_status),
  sync_enabled = COALESCE($7, sync_enabled),
  sync_direction = COALESCE($8, sync_direction),
  contact_email = COALESCE($9, contact_email),
  contact_name = COALESCE($10, contact_name),
  notes = COALESCE($11, notes),
  updated_at = now()
WHERE id = $12
RETURNING id, node_domain, node_name, base_url, api_version, geographic_scope, service_area_geojson, trust_level, federation_status, sync_enabled, sync_direction, last_sync_at, last_successful_sync_at, sync_cursor, requires_authentication, api_key_encrypted, contact_email, contact_name, config, is_online, last_health_check_at, last_error_at, last_error_message, notes, created_at, updated_at
`

type UpdateFederationNodeParams struct {
	NodeName         pgtype.Text `json:"node_name"`
	BaseUrl          pgtype.Text `json:"base_url"`
	ApiVersion       pgtype.Text `json:"api_version"`
	GeographicScope  pgtype.Text `json:"geographic_scope"`
	TrustLevel       pgtype.Int4 `json:"trust_level"`
	FederationStatus pgtype.Text `json:"federation_status"`
	SyncEnabled      pgtype.Bool `json:"sync_enabled"`
	SyncDirection    pgtype.Text `json:"sync_direction"`
	ContactEmail     pgtype.Text `json:"contact_email"`
	ContactName      pgtype.Text `json:"contact_name"`
	Notes            pgtype.Text `json:"notes"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateFederationNode(ctx context.Context, arg UpdateFederationNodeParams) (FederationNode, error) {
	row := q.db.QueryRow(ctx, updateFederationNode,
		arg.NodeName,
		arg.BaseUrl,
		arg.ApiVersion,
		arg.GeographicScope,
		arg.TrustLevel,
		arg.FederationStatus,
		arg.SyncEnabled,
		arg.SyncDirection,
		arg.ContactEmail,
		arg.ContactName,
		arg.Notes,
		arg.ID,
	)
	var i FederationNode
	err := row.Scan(
		&i.ID,
		&i.NodeDomain,
		&i.NodeName,
		&i.BaseUrl,
		&i.ApiVersion,
		&i.GeographicScope,
		&i.ServiceAreaGeojson,
		&i.TrustLevel,
		&i.FederationStatus,
		&i.SyncEnabled,
		&i.SyncDirection,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.SyncCursor,
		&i.RequiresAuthentication,
		&i.ApiKeyEncrypted,
		&i.ContactEmail,
		&i.ContactName,
		&i.Config,
		&i.IsOnline,
		&i.LastHealthCheckAt,
		&i.LastErrorAt,
		&i.LastErrorMessage,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFederationNodeHealth = `-- name: UpdateFederationNodeHealth :exec
UPDATE federation_nodes
SET
  is_online = $2,
  last_health_check_at = now(),
  updated_at = now()
WHERE id = $1
`

type UpdateFederationNodeHealthParams struct {
	ID       pgtype.UUID `json:"id"`
	IsOnline pgtype.Bool `json:"is_online"`
}

func (q *Queries) UpdateFederationNodeHealth(ctx context.Context, arg UpdateFederationNodeHealthParams) error {
	_, err := q.db.Exec(ctx, updateFederationNodeHealth, arg.ID, arg.IsOnline)
	return err
}

const updateFederationNodeSyncStatus = `-- name: UpdateFederationNodeSyncStatus :exec
UPDATE federation_nodes
SET
  last_sync_at = $2,
  last_successful_sync_at = CASE WHEN $3 THEN $2 ELSE last_successful_sync_at END,
  sync_cursor = COALESCE($4, sync_cursor),
  last_error_at = CASE WHEN NOT $3 THEN now() ELSE last_error_at END,
  last_error_message = CASE WHEN NOT $3 THEN $5 ELSE last_error_message END,
  updated_at = now()
WHERE id = $1
`

type UpdateFederationNodeSyncStatusParams struct {
	ID                   pgtype.UUID        `json:"id"`
	LastSyncAt           pgtype.Timestamptz `json:"last_sync_at"`
	LastSuccessfulSyncAt pgtype.Timestamptz `json:"last_successful_sync_at"`
	SyncCursor           pgtype.Text        `json:"sync_cursor"`
	LastErrorMessage     pgtype.Text        `json:"last_error_message"`
}

func (q *Queries) UpdateFederationNodeSyncStatus(ctx context.Context, arg UpdateFederationNodeSyncStatusParams) error {
	_, err := q.db.Exec(ctx, updateFederationNodeSyncStatus,
		arg.ID,
		arg.LastSyncAt,
		arg.LastSuccessfulSyncAt,
		arg.SyncCursor,
		arg.LastErrorMessage,
	)
	return err
}

const upsertFederatedEvent = `-- name: UpsertFederatedEvent :one
INSERT INTO events (
  ulid,
  name,
  description,
  lifecycle_state,
  event_status,
  attendance_mode,
  organizer_id,
  primary_venue_id,
  series_id,
  image_url,
  public_url,
  virtual_url,
  keywords,
  in_language,
  default_language,
  is_accessible_for_free,
  accessibility_features,
  event_domain,
  origin_node_id,
  federation_uri,
  license_url,
  license_status,
  confidence,
  quality_score,
  version,
  created_at,
  updated_at,
  published_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 
  $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
  $21, $22, $23, $24, $25, $26, $27, $28
)
ON CONFLICT (federation_uri)
WHERE federation_uri IS NOT NULL
DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  lifecycle_state = EXCLUDED.lifecycle_state,
  event_status = EXCLUDED.event_status,
  attendance_mode = EXCLUDED.attendance_mode,
  organizer_id = EXCLUDED.organizer_id,
  primary_venue_id = EXCLUDED.primary_venue_id,
  image_url = EXCLUDED.image_url,
  public_url = EXCLUDED.public_url,
  virtual_url = EXCLUDED.virtual_url,
  keywords = EXCLUDED.keywords,
  in_language = EXCLUDED.in_language,
  default_language = EXCLUDED.default_language,
  is_accessible_for_free = EXCLUDED.is_accessible_for_free,
  accessibility_features = EXCLUDED.accessibility_features,
  event_domain = EXCLUDED.event_domain,
  confidence = EXCLUDED.confidence,
  quality_score = EXCLUDED.quality_score,
  version = events.version + 1,
  updated_at = now()
RETURNING id, ulid, name, description, lifecycle_state, event_status, attendance_mode, organizer_id, primary_venue_id, series_id, image_url, public_url, virtual_url, keywords, in_language, default_language, is_accessible_for_free, accessibility_features, event_domain, origin_node_id, federation_uri, dedup_hash, license_url, license_status, takedown_requested, takedown_requested_at, takedown_request_notes, confidence, quality_score, version, created_at, updated_at, published_at, deleted_at, merged_into_id, deletion_reason
`

type UpsertFederatedEventParams struct {
	Ulid                  string             `json:"ulid"`
	Name                  string             `json:"name"`
	Description           pgtype.Text        `json:"description"`
	LifecycleState        string             `json:"lifecycle_state"`
	EventStatus           pgtype.Text        `json:"event_status"`
	AttendanceMode        pgtype.Text        `json:"attendance_mode"`
	OrganizerID           pgtype.UUID        `json:"organizer_id"`
	PrimaryVenueID        pgtype.UUID        `json:"primary_venue_id"`
	SeriesID              pgtype.UUID        `json:"series_id"`
	ImageUrl              pgtype.Text        `json:"image_url"`
	PublicUrl             pgtype.Text        `json:"public_url"`
	VirtualUrl            pgtype.Text        `json:"virtual_url"`
	Keywords              []string           `json:"keywords"`
	InLanguage            []string           `json:"in_language"`
	DefaultLanguage       pgtype.Text        `json:"default_language"`
	IsAccessibleForFree   pgtype.Bool        `json:"is_accessible_for_free"`
	AccessibilityFeatures []string           `json:"accessibility_features"`
	EventDomain           pgtype.Text        `json:"event_domain"`
	OriginNodeID          pgtype.UUID        `json:"origin_node_id"`
	FederationUri         pgtype.Text        `json:"federation_uri"`
	LicenseUrl            string             `json:"license_url"`
	LicenseStatus         string             `json:"license_status"`
	Confidence            pgtype.Numeric     `json:"confidence"`
	QualityScore          pgtype.Int4        `json:"quality_score"`
	Version               int32              `json:"version"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	PublishedAt           pgtype.Timestamptz `json:"published_at"`
}

func (q *Queries) UpsertFederatedEvent(ctx context.Context, arg UpsertFederatedEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, upsertFederatedEvent,
		arg.Ulid,
		arg.Name,
		arg.Description,
		arg.LifecycleState,
		arg.EventStatus,
		arg.AttendanceMode,
		arg.OrganizerID,
		arg.PrimaryVenueID,
		arg.SeriesID,
		arg.ImageUrl,
		arg.PublicUrl,
		arg.VirtualUrl,
		arg.Keywords,
		arg.InLanguage,
		arg.DefaultLanguage,
		arg.IsAccessibleForFree,
		arg.AccessibilityFeatures,
		arg.EventDomain,
		arg.OriginNodeID,
		arg.FederationUri,
		arg.LicenseUrl,
		arg.LicenseStatus,
		arg.Confidence,
		arg.QualityScore,
		arg.Version,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PublishedAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Ulid,
		&i.Name,
		&i.Description,
		&i.LifecycleState,
		&i.EventStatus,
		&i.AttendanceMode,
		&i.OrganizerID,
		&i.PrimaryVenueID,
		&i.SeriesID,
		&i.ImageUrl,
		&i.PublicUrl,
		&i.VirtualUrl,
		&i.Keywords,
		&i.InLanguage,
		&i.DefaultLanguage,
		&i.IsAccessibleForFree,
		&i.AccessibilityFeatures,
		&i.EventDomain,
		&i.OriginNodeID,
		&i.FederationUri,
		&i.DedupHash,
		&i.LicenseUrl,
		&i.LicenseStatus,
		&i.TakedownRequested,
		&i.TakedownRequestedAt,
		&i.TakedownRequestNotes,
		&i.Confidence,
		&i.QualityScore,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.DeletedAt,
		&i.MergedIntoID,
		&i.DeletionReason,
	)
	return i, err
}
