// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: provenance.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllFieldProvenanceHistory = `-- name: GetAllFieldProvenanceHistory :many
SELECT
  fp.id,
  fp.event_id,
  fp.field_path,
  fp.value_hash,
  fp.value_preview,
  fp.source_id,
  fp.confidence,
  fp.observed_at,
  fp.applied_to_canonical,
  fp.superseded_at,
  fp.superseded_by_id,
  s.name as source_name,
  s.source_type,
  s.trust_level,
  s.license_url,
  s.license_type
FROM field_provenance fp
JOIN sources s ON s.id = fp.source_id
WHERE fp.event_id = $1
  AND fp.field_path = $2
ORDER BY fp.observed_at DESC
`

type GetAllFieldProvenanceHistoryParams struct {
	EventID   pgtype.UUID `json:"event_id"`
	FieldPath string      `json:"field_path"`
}

type GetAllFieldProvenanceHistoryRow struct {
	ID                 pgtype.UUID        `json:"id"`
	EventID            pgtype.UUID        `json:"event_id"`
	FieldPath          string             `json:"field_path"`
	ValueHash          string             `json:"value_hash"`
	ValuePreview       pgtype.Text        `json:"value_preview"`
	SourceID           pgtype.UUID        `json:"source_id"`
	Confidence         pgtype.Numeric     `json:"confidence"`
	ObservedAt         pgtype.Timestamptz `json:"observed_at"`
	AppliedToCanonical bool               `json:"applied_to_canonical"`
	SupersededAt       pgtype.Timestamptz `json:"superseded_at"`
	SupersededByID     pgtype.UUID        `json:"superseded_by_id"`
	SourceName         string             `json:"source_name"`
	SourceType         string             `json:"source_type"`
	TrustLevel         int32              `json:"trust_level"`
	LicenseUrl         string             `json:"license_url"`
	LicenseType        string             `json:"license_type"`
}

// Gets complete provenance history for a field, including superseded records
func (q *Queries) GetAllFieldProvenanceHistory(ctx context.Context, arg GetAllFieldProvenanceHistoryParams) ([]GetAllFieldProvenanceHistoryRow, error) {
	rows, err := q.db.Query(ctx, getAllFieldProvenanceHistory, arg.EventID, arg.FieldPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllFieldProvenanceHistoryRow{}
	for rows.Next() {
		var i GetAllFieldProvenanceHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.FieldPath,
			&i.ValueHash,
			&i.ValuePreview,
			&i.SourceID,
			&i.Confidence,
			&i.ObservedAt,
			&i.AppliedToCanonical,
			&i.SupersededAt,
			&i.SupersededByID,
			&i.SourceName,
			&i.SourceType,
			&i.TrustLevel,
			&i.LicenseUrl,
			&i.LicenseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCanonicalFieldValue = `-- name: GetCanonicalFieldValue :one
SELECT
  fp.id,
  fp.event_id,
  fp.field_path,
  fp.value_hash,
  fp.value_preview,
  fp.source_id,
  fp.confidence,
  fp.observed_at,
  fp.applied_to_canonical,
  s.name as source_name,
  s.source_type,
  s.trust_level,
  s.license_url,
  s.license_type
FROM field_provenance fp
JOIN sources s ON s.id = fp.source_id
WHERE fp.event_id = $1
  AND fp.field_path = $2
  AND fp.applied_to_canonical = true
  AND fp.superseded_at IS NULL
ORDER BY s.trust_level DESC, fp.confidence DESC, fp.observed_at DESC
LIMIT 1
`

type GetCanonicalFieldValueParams struct {
	EventID   pgtype.UUID `json:"event_id"`
	FieldPath string      `json:"field_path"`
}

type GetCanonicalFieldValueRow struct {
	ID                 pgtype.UUID        `json:"id"`
	EventID            pgtype.UUID        `json:"event_id"`
	FieldPath          string             `json:"field_path"`
	ValueHash          string             `json:"value_hash"`
	ValuePreview       pgtype.Text        `json:"value_preview"`
	SourceID           pgtype.UUID        `json:"source_id"`
	Confidence         pgtype.Numeric     `json:"confidence"`
	ObservedAt         pgtype.Timestamptz `json:"observed_at"`
	AppliedToCanonical bool               `json:"applied_to_canonical"`
	SourceName         string             `json:"source_name"`
	SourceType         string             `json:"source_type"`
	TrustLevel         int32              `json:"trust_level"`
	LicenseUrl         string             `json:"license_url"`
	LicenseType        string             `json:"license_type"`
}

// Gets the canonical (winning) field value based on conflict resolution rules
// Priority: trust_level DESC, confidence DESC, observed_at DESC
func (q *Queries) GetCanonicalFieldValue(ctx context.Context, arg GetCanonicalFieldValueParams) (GetCanonicalFieldValueRow, error) {
	row := q.db.QueryRow(ctx, getCanonicalFieldValue, arg.EventID, arg.FieldPath)
	var i GetCanonicalFieldValueRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.FieldPath,
		&i.ValueHash,
		&i.ValuePreview,
		&i.SourceID,
		&i.Confidence,
		&i.ObservedAt,
		&i.AppliedToCanonical,
		&i.SourceName,
		&i.SourceType,
		&i.TrustLevel,
		&i.LicenseUrl,
		&i.LicenseType,
	)
	return i, err
}

const getEventSources = `-- name: GetEventSources :many

SELECT
  es.id,
  es.event_id,
  es.source_id,
  es.source_url,
  es.source_event_id,
  es.retrieved_at,
  es.payload,
  es.payload_hash,
  es.confidence,
  s.name as source_name,
  s.source_type,
  s.trust_level,
  s.license_url,
  s.license_type
FROM event_sources es
JOIN sources s ON s.id = es.source_id
WHERE es.event_id = $1
ORDER BY s.trust_level DESC, es.confidence DESC, es.retrieved_at DESC
`

type GetEventSourcesRow struct {
	ID            pgtype.UUID        `json:"id"`
	EventID       pgtype.UUID        `json:"event_id"`
	SourceID      pgtype.UUID        `json:"source_id"`
	SourceUrl     string             `json:"source_url"`
	SourceEventID pgtype.Text        `json:"source_event_id"`
	RetrievedAt   pgtype.Timestamptz `json:"retrieved_at"`
	Payload       []byte             `json:"payload"`
	PayloadHash   string             `json:"payload_hash"`
	Confidence    pgtype.Numeric     `json:"confidence"`
	SourceName    string             `json:"source_name"`
	SourceType    string             `json:"source_type"`
	TrustLevel    int32              `json:"trust_level"`
	LicenseUrl    string             `json:"license_url"`
	LicenseType   string             `json:"license_type"`
}

// SQLc queries for provenance tracking.
// Retrieves all sources for a given event with source metadata and timestamps (FR-029)
func (q *Queries) GetEventSources(ctx context.Context, eventID pgtype.UUID) ([]GetEventSourcesRow, error) {
	rows, err := q.db.Query(ctx, getEventSources, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventSourcesRow{}
	for rows.Next() {
		var i GetEventSourcesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.SourceID,
			&i.SourceUrl,
			&i.SourceEventID,
			&i.RetrievedAt,
			&i.Payload,
			&i.PayloadHash,
			&i.Confidence,
			&i.SourceName,
			&i.SourceType,
			&i.TrustLevel,
			&i.LicenseUrl,
			&i.LicenseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFieldProvenance = `-- name: GetFieldProvenance :many
SELECT
  fp.id,
  fp.event_id,
  fp.field_path,
  fp.value_hash,
  fp.value_preview,
  fp.source_id,
  fp.confidence,
  fp.observed_at,
  fp.applied_to_canonical,
  fp.superseded_at,
  fp.superseded_by_id,
  s.name as source_name,
  s.source_type,
  s.trust_level,
  s.license_url,
  s.license_type
FROM field_provenance fp
JOIN sources s ON s.id = fp.source_id
WHERE fp.event_id = $1
  AND fp.applied_to_canonical = true
  AND fp.superseded_at IS NULL
ORDER BY s.trust_level DESC, fp.confidence DESC, fp.observed_at DESC
`

type GetFieldProvenanceRow struct {
	ID                 pgtype.UUID        `json:"id"`
	EventID            pgtype.UUID        `json:"event_id"`
	FieldPath          string             `json:"field_path"`
	ValueHash          string             `json:"value_hash"`
	ValuePreview       pgtype.Text        `json:"value_preview"`
	SourceID           pgtype.UUID        `json:"source_id"`
	Confidence         pgtype.Numeric     `json:"confidence"`
	ObservedAt         pgtype.Timestamptz `json:"observed_at"`
	AppliedToCanonical bool               `json:"applied_to_canonical"`
	SupersededAt       pgtype.Timestamptz `json:"superseded_at"`
	SupersededByID     pgtype.UUID        `json:"superseded_by_id"`
	SourceName         string             `json:"source_name"`
	SourceType         string             `json:"source_type"`
	TrustLevel         int32              `json:"trust_level"`
	LicenseUrl         string             `json:"license_url"`
	LicenseType        string             `json:"license_type"`
}

// Retrieves field-level provenance for an event, optionally filtered by field paths
// Includes source metadata and timestamps per FR-024 and FR-029
func (q *Queries) GetFieldProvenance(ctx context.Context, eventID pgtype.UUID) ([]GetFieldProvenanceRow, error) {
	rows, err := q.db.Query(ctx, getFieldProvenance, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFieldProvenanceRow{}
	for rows.Next() {
		var i GetFieldProvenanceRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.FieldPath,
			&i.ValueHash,
			&i.ValuePreview,
			&i.SourceID,
			&i.Confidence,
			&i.ObservedAt,
			&i.AppliedToCanonical,
			&i.SupersededAt,
			&i.SupersededByID,
			&i.SourceName,
			&i.SourceType,
			&i.TrustLevel,
			&i.LicenseUrl,
			&i.LicenseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFieldProvenanceForPaths = `-- name: GetFieldProvenanceForPaths :many
SELECT
  fp.id,
  fp.event_id,
  fp.field_path,
  fp.value_hash,
  fp.value_preview,
  fp.source_id,
  fp.confidence,
  fp.observed_at,
  fp.applied_to_canonical,
  fp.superseded_at,
  fp.superseded_by_id,
  s.name as source_name,
  s.source_type,
  s.trust_level,
  s.license_url,
  s.license_type
FROM field_provenance fp
JOIN sources s ON s.id = fp.source_id
WHERE fp.event_id = $1
  AND fp.field_path = ANY($2::text[])
  AND fp.applied_to_canonical = true
  AND fp.superseded_at IS NULL
ORDER BY s.trust_level DESC, fp.confidence DESC, fp.observed_at DESC
`

type GetFieldProvenanceForPathsParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Column2 []string    `json:"column_2"`
}

type GetFieldProvenanceForPathsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	EventID            pgtype.UUID        `json:"event_id"`
	FieldPath          string             `json:"field_path"`
	ValueHash          string             `json:"value_hash"`
	ValuePreview       pgtype.Text        `json:"value_preview"`
	SourceID           pgtype.UUID        `json:"source_id"`
	Confidence         pgtype.Numeric     `json:"confidence"`
	ObservedAt         pgtype.Timestamptz `json:"observed_at"`
	AppliedToCanonical bool               `json:"applied_to_canonical"`
	SupersededAt       pgtype.Timestamptz `json:"superseded_at"`
	SupersededByID     pgtype.UUID        `json:"superseded_by_id"`
	SourceName         string             `json:"source_name"`
	SourceType         string             `json:"source_type"`
	TrustLevel         int32              `json:"trust_level"`
	LicenseUrl         string             `json:"license_url"`
	LicenseType        string             `json:"license_type"`
}

// Retrieves field-level provenance for specific field paths on an event
func (q *Queries) GetFieldProvenanceForPaths(ctx context.Context, arg GetFieldProvenanceForPathsParams) ([]GetFieldProvenanceForPathsRow, error) {
	rows, err := q.db.Query(ctx, getFieldProvenanceForPaths, arg.EventID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFieldProvenanceForPathsRow{}
	for rows.Next() {
		var i GetFieldProvenanceForPathsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.FieldPath,
			&i.ValueHash,
			&i.ValuePreview,
			&i.SourceID,
			&i.Confidence,
			&i.ObservedAt,
			&i.AppliedToCanonical,
			&i.SupersededAt,
			&i.SupersededByID,
			&i.SourceName,
			&i.SourceType,
			&i.TrustLevel,
			&i.LicenseUrl,
			&i.LicenseType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSourceByID = `-- name: GetSourceByID :one
SELECT
  id,
  name,
  source_type,
  base_url,
  trust_level,
  license_url,
  license_type,
  is_active,
  created_at,
  updated_at
FROM sources
WHERE id = $1
`

type GetSourceByIDRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	SourceType  string             `json:"source_type"`
	BaseUrl     pgtype.Text        `json:"base_url"`
	TrustLevel  int32              `json:"trust_level"`
	LicenseUrl  string             `json:"license_url"`
	LicenseType string             `json:"license_type"`
	IsActive    pgtype.Bool        `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Retrieves source metadata by ID
func (q *Queries) GetSourceByID(ctx context.Context, id pgtype.UUID) (GetSourceByIDRow, error) {
	row := q.db.QueryRow(ctx, getSourceByID, id)
	var i GetSourceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SourceType,
		&i.BaseUrl,
		&i.TrustLevel,
		&i.LicenseUrl,
		&i.LicenseType,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSourcesByEventID = `-- name: GetSourcesByEventID :many
SELECT DISTINCT
  s.id,
  s.name,
  s.source_type,
  s.base_url,
  s.trust_level,
  s.license_url,
  s.license_type,
  s.is_active
FROM sources s
JOIN event_sources es ON es.source_id = s.id
WHERE es.event_id = $1
ORDER BY s.trust_level DESC, s.name ASC
`

type GetSourcesByEventIDRow struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	SourceType  string      `json:"source_type"`
	BaseUrl     pgtype.Text `json:"base_url"`
	TrustLevel  int32       `json:"trust_level"`
	LicenseUrl  string      `json:"license_url"`
	LicenseType string      `json:"license_type"`
	IsActive    pgtype.Bool `json:"is_active"`
}

// Gets all sources that contributed to an event (deduplicated)
func (q *Queries) GetSourcesByEventID(ctx context.Context, eventID pgtype.UUID) ([]GetSourcesByEventIDRow, error) {
	rows, err := q.db.Query(ctx, getSourcesByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSourcesByEventIDRow{}
	for rows.Next() {
		var i GetSourcesByEventIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SourceType,
			&i.BaseUrl,
			&i.TrustLevel,
			&i.LicenseUrl,
			&i.LicenseType,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEventSource = `-- name: InsertEventSource :one
INSERT INTO event_sources (
  event_id,
  source_id,
  source_url,
  source_event_id,
  retrieved_at,
  payload,
  payload_hash,
  confidence
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, event_id, source_id, source_url, source_event_id, retrieved_at, payload, payload_hash, confidence
`

type InsertEventSourceParams struct {
	EventID       pgtype.UUID        `json:"event_id"`
	SourceID      pgtype.UUID        `json:"source_id"`
	SourceUrl     string             `json:"source_url"`
	SourceEventID pgtype.Text        `json:"source_event_id"`
	RetrievedAt   pgtype.Timestamptz `json:"retrieved_at"`
	Payload       []byte             `json:"payload"`
	PayloadHash   string             `json:"payload_hash"`
	Confidence    pgtype.Numeric     `json:"confidence"`
}

// Records a source's contribution to an event with source and received timestamps (FR-029)
func (q *Queries) InsertEventSource(ctx context.Context, arg InsertEventSourceParams) (EventSource, error) {
	row := q.db.QueryRow(ctx, insertEventSource,
		arg.EventID,
		arg.SourceID,
		arg.SourceUrl,
		arg.SourceEventID,
		arg.RetrievedAt,
		arg.Payload,
		arg.PayloadHash,
		arg.Confidence,
	)
	var i EventSource
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.SourceID,
		&i.SourceUrl,
		&i.SourceEventID,
		&i.RetrievedAt,
		&i.Payload,
		&i.PayloadHash,
		&i.Confidence,
	)
	return i, err
}

const insertFieldProvenance = `-- name: InsertFieldProvenance :one
INSERT INTO field_provenance (
  event_id,
  field_path,
  value_hash,
  value_preview,
  source_id,
  confidence,
  observed_at,
  applied_to_canonical
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, event_id, field_path, value_hash, value_preview, source_id, confidence, observed_at, applied_to_canonical, superseded_at, superseded_by_id
`

type InsertFieldProvenanceParams struct {
	EventID            pgtype.UUID        `json:"event_id"`
	FieldPath          string             `json:"field_path"`
	ValueHash          string             `json:"value_hash"`
	ValuePreview       pgtype.Text        `json:"value_preview"`
	SourceID           pgtype.UUID        `json:"source_id"`
	Confidence         pgtype.Numeric     `json:"confidence"`
	ObservedAt         pgtype.Timestamptz `json:"observed_at"`
	AppliedToCanonical bool               `json:"applied_to_canonical"`
}

// Records field-level provenance with source timestamp
func (q *Queries) InsertFieldProvenance(ctx context.Context, arg InsertFieldProvenanceParams) (FieldProvenance, error) {
	row := q.db.QueryRow(ctx, insertFieldProvenance,
		arg.EventID,
		arg.FieldPath,
		arg.ValueHash,
		arg.ValuePreview,
		arg.SourceID,
		arg.Confidence,
		arg.ObservedAt,
		arg.AppliedToCanonical,
	)
	var i FieldProvenance
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.FieldPath,
		&i.ValueHash,
		&i.ValuePreview,
		&i.SourceID,
		&i.Confidence,
		&i.ObservedAt,
		&i.AppliedToCanonical,
		&i.SupersededAt,
		&i.SupersededByID,
	)
	return i, err
}

const supersedeFieldProvenance = `-- name: SupersedeFieldProvenance :exec
UPDATE field_provenance
SET superseded_at = now(),
    superseded_by_id = $2
WHERE id = $1
`

type SupersedeFieldProvenanceParams struct {
	ID             pgtype.UUID `json:"id"`
	SupersededByID pgtype.UUID `json:"superseded_by_id"`
}

// Marks a field provenance record as superseded by a new record
func (q *Queries) SupersedeFieldProvenance(ctx context.Context, arg SupersedeFieldProvenanceParams) error {
	_, err := q.db.Exec(ctx, supersedeFieldProvenance, arg.ID, arg.SupersededByID)
	return err
}
