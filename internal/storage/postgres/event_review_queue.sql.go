// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event_review_queue.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveReview = `-- name: ApproveReview :one
UPDATE event_review_queue
   SET status = 'approved',
       reviewed_by = $1,
       reviewed_at = NOW(),
       review_notes = $2,
       updated_at = NOW()
 WHERE id = $3
   AND status = 'pending'
RETURNING id,
          event_id,
          original_payload,
          normalized_payload,
          warnings,
          source_id,
          source_external_id,
          dedup_hash,
          event_start_time,
          event_end_time,
          status,
          reviewed_by,
          reviewed_at,
          review_notes,
          rejection_reason,
          created_at,
          updated_at
`

type ApproveReviewParams struct {
	ReviewedBy pgtype.Text `json:"reviewed_by"`
	Notes      pgtype.Text `json:"notes"`
	ID         int32       `json:"id"`
}

type ApproveReviewRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Mark review as approved
func (q *Queries) ApproveReview(ctx context.Context, arg ApproveReviewParams) (ApproveReviewRow, error) {
	row := q.db.QueryRow(ctx, approveReview, arg.ReviewedBy, arg.Notes, arg.ID)
	var i ApproveReviewRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const cleanupArchivedReviews = `-- name: CleanupArchivedReviews :exec
DELETE FROM event_review_queue
 WHERE status IN ('approved', 'superseded', 'merged')
   AND reviewed_at < NOW() - INTERVAL '90 days'
`

// Archive old approved/superseded/merged reviews (90 day retention)
func (q *Queries) CleanupArchivedReviews(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupArchivedReviews)
	return err
}

const cleanupExpiredRejections = `-- name: CleanupExpiredRejections :exec
DELETE FROM event_review_queue
 WHERE status = 'rejected'
   AND (
     event_end_time < NOW() - INTERVAL '7 days'
     OR (event_end_time IS NULL AND event_start_time < NOW() - INTERVAL '7 days')
   )
`

// Delete rejected reviews for past events (7 day grace period)
func (q *Queries) CleanupExpiredRejections(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredRejections)
	return err
}

const cleanupUnreviewedEvents = `-- name: CleanupUnreviewedEvents :exec
DELETE FROM event_review_queue
 WHERE status = 'pending'
   AND event_start_time < NOW()
`

// Delete pending reviews for events that have already started (too late to review)
func (q *Queries) CleanupUnreviewedEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupUnreviewedEvents)
	return err
}

const countReviewQueueByStatus = `-- name: CountReviewQueueByStatus :one
SELECT COUNT(*) as total
  FROM event_review_queue
 WHERE ($1::text IS NULL OR status = $1)
`

// Count total reviews by status (for badge display)
func (q *Queries) CountReviewQueueByStatus(ctx context.Context, status pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countReviewQueueByStatus, status)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createReviewQueueEntry = `-- name: CreateReviewQueueEntry :one
INSERT INTO event_review_queue (
  event_id,
  original_payload,
  normalized_payload,
  warnings,
  source_id,
  source_external_id,
  dedup_hash,
  event_start_time,
  event_end_time
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9
)
RETURNING id,
          event_id,
          original_payload,
          normalized_payload,
          warnings,
          source_id,
          source_external_id,
          dedup_hash,
          event_start_time,
          event_end_time,
          status,
          reviewed_by,
          reviewed_at,
          review_notes,
          rejection_reason,
          created_at,
          updated_at
`

type CreateReviewQueueEntryParams struct {
	EventID           pgtype.UUID        `json:"event_id"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
}

type CreateReviewQueueEntryRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Create new review queue entry
func (q *Queries) CreateReviewQueueEntry(ctx context.Context, arg CreateReviewQueueEntryParams) (CreateReviewQueueEntryRow, error) {
	row := q.db.QueryRow(ctx, createReviewQueueEntry,
		arg.EventID,
		arg.OriginalPayload,
		arg.NormalizedPayload,
		arg.Warnings,
		arg.SourceID,
		arg.SourceExternalID,
		arg.DedupHash,
		arg.EventStartTime,
		arg.EventEndTime,
	)
	var i CreateReviewQueueEntryRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findReviewByDedup = `-- name: FindReviewByDedup :one

SELECT r.id,
       r.event_id,
       e.ulid AS event_ulid,
       r.original_payload,
       r.normalized_payload,
       r.warnings,
       r.source_id,
       r.source_external_id,
       r.dedup_hash,
       r.event_start_time,
       r.event_end_time,
       r.status,
       r.reviewed_by,
       r.reviewed_at,
       r.review_notes,
       r.rejection_reason,
       r.created_at,
       r.updated_at
  FROM event_review_queue r
  JOIN events e ON e.id = r.event_id
 WHERE (
         ($1::text IS NOT NULL 
          AND $2::text IS NOT NULL 
          AND r.source_id = $1 
          AND r.source_external_id = $2)
         OR
         ($3::text IS NOT NULL 
          AND r.dedup_hash = $3)
       )
   AND r.status IN ('pending', 'rejected')
 ORDER BY r.created_at DESC
 LIMIT 1
`

type FindReviewByDedupParams struct {
	SourceID         pgtype.Text `json:"source_id"`
	SourceExternalID pgtype.Text `json:"source_external_id"`
	DedupHash        pgtype.Text `json:"dedup_hash"`
}

type FindReviewByDedupRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	EventUlid         string             `json:"event_ulid"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// SQLc queries for event_review_queue domain.
// See docs/architecture/event-review-workflow.md for complete design.
// Find existing review by deduplication keys (checks source_external_id or dedup_hash)
func (q *Queries) FindReviewByDedup(ctx context.Context, arg FindReviewByDedupParams) (FindReviewByDedupRow, error) {
	row := q.db.QueryRow(ctx, findReviewByDedup, arg.SourceID, arg.SourceExternalID, arg.DedupHash)
	var i FindReviewByDedupRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUlid,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewQueueEntry = `-- name: GetReviewQueueEntry :one
SELECT r.id,
       r.event_id,
       e.ulid AS event_ulid,
       r.original_payload,
       r.normalized_payload,
       r.warnings,
       r.source_id,
       r.source_external_id,
       r.dedup_hash,
       r.event_start_time,
       r.event_end_time,
       r.status,
       r.reviewed_by,
       r.reviewed_at,
       r.review_notes,
       r.rejection_reason,
       r.created_at,
       r.updated_at
  FROM event_review_queue r
  JOIN events e ON e.id = r.event_id
 WHERE r.id = $1
`

type GetReviewQueueEntryRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	EventUlid         string             `json:"event_ulid"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Get single review by ID
func (q *Queries) GetReviewQueueEntry(ctx context.Context, id int32) (GetReviewQueueEntryRow, error) {
	row := q.db.QueryRow(ctx, getReviewQueueEntry, id)
	var i GetReviewQueueEntryRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.EventUlid,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listReviewQueue = `-- name: ListReviewQueue :many
SELECT r.id,
       r.event_id,
       e.ulid AS event_ulid,
       r.original_payload,
       r.normalized_payload,
       r.warnings,
       r.source_id,
       r.source_external_id,
       r.dedup_hash,
       r.event_start_time,
       r.event_end_time,
       r.status,
       r.reviewed_by,
       r.reviewed_at,
       r.review_notes,
       r.rejection_reason,
       r.created_at,
       r.updated_at
  FROM event_review_queue r
  JOIN events e ON e.id = r.event_id
 WHERE ($1::text IS NULL OR r.status = $1)
   AND ($2::integer IS NULL OR r.id > $2)
 ORDER BY r.id ASC
 LIMIT $3
`

type ListReviewQueueParams struct {
	Status  pgtype.Text `json:"status"`
	AfterID pgtype.Int4 `json:"after_id"`
	Limit   int32       `json:"limit"`
}

type ListReviewQueueRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	EventUlid         string             `json:"event_ulid"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// List reviews with pagination and status filter
func (q *Queries) ListReviewQueue(ctx context.Context, arg ListReviewQueueParams) ([]ListReviewQueueRow, error) {
	rows, err := q.db.Query(ctx, listReviewQueue, arg.Status, arg.AfterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReviewQueueRow{}
	for rows.Next() {
		var i ListReviewQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.EventUlid,
			&i.OriginalPayload,
			&i.NormalizedPayload,
			&i.Warnings,
			&i.SourceID,
			&i.SourceExternalID,
			&i.DedupHash,
			&i.EventStartTime,
			&i.EventEndTime,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markUnreviewedEventsAsDeleted = `-- name: MarkUnreviewedEventsAsDeleted :exec
UPDATE events
   SET lifecycle_state = 'deleted',
       deleted_at = NOW(),
       deletion_reason = 'Expired from review queue - event started before review',
       updated_at = NOW()
 WHERE id IN (
   SELECT event_id FROM event_review_queue
   WHERE status = 'pending' AND event_start_time < NOW()
 )
   AND lifecycle_state = 'pending_review'
`

// Mark events as deleted before cleaning up their pending reviews
func (q *Queries) MarkUnreviewedEventsAsDeleted(ctx context.Context) error {
	_, err := q.db.Exec(ctx, markUnreviewedEventsAsDeleted)
	return err
}

const rejectReview = `-- name: RejectReview :one
UPDATE event_review_queue
   SET status = 'rejected',
       reviewed_by = $1,
       reviewed_at = NOW(),
       rejection_reason = $2,
       updated_at = NOW()
 WHERE id = $3
   AND status = 'pending'
RETURNING id,
          event_id,
          original_payload,
          normalized_payload,
          warnings,
          source_id,
          source_external_id,
          dedup_hash,
          event_start_time,
          event_end_time,
          status,
          reviewed_by,
          reviewed_at,
          review_notes,
          rejection_reason,
          created_at,
          updated_at
`

type RejectReviewParams struct {
	ReviewedBy pgtype.Text `json:"reviewed_by"`
	Reason     pgtype.Text `json:"reason"`
	ID         int32       `json:"id"`
}

type RejectReviewRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Mark review as rejected
func (q *Queries) RejectReview(ctx context.Context, arg RejectReviewParams) (RejectReviewRow, error) {
	row := q.db.QueryRow(ctx, rejectReview, arg.ReviewedBy, arg.Reason, arg.ID)
	var i RejectReviewRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReviewQueueEntry = `-- name: UpdateReviewQueueEntry :one
UPDATE event_review_queue
   SET original_payload = COALESCE($1, original_payload),
       normalized_payload = COALESCE($2, normalized_payload),
       warnings = COALESCE($3, warnings),
       updated_at = NOW()
 WHERE id = $4
RETURNING id,
          event_id,
          original_payload,
          normalized_payload,
          warnings,
          source_id,
          source_external_id,
          dedup_hash,
          event_start_time,
          event_end_time,
          status,
          reviewed_by,
          reviewed_at,
          review_notes,
          rejection_reason,
          created_at,
          updated_at
`

type UpdateReviewQueueEntryParams struct {
	OriginalPayload   []byte `json:"original_payload"`
	NormalizedPayload []byte `json:"normalized_payload"`
	Warnings          []byte `json:"warnings"`
	ID                int32  `json:"id"`
}

type UpdateReviewQueueEntryRow struct {
	ID                int32              `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	OriginalPayload   []byte             `json:"original_payload"`
	NormalizedPayload []byte             `json:"normalized_payload"`
	Warnings          []byte             `json:"warnings"`
	SourceID          pgtype.Text        `json:"source_id"`
	SourceExternalID  pgtype.Text        `json:"source_external_id"`
	DedupHash         pgtype.Text        `json:"dedup_hash"`
	EventStartTime    pgtype.Timestamptz `json:"event_start_time"`
	EventEndTime      pgtype.Timestamptz `json:"event_end_time"`
	Status            string             `json:"status"`
	ReviewedBy        pgtype.Text        `json:"reviewed_by"`
	ReviewedAt        pgtype.Timestamptz `json:"reviewed_at"`
	ReviewNotes       pgtype.Text        `json:"review_notes"`
	RejectionReason   pgtype.Text        `json:"rejection_reason"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

// Update existing review entry (for resubmissions with same issues)
func (q *Queries) UpdateReviewQueueEntry(ctx context.Context, arg UpdateReviewQueueEntryParams) (UpdateReviewQueueEntryRow, error) {
	row := q.db.QueryRow(ctx, updateReviewQueueEntry,
		arg.OriginalPayload,
		arg.NormalizedPayload,
		arg.Warnings,
		arg.ID,
	)
	var i UpdateReviewQueueEntryRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.OriginalPayload,
		&i.NormalizedPayload,
		&i.Warnings,
		&i.SourceID,
		&i.SourceExternalID,
		&i.DedupHash,
		&i.EventStartTime,
		&i.EventEndTime,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
