#!/usr/bin/env bash
# Togather Server Installation Script
# 
# This is a TEMPLATE file. The actual install.sh is generated during package build.
# Edit this file and rebuild the package to update installation logic.
#
# Generation: deploy/scripts/build-deploy-package.sh embeds this as a heredoc
#
# Features:
# - First-time installation
# - Upgrade existing installation (with data preservation)
# - Automatic database backup before changes
# - Blue-green deployment support
# - Health checks and validation
#
# Exit codes:
#   0 - Success
#   1 - Error (with descriptive message)

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

APP_NAME="togather"
APP_DIR="/opt/${APP_NAME}"
BACKUP_DIR="${APP_DIR}/backups"
SYSTEMD_SERVICE="/etc/systemd/system/${APP_NAME}.service"
BINARY_PATH="/usr/local/bin/${APP_NAME}-server"

# Detect environment (staging/production) from system-wide ENVIRONMENT variable
# Set by provision-server.sh during initial server setup
ENVIRONMENT="${ENVIRONMENT:-staging}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log() {
    echo -e "${BLUE}${1}${NC}"
}

success() {
    echo -e "${GREEN}âœ“ ${1}${NC}"
}

warning() {
    echo -e "${YELLOW}âš ï¸  ${1}${NC}"
}

error_exit() {
    echo -e "${RED}âŒ Installation failed: ${1}${NC}" >&2
    exit 1
}

configure_caddy() {
    log "â†’ Configuring Caddy reverse proxy for ${ENVIRONMENT} environment..."
    
    # Check if Caddy is installed
    if ! command -v caddy &> /dev/null; then
        warning "Caddy not found - skipping Caddy configuration"
        warning "Install Caddy with: sudo apt install caddy"
        return 0
    fi
    
    # Determine which Caddyfile to use based on environment
    local CADDYFILE_SOURCE
    case "$ENVIRONMENT" in
        staging)
            CADDYFILE_SOURCE="${APP_DIR}/deploy/config/environments/Caddyfile.staging"
            ;;
        production)
            CADDYFILE_SOURCE="${APP_DIR}/deploy/config/environments/Caddyfile.production"
            ;;
        *)
            warning "Unknown environment: $ENVIRONMENT - skipping Caddy configuration"
            return 0
            ;;
    esac
    
    # Check if source Caddyfile exists
    if [[ ! -f "$CADDYFILE_SOURCE" ]]; then
        warning "Caddyfile not found at: $CADDYFILE_SOURCE"
        warning "Skipping Caddy configuration"
        return 0
    fi
    
    # Deploy Caddyfile
    log "  â†’ Deploying ${ENVIRONMENT} Caddyfile to /etc/caddy/Caddyfile..."
    cp "$CADDYFILE_SOURCE" /etc/caddy/Caddyfile
    
    # Create log file with correct permissions (prevents "permission denied" errors)
    log "  â†’ Creating Caddy log file..."
    touch "/var/log/caddy/${ENVIRONMENT}.toronto.log"
    chown caddy:caddy "/var/log/caddy/${ENVIRONMENT}.toronto.log"
    chmod 644 "/var/log/caddy/${ENVIRONMENT}.toronto.log"
    success "Log file created: /var/log/caddy/${ENVIRONMENT}.toronto.log"
    
    # Validate Caddyfile
    if caddy validate --config /etc/caddy/Caddyfile 2>&1 | grep -q "Valid"; then
        success "Caddyfile validated successfully"
    else
        warning "Caddyfile validation failed - check /etc/caddy/Caddyfile"
        return 1
    fi
    
    # Reload Caddy (or start if not active)
    log "  â†’ Starting/reloading Caddy service..."
    if systemctl is-active --quiet caddy; then
        # Caddy is running, reload config
        if systemctl reload caddy; then
            success "Caddy configuration reloaded"
        else
            warning "Failed to reload Caddy - attempting restart..."
            systemctl restart caddy && success "Caddy restarted successfully"
        fi
    else
        # Caddy not running, start it
        if systemctl start caddy; then
            success "Caddy started successfully"
        else
            warning "Failed to start Caddy - check systemctl status caddy"
            # Don't return error - let script continue
        fi
    fi
    
    # Always return success - Caddy issues shouldn't block installation
    return 0
}

# ============================================================================
# Pre-flight Checks
# ============================================================================

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘         Togather Server Installation           â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

log "Step 1/8: Pre-flight Checks"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    error_exit "This script must be run as root (use sudo)"
fi

# Detect OS
if [[ -f /etc/os-release ]]; then
    . /etc/os-release
    log "  âœ“ OS detected: ${ID} ${VERSION_ID}"
else
    error_exit "Cannot detect OS (missing /etc/os-release)"
fi

# Check Docker
if ! command -v docker &> /dev/null; then
    error_exit "Docker is not installed. Please install Docker first."
fi
log "  âœ“ Docker found: $(docker --version)"

# Check Docker Compose
if ! docker compose version &> /dev/null; then
    error_exit "Docker Compose v2 is not installed. Please install Docker Compose."
fi
log "  âœ“ Docker Compose found: $(docker compose version)"

# Check for existing installation BEFORE port checks
EXISTING_INSTALL=false
if [[ -f "${APP_DIR}/.env" ]] && [[ -f /usr/local/bin/togather-server ]]; then
    EXISTING_INSTALL=true
    log "  â„¹ï¸  Existing installation detected"
fi

# Check if ports are available
# If existing installation and port in use, stop services first
for PORT in 8080 5433; do
    if sudo lsof -i :$PORT > /dev/null 2>&1; then
        if [[ "$EXISTING_INSTALL" == "true" ]]; then
            log "  â„¹ï¸  Port $PORT is in use (likely by existing Togather installation)"
            
            # Check if systemd service is running
            if systemctl is-active --quiet togather 2>/dev/null; then
                log "  â†’ Stopping existing Togather systemd service..."
                sudo systemctl stop togather || true
            fi
            
            # Check if Docker containers are running (they may survive systemd stop)
            # FIX: Use project name and correct working directory
            if sudo docker ps | grep -q togather 2>/dev/null; then
                log "  â†’ Stopping Docker containers..."
                
                # Try multiple methods to ensure containers stop:
                # Method 1: Use docker compose with project name from labels
                COMPOSE_PROJECT=$(docker inspect togather-db --format '{{index .Config.Labels "com.docker.compose.project"}}' 2>/dev/null || echo "")
                if [[ -n "$COMPOSE_PROJECT" ]] && [[ -d "${APP_DIR}/deploy/docker" ]]; then
                    log "  â†’ Detected Docker Compose project: $COMPOSE_PROJECT"
                    (cd "${APP_DIR}/deploy/docker" && sudo docker compose --env-file ../../.env down) 2>/dev/null || true
                fi
                
                # Method 2: Fallback to direct container stop if compose failed
                if sudo docker ps | grep -q togather 2>/dev/null; then
                    log "  â†’ Docker Compose down failed, stopping containers directly..."
                    sudo docker stop $(sudo docker ps -q --filter "name=togather") 2>/dev/null || true
                fi
            fi
            
            # Wait for ports to free
            sleep 3
            
            # Check if ports are now free
            if ! sudo lsof -i :$PORT > /dev/null 2>&1; then
                log "  âœ“ Port $PORT freed"
            else
                error_exit "Port $PORT still in use after stopping services. Please manually stop processes using this port."
            fi
        else
            error_exit "Port $PORT is in use by another process (not Togather service). Please free this port before installing."
        fi
    else
        log "  âœ“ Port $PORT is available"
    fi
done

echo ""

# ============================================================================
# Installation Mode Detection
# ============================================================================

log "Step 2/8: Installation Mode"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

INSTALL_MODE="new"

if [[ "$EXISTING_INSTALL" == "true" ]]; then
    INSTALL_MODE="upgrade"
    log "  â†’ Mode: UPGRADE (preserving existing data and configuration)"
    
    # Create backup of existing .env
    BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="${APP_DIR}/.env.backup.${BACKUP_TIMESTAMP}"
    
    log "  â†’ Creating backup of existing configuration..."
    cp "${APP_DIR}/.env" "${BACKUP_FILE}"
    success "Configuration backed up to: ${BACKUP_FILE}"
    
    # Create symlink to latest backup
    ln -sf ".env.backup.${BACKUP_TIMESTAMP}" "${APP_DIR}/.env.backup"
    
    # Check if database backup is needed
    if docker volume ls | grep -q togather_postgres_data; then
        log "  â†’ Database volume detected: togather_postgres_data"
        log "  â†’ Creating database backup before upgrade..."
        
        # Create backups directory if it doesn't exist
        mkdir -p "${BACKUP_DIR}"
        
        # Start database if not running (needed for pg_dump)
        if ! docker ps | grep -q togather-db; then
            log "  â†’ Starting database temporarily for backup..."
            cd "${APP_DIR}/deploy/docker"
            docker compose --env-file ../../.env up -d db 2>/dev/null || true
            sleep 5
        fi
        
        # Create database backup using pg_dump inside container
        DB_BACKUP_FILE="${BACKUP_DIR}/db_backup_${BACKUP_TIMESTAMP}.sql"
        BACKUP_SUCCESS=false
        
        if docker exec togather-db pg_dump -U togather togather > "${DB_BACKUP_FILE}" 2>/dev/null; then
            BACKUP_SUCCESS=true
            success "Database backed up to: ${DB_BACKUP_FILE}"
            
            # Compress backup
            gzip "${DB_BACKUP_FILE}"
            success "Backup compressed: ${DB_BACKUP_FILE}.gz"
        else
            warning "Database backup failed (container may not be responding)"
            warning "Continuing installation - manual backup recommended"
        fi
        
        # Keep only last 5 backups
        if [[ "$BACKUP_SUCCESS" == "true" ]]; then
            ls -t "${BACKUP_DIR}"/db_backup_*.sql.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
        fi
    fi
else
    log "  â†’ Mode: NEW INSTALLATION"
fi


# ============================================================================
# Blue-Green Deployment Detection
# ============================================================================

log "Step 2.5/8: Deployment Mode Detection"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

DEPLOYMENT_MODE="simple"
TARGET_SLOT=""
DEPLOYMENT_STATE_FILE="${APP_DIR}/deploy/config/deployment-state.json"

# Check if blue-green infrastructure exists
if [[ -f "$DEPLOYMENT_STATE_FILE" ]]; then
    DEPLOYMENT_MODE="blue-green"
    log "  â†’ Mode: BLUE-GREEN DEPLOYMENT"
    
    # Read active slot from deployment-state.json
    if command -v jq &> /dev/null; then
        ACTIVE_SLOT=$(jq -r '.active_slot' "$DEPLOYMENT_STATE_FILE" 2>/dev/null || echo "blue")
    else
        # Fallback parsing without jq
        ACTIVE_SLOT=$(grep -oP '"active_slot"\s*:\s*"\K[^"]+' "$DEPLOYMENT_STATE_FILE" 2>/dev/null || echo "blue")
    fi
    
    # Determine target slot (opposite of active)
    if [[ "$ACTIVE_SLOT" == "blue" ]]; then
        TARGET_SLOT="green"
    else
        TARGET_SLOT="blue"
    fi
    
    # Set slot-specific service name
    SYSTEMD_SERVICE="/etc/systemd/system/${APP_NAME}-${TARGET_SLOT}.service"
    
    # Set slot-specific port (blue=8080, green=8081)
    if [[ "$TARGET_SLOT" == "blue" ]]; then
        SERVER_PORT=8080
    else
        SERVER_PORT=8081
    fi
    
    success "Active slot: ${ACTIVE_SLOT}"
    success "Target slot: ${TARGET_SLOT} (port ${SERVER_PORT})"
    log "  â†’ Will install to slot: ${TARGET_SLOT}"
    log "  â†’ Service name: ${APP_NAME}-${TARGET_SLOT}"
else
    DEPLOYMENT_MODE="simple"
    log "  â†’ Mode: SIMPLE (single service)"
    log "  â†’ No blue-green infrastructure detected"
    
    # Use traditional single service
    SYSTEMD_SERVICE="/etc/systemd/system/${APP_NAME}.service"
    SERVER_PORT=8080
    
    success "Using traditional single-service deployment"
fi

echo ""
echo ""

# ============================================================================
# Create Application Directory
# ============================================================================

log "Step 3/8: Directory Setup"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Create app directory if it doesn't exist
if [[ ! -d "${APP_DIR}" ]]; then
    mkdir -p "${APP_DIR}"
    success "Created application directory: ${APP_DIR}"
fi

# Create backups directory
mkdir -p "${BACKUP_DIR}"

# Copy files to app directory (preserve existing .env)
log "  â†’ Copying application files..."

# Get the directory where this script is located (the extracted package)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Copy everything except .env
for item in "${SCRIPT_DIR}"/*; do
    basename_item=$(basename "$item")
    if [[ "$basename_item" != "install.sh" ]] && [[ "$basename_item" != ".env" ]]; then
        cp -r "$item" "${APP_DIR}/"
    fi
done

# Handle .env file
if [[ "$INSTALL_MODE" == "new" ]]; then
    if [[ -f "${SCRIPT_DIR}/.env" ]]; then
        cp "${SCRIPT_DIR}/.env" "${APP_DIR}/.env"
        success ".env copied from package"
    elif [[ -f "${SCRIPT_DIR}/.env.example" ]]; then
        cp "${SCRIPT_DIR}/.env.example" "${APP_DIR}/.env"
        warning ".env created from .env.example - UPDATE PASSWORDS AND SECRETS!"
        warning "Edit ${APP_DIR}/.env and change:"
        warning "  - POSTGRES_PASSWORD (used by database)"
        warning "  - JWT_SECRET (min 32 chars)"
        warning "  - CSRF_KEY (exactly 32 chars)"
        warning "  - ADMIN_PASSWORD"
    else
        error_exit ".env.example file not found in package"
    fi
else
    log "  â†’ Preserving existing .env (backed up to .env.backup)"
fi

# Set ownership (deploy user)
if id "deploy" &>/dev/null; then
    chown -R deploy:deploy "${APP_DIR}"
    success "Set ownership to deploy:deploy"
fi

echo ""

# ============================================================================
# Install Binary
# ============================================================================

log "Step 4/8: Install Server Binary"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Copy binary to system location
cp "${APP_DIR}/server" "${BINARY_PATH}"
chmod +x "${BINARY_PATH}"
success "Installed binary to: ${BINARY_PATH}"

# Verify binary works
if ! "${BINARY_PATH}" version &> /dev/null; then
    error_exit "Binary verification failed (server version returned error)"
fi
success "Binary verified"

echo ""

# ============================================================================
# Start Database
# ============================================================================

log "Step 5/8: Start Database"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

cd "${APP_DIR}/deploy/docker"

# Stop any existing containers first (cleanup)
docker compose --env-file ../../.env down 2>/dev/null || true

# Clean old volumes on new install to prevent password mismatch issues
if [[ "$INSTALL_MODE" == "new" ]]; then
    log "  â†’ Cleaning old Docker volumes (new install)..."
    docker volume rm togather-db-data togather-db-snapshots 2>/dev/null || true
    success "Old volumes cleaned"
fi

# Start database
log "  â†’ Starting PostgreSQL database..."
docker compose --env-file ../../.env up -d togather-db

# Wait for database to be healthy
log "  â†’ Waiting for database to be ready..."
for i in {1..30}; do
    if docker compose --env-file ../../.env ps togather-db | grep -q "healthy"; then
        success "Database is ready"
        break
    fi
    if [[ $i -eq 30 ]]; then
        error_exit "Database failed to start within 30 seconds"
    fi
    sleep 1
done

echo ""

# ============================================================================
# Run Migrations
# ============================================================================

log "Step 6/8: Run Database Migrations"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

cd "${APP_DIR}"

# Source .env for DATABASE_URL
set -a
source .env
set +a

log "  â†’ Running schema migrations..."
if ! "${APP_DIR}/migrate" -path "${APP_DIR}/internal/storage/postgres/migrations" -database "$DATABASE_URL" up 2>&1; then
    error_exit "Schema migrations failed"
fi
success "Schema migrations completed"

log "  â†’ Running River job queue migrations..."
if ! "${APP_DIR}/river" migrate-up --database-url "$DATABASE_URL" 2>&1; then
    error_exit "River migrations failed"
fi
success "River migrations completed"

echo ""

# ============================================================================
# Install and Start Systemd Service
# ============================================================================

log "Step 7/8: Install Systemd Service"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Create systemd service file
if [[ "$DEPLOYMENT_MODE" == "blue-green" ]]; then
    # Blue-green mode: include slot information
    cat > "${SYSTEMD_SERVICE}" <<EOF
[Unit]
Description=Togather SEL Server (${TARGET_SLOT} slot)
After=network.target docker.service
Requires=docker.service

[Service]
Type=simple
User=deploy
WorkingDirectory=${APP_DIR}
Environment="SLOT=${TARGET_SLOT}"
Environment="PORT=${SERVER_PORT}"
EnvironmentFile=${APP_DIR}/.env
ExecStart=${BINARY_PATH} serve
Restart=always
RestartSec=5

# Security settings
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF
else
    # Simple mode: traditional single service
    cat > "${SYSTEMD_SERVICE}" <<EOF
[Unit]
Description=Togather SEL Server
After=network.target docker.service
Requires=docker.service

[Service]
Type=simple
User=deploy
WorkingDirectory=${APP_DIR}
EnvironmentFile=${APP_DIR}/.env
ExecStart=${BINARY_PATH} serve
Restart=always
RestartSec=5

# Security settings
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF
fi

success "Created systemd service: ${SYSTEMD_SERVICE}"

# Reload systemd
systemctl daemon-reload
success "Systemd configuration reloaded"

# Enable service (use appropriate service name)
if [[ "$DEPLOYMENT_MODE" == "blue-green" ]]; then
    SERVICE_NAME="${APP_NAME}-${TARGET_SLOT}"
else
    SERVICE_NAME="${APP_NAME}"
fi

systemctl enable "${SERVICE_NAME}"

# Start service
log "  â†’ Starting Togather server..."
systemctl start "${SERVICE_NAME}"

# Wait for service to be active
sleep 3

# Check service status
if systemctl is-active --quiet "${SERVICE_NAME}"; then
    success "Service started successfully"
else
    error_exit "Service failed to start. Check logs with: journalctl -u ${SERVICE_NAME} -f"
fi

# Health check
log "  â†’ Running health check..."
for i in {1..15}; do
    if curl -sf "http://localhost:${SERVER_PORT}/health" > /dev/null 2>&1; then
        success "Health check passed (port ${SERVER_PORT})"
        break
    fi
    if [[ $i -eq 15 ]]; then
        warning "Health check timeout (service may still be starting)"
    fi
    sleep 1
done


# ============================================================================
# Configure Caddy Reverse Proxy
# ============================================================================

log "Step 8/8: Configure Caddy Reverse Proxy"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

log "  â†’ Detected environment: ${ENVIRONMENT}"

# Update SERVER_PORT in .env based on deployment mode
if [[ "$DEPLOYMENT_MODE" == "blue-green" ]]; then
    log "  â†’ Configuring server port for blue-green deployment..."
    if grep -q "^SERVER_PORT=" "${APP_DIR}/.env"; then
        sed -i "s/^SERVER_PORT=.*/SERVER_PORT=${SERVER_PORT}/" "${APP_DIR}/.env"
        success "SERVER_PORT set to ${SERVER_PORT} (${TARGET_SLOT} slot)"
    else
        echo "SERVER_PORT=${SERVER_PORT}" >> "${APP_DIR}/.env"
        success "SERVER_PORT added to .env (${SERVER_PORT} - ${TARGET_SLOT} slot)"
    fi
else
    log "  â†’ Configuring server port for simple deployment..."
    if ! grep -q "^SERVER_PORT=" "${APP_DIR}/.env"; then
        echo "SERVER_PORT=${SERVER_PORT}" >> "${APP_DIR}/.env"
        success "SERVER_PORT added to .env (${SERVER_PORT})"
    fi
fi

# Configure Caddy
configure_caddy

# Restart service to pick up new configuration
log "  â†’ Restarting service to apply configuration..."
systemctl stop "${SERVICE_NAME}"
sleep 2
if systemctl start "${SERVICE_NAME}"; then
    success "Service restarted with port ${SERVER_PORT}"
    
    # Wait for service to be active
    sleep 3
    
    # Health check on configured port
    log "  â†’ Running health check on port ${SERVER_PORT}..."
    for i in {1..15}; do
        if curl -sf "http://localhost:${SERVER_PORT}/health" > /dev/null 2>&1; then
            success "Health check passed on port ${SERVER_PORT}"
            break
        fi
        if [[ $i -eq 15 ]]; then
            warning "Health check timeout on port ${SERVER_PORT} (service may still be starting)"
            warning "Try: sudo systemctl status ${SERVICE_NAME}"
        fi
        sleep 1
    done
else
    error_exit "Failed to restart service with new configuration"
fi

echo ""

# ============================================================================
# Installation Complete
# ============================================================================

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘         Installation Complete! ðŸŽ‰               â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [[ "$INSTALL_MODE" == "upgrade" ]]; then
    echo "Upgrade Summary:"
    echo "  â€¢ Configuration: Preserved (backup at ${BACKUP_FILE})"
    echo "  â€¢ Database: Preserved (backup at ${BACKUP_DIR}/)"
else
    echo "Installation Summary:"
fi

echo "  â€¢ Application directory: ${APP_DIR}"
echo "  â€¢ Binary: ${BINARY_PATH}"
if [[ "$DEPLOYMENT_MODE" == "blue-green" ]]; then
    echo "  â€¢ Service: ${SERVICE_NAME}.service (${TARGET_SLOT} slot on port ${SERVER_PORT})"
    echo "  â€¢ Mode: Blue-Green Deployment"
else
    echo "  â€¢ Service: ${SERVICE_NAME}.service"
    echo "  â€¢ Mode: Simple Deployment"
fi
echo ""

echo "Service Management:"
echo "  â€¢ Status:  sudo systemctl status ${SERVICE_NAME}"
echo "  â€¢ Stop:    sudo systemctl stop ${SERVICE_NAME}"
echo "  â€¢ Start:   sudo systemctl start ${SERVICE_NAME}"
echo "  â€¢ Restart: sudo systemctl restart ${SERVICE_NAME}"
echo "  â€¢ Logs:    sudo journalctl -u ${SERVICE_NAME} -f"
echo ""

echo "Health Check:"
echo "  â€¢ Local:   curl http://localhost:${SERVER_PORT}/health"
if command -v jq &> /dev/null; then
    echo "  â€¢ Pretty:  curl -s http://localhost:${SERVER_PORT}/health | jq"
fi
if command -v caddy &> /dev/null; then
    case "$ENVIRONMENT" in
        staging)
            echo "  â€¢ Staging: curl https://staging.toronto.togather.foundation/health"
            ;;
        production)
            echo "  â€¢ Production: curl https://toronto.togather.foundation/health"
            ;;
    esac
fi
echo ""

echo "Configuration:"
echo "  â€¢ Edit: ${APP_DIR}/.env"
echo "  â€¢ After editing, restart: sudo systemctl restart ${SERVICE_NAME}"
if command -v caddy &> /dev/null; then
    echo "  â€¢ Caddy config: /etc/caddy/Caddyfile"
    echo "  â€¢ Reload Caddy: sudo systemctl reload caddy"
fi
echo ""

if [[ "$INSTALL_MODE" == "upgrade" ]]; then
    echo "Rollback (if needed):"
    echo "  â€¢ Restore config: cp ${BACKUP_FILE} ${APP_DIR}/.env"
    echo "  â€¢ Restart service: sudo systemctl restart ${SERVICE_NAME}"
    echo ""
fi
echo "Next steps:"
if command -v caddy &> /dev/null; then
    echo "  1. Verify DNS points to this server"
    echo "  2. Check HTTPS access works"
    echo "  3. Review logs: sudo journalctl -u togather -f"
    echo "  4. Review Caddy logs: sudo journalctl -u caddy -f"
else
    echo "  1. Install Caddy: sudo apt install caddy"
    echo "  2. Run install.sh again to configure Caddy"
    echo "  3. Set up DNS records"
    echo "  4. Review logs: sudo journalctl -u togather -f"
fi
echo ""

success "Installation complete!"
