#!/usr/bin/env bash
# Togather Server Installation Script
# 
# This is a TEMPLATE file. The actual install.sh is generated during package build.
# Edit this file and rebuild the package to update installation logic.
#
# Generation: deploy/scripts/build-deploy-package.sh embeds this as a heredoc
#
# Features:
# - First-time installation
# - Upgrade existing installation (with data preservation)
# - Automatic database backup before changes
# - Blue-green deployment support
# - Health checks and validation
#
# Exit codes:
#   0 - Success
#   1 - Error (with descriptive message)

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

APP_NAME="togather"
APP_DIR="/opt/${APP_NAME}"
BACKUP_DIR="${APP_DIR}/backups"
SYSTEMD_SERVICE="/etc/systemd/system/${APP_NAME}.service"
BINARY_PATH="/usr/local/bin/${APP_NAME}-server"

# Detect environment (staging/production) from system-wide ENVIRONMENT variable
# Set by provision-server.sh during initial server setup
ENVIRONMENT="${ENVIRONMENT:-staging}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log() {
    echo -e "${BLUE}${1}${NC}"
}

success() {
    echo -e "${GREEN}âœ“ ${1}${NC}"
}

warning() {
    echo -e "${YELLOW}âš ï¸  ${1}${NC}"
}

error_exit() {
    echo -e "${RED}âŒ Installation failed: ${1}${NC}" >&2
    exit 1
}

configure_caddy() {
    log "â†’ Configuring Caddy reverse proxy for ${ENVIRONMENT} environment..."
    
    # Check if Caddy is installed
    if ! command -v caddy &> /dev/null; then
        warning "Caddy not found - skipping Caddy configuration"
        warning "Install Caddy with: sudo apt install caddy"
        return 0
    fi
    
    # Determine which Caddyfile to use based on environment
    local CADDYFILE_SOURCE
    case "$ENVIRONMENT" in
        staging)
            CADDYFILE_SOURCE="${APP_DIR}/deploy/config/environments/Caddyfile.staging"
            ;;
        production)
            CADDYFILE_SOURCE="${APP_DIR}/deploy/config/environments/Caddyfile.production"
            ;;
        *)
            warning "Unknown environment: $ENVIRONMENT - skipping Caddy configuration"
            return 0
            ;;
    esac
    
    # Check if source Caddyfile exists
    if [[ ! -f "$CADDYFILE_SOURCE" ]]; then
        warning "Caddyfile not found at: $CADDYFILE_SOURCE"
        warning "Skipping Caddy configuration"
        return 0
    fi
    
    # Deploy Caddyfile
    log "  â†’ Deploying ${ENVIRONMENT} Caddyfile to /etc/caddy/Caddyfile..."
    cp "$CADDYFILE_SOURCE" /etc/caddy/Caddyfile
    
    # Validate Caddyfile
    if caddy validate --config /etc/caddy/Caddyfile 2>&1 | grep -q "Valid"; then
        success "Caddyfile validated successfully"
    else
        warning "Caddyfile validation failed - check /etc/caddy/Caddyfile"
        return 1
    fi
    
    # Reload Caddy
    log "  â†’ Reloading Caddy service..."
    if systemctl reload caddy; then
        success "Caddy configured and reloaded for ${ENVIRONMENT}"
    else
        warning "Failed to reload Caddy - you may need to restart it manually"
        return 1
    fi
    
    return 0
}

# ============================================================================
# Pre-flight Checks
# ============================================================================

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘         Togather Server Installation           â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

log "Step 1/8: Pre-flight Checks"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Check if running as root
if [[ $EUID -ne 0 ]]; then
    error_exit "This script must be run as root (use sudo)"
fi

# Detect OS
if [[ -f /etc/os-release ]]; then
    . /etc/os-release
    log "  âœ“ OS detected: ${ID} ${VERSION_ID}"
else
    error_exit "Cannot detect OS (missing /etc/os-release)"
fi

# Check Docker
if ! command -v docker &> /dev/null; then
    error_exit "Docker is not installed. Please install Docker first."
fi
log "  âœ“ Docker found: $(docker --version)"

# Check Docker Compose
if ! docker compose version &> /dev/null; then
    error_exit "Docker Compose v2 is not installed. Please install Docker Compose."
fi
log "  âœ“ Docker Compose found: $(docker compose version)"

# Check for existing installation BEFORE port checks
EXISTING_INSTALL=false
if [[ -f "${APP_DIR}/.env" ]] && [[ -f /usr/local/bin/togather-server ]]; then
    EXISTING_INSTALL=true
    log "  â„¹ï¸  Existing installation detected"
fi

# Check if ports are available
# If existing installation and port in use, stop services first
for PORT in 8080 5433; do
    if sudo lsof -i :$PORT > /dev/null 2>&1; then
        if [[ "$EXISTING_INSTALL" == "true" ]]; then
            log "  â„¹ï¸  Port $PORT is in use (likely by existing Togather installation)"
            
            # Check if systemd service is running
            if systemctl is-active --quiet togather 2>/dev/null; then
                log "  â†’ Stopping existing Togather systemd service..."
                sudo systemctl stop togather || true
            fi
            
            # Check if Docker containers are running (they may survive systemd stop)
            # FIX: Use project name and correct working directory
            if sudo docker ps | grep -q togather 2>/dev/null; then
                log "  â†’ Stopping Docker containers..."
                
                # Try multiple methods to ensure containers stop:
                # Method 1: Use docker compose with project name from labels
                COMPOSE_PROJECT=$(docker inspect togather-db --format '{{index .Config.Labels "com.docker.compose.project"}}' 2>/dev/null || echo "")
                if [[ -n "$COMPOSE_PROJECT" ]] && [[ -d "${APP_DIR}/deploy/docker" ]]; then
                    log "  â†’ Detected Docker Compose project: $COMPOSE_PROJECT"
                    (cd "${APP_DIR}/deploy/docker" && sudo docker compose --env-file ../../.env down) 2>/dev/null || true
                fi
                
                # Method 2: Fallback to direct container stop if compose failed
                if sudo docker ps | grep -q togather 2>/dev/null; then
                    log "  â†’ Docker Compose down failed, stopping containers directly..."
                    sudo docker stop $(sudo docker ps -q --filter "name=togather") 2>/dev/null || true
                fi
            fi
            
            # Wait for ports to free
            sleep 3
            
            # Check if ports are now free
            if ! sudo lsof -i :$PORT > /dev/null 2>&1; then
                log "  âœ“ Port $PORT freed"
            else
                error_exit "Port $PORT still in use after stopping services. Please manually stop processes using this port."
            fi
        else
            error_exit "Port $PORT is in use by another process (not Togather service). Please free this port before installing."
        fi
    else
        log "  âœ“ Port $PORT is available"
    fi
done

echo ""

# ============================================================================
# Installation Mode Detection
# ============================================================================

log "Step 2/8: Installation Mode"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

INSTALL_MODE="new"

if [[ "$EXISTING_INSTALL" == "true" ]]; then
    INSTALL_MODE="upgrade"
    log "  â†’ Mode: UPGRADE (preserving existing data and configuration)"
    
    # Create backup of existing .env
    BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_FILE="${APP_DIR}/.env.backup.${BACKUP_TIMESTAMP}"
    
    log "  â†’ Creating backup of existing configuration..."
    cp "${APP_DIR}/.env" "${BACKUP_FILE}"
    success "Configuration backed up to: ${BACKUP_FILE}"
    
    # Create symlink to latest backup
    ln -sf ".env.backup.${BACKUP_TIMESTAMP}" "${APP_DIR}/.env.backup"
    
    # Check if database backup is needed
    if docker volume ls | grep -q togather_postgres_data; then
        log "  â†’ Database volume detected: togather_postgres_data"
        log "  â†’ Creating database backup before upgrade..."
        
        # Create backups directory if it doesn't exist
        mkdir -p "${BACKUP_DIR}"
        
        # Start database if not running (needed for pg_dump)
        if ! docker ps | grep -q togather-db; then
            log "  â†’ Starting database temporarily for backup..."
            cd "${APP_DIR}/deploy/docker"
            docker compose --env-file ../../.env up -d db 2>/dev/null || true
            sleep 5
        fi
        
        # Create database backup using pg_dump inside container
        DB_BACKUP_FILE="${BACKUP_DIR}/db_backup_${BACKUP_TIMESTAMP}.sql"
        BACKUP_SUCCESS=false
        
        if docker exec togather-db pg_dump -U togather togather > "${DB_BACKUP_FILE}" 2>/dev/null; then
            BACKUP_SUCCESS=true
            success "Database backed up to: ${DB_BACKUP_FILE}"
            
            # Compress backup
            gzip "${DB_BACKUP_FILE}"
            success "Backup compressed: ${DB_BACKUP_FILE}.gz"
        else
            warning "Database backup failed (container may not be responding)"
            warning "Continuing installation - manual backup recommended"
        fi
        
        # Keep only last 5 backups
        if [[ "$BACKUP_SUCCESS" == "true" ]]; then
            ls -t "${BACKUP_DIR}"/db_backup_*.sql.gz 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
        fi
    fi
else
    log "  â†’ Mode: NEW INSTALLATION"
fi

echo ""

# ============================================================================
# Create Application Directory
# ============================================================================

log "Step 3/8: Directory Setup"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Create app directory if it doesn't exist
if [[ ! -d "${APP_DIR}" ]]; then
    mkdir -p "${APP_DIR}"
    success "Created application directory: ${APP_DIR}"
fi

# Create backups directory
mkdir -p "${BACKUP_DIR}"

# Copy files to app directory (preserve existing .env)
log "  â†’ Copying application files..."

# Get the directory where this script is located (the extracted package)
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Copy everything except .env
for item in "${SCRIPT_DIR}"/*; do
    basename_item=$(basename "$item")
    if [[ "$basename_item" != "install.sh" ]] && [[ "$basename_item" != ".env" ]]; then
        cp -r "$item" "${APP_DIR}/"
    fi
done

# Handle .env file
if [[ "$INSTALL_MODE" == "new" ]]; then
    if [[ -f "${SCRIPT_DIR}/.env" ]]; then
        cp "${SCRIPT_DIR}/.env" "${APP_DIR}/.env"
        success ".env copied from package"
    else
        error_exit ".env file not found in package"
    fi
else
    log "  â†’ Preserving existing .env (backed up to .env.backup)"
fi

# Set ownership (deploy user)
if id "deploy" &>/dev/null; then
    chown -R deploy:deploy "${APP_DIR}"
    success "Set ownership to deploy:deploy"
fi

echo ""

# ============================================================================
# Install Binary
# ============================================================================

log "Step 4/8: Install Server Binary"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Copy binary to system location
cp "${APP_DIR}/server" "${BINARY_PATH}"
chmod +x "${BINARY_PATH}"
success "Installed binary to: ${BINARY_PATH}"

# Verify binary works
if ! "${BINARY_PATH}" --version &> /dev/null; then
    error_exit "Binary verification failed (server --version returned error)"
fi
success "Binary verified"

echo ""

# ============================================================================
# Start Database
# ============================================================================

log "Step 5/8: Start Database"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

cd "${APP_DIR}/deploy/docker"

# Stop any existing containers first (cleanup)
docker compose --env-file ../../.env down 2>/dev/null || true

# Start database
log "  â†’ Starting PostgreSQL database..."
docker compose --env-file ../../.env up -d db

# Wait for database to be healthy
log "  â†’ Waiting for database to be ready..."
for i in {1..30}; do
    if docker compose --env-file ../../.env ps db | grep -q "healthy"; then
        success "Database is ready"
        break
    fi
    if [[ $i -eq 30 ]]; then
        error_exit "Database failed to start within 30 seconds"
    fi
    sleep 1
done

echo ""

# ============================================================================
# Run Migrations
# ============================================================================

log "Step 6/8: Run Database Migrations"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

cd "${APP_DIR}"

# Source .env for DATABASE_URL
set -a
source .env
set +a

log "  â†’ Running schema migrations..."
if ! "${BINARY_PATH}" migrate up 2>&1; then
    error_exit "Schema migrations failed"
fi
success "Schema migrations completed"

log "  â†’ Running River job queue migrations..."
if ! "${BINARY_PATH}" migrate river 2>&1; then
    error_exit "River migrations failed"
fi
success "River migrations completed"

echo ""

# ============================================================================
# Install and Start Systemd Service
# ============================================================================

log "Step 7/8: Install Systemd Service"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Create systemd service file
cat > "${SYSTEMD_SERVICE}" <<EOF
[Unit]
Description=Togather SEL Server
After=network.target docker.service
Requires=docker.service

[Service]
Type=simple
User=deploy
WorkingDirectory=${APP_DIR}
EnvironmentFile=${APP_DIR}/.env
ExecStart=${BINARY_PATH} serve
Restart=always
RestartSec=5

# Security settings
NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target
EOF

success "Created systemd service: ${SYSTEMD_SERVICE}"

# Reload systemd
systemctl daemon-reload
success "Systemd configuration reloaded"

# Enable service
systemctl enable togather
success "Service enabled (will start on boot)"

# Start service
log "  â†’ Starting Togather server..."
systemctl start togather

# Wait for service to be active
sleep 3

# Check service status
if systemctl is-active --quiet togather; then
    success "Service started successfully"
else
    error_exit "Service failed to start. Check logs with: journalctl -u togather -f"
fi

# Health check
log "  â†’ Running health check..."
for i in {1..15}; do
    if curl -sf http://localhost:8080/health > /dev/null 2>&1; then
        success "Health check passed"
        break
    fi
    if [[ $i -eq 15 ]]; then
        warning "Health check timeout (service may still be starting)"
    fi
    sleep 1
done

echo ""

# ============================================================================
# Configure Caddy Reverse Proxy
# ============================================================================

log "Step 8/8: Configure Caddy Reverse Proxy"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

log "  â†’ Detected environment: ${ENVIRONMENT}"

# Update SERVER_PORT in .env for blue-green deployment (8081 for blue slot)
log "  â†’ Configuring server port for reverse proxy..."
if grep -q "^SERVER_PORT=" "${APP_DIR}/.env"; then
    sed -i 's/^SERVER_PORT=.*/SERVER_PORT=8081/' "${APP_DIR}/.env"
    success "SERVER_PORT set to 8081 (blue slot)"
else
    echo "SERVER_PORT=8081" >> "${APP_DIR}/.env"
    success "SERVER_PORT added to .env (8081 - blue slot)"
fi

# Configure Caddy
configure_caddy

# Restart service to pick up new port
if systemctl restart togather; then
    success "Service restarted with new configuration"
    
    # Wait for service to be active
    sleep 3
    
    # Health check on new port
    log "  â†’ Running health check on port 8081..."
    for i in {1..15}; do
        if curl -sf http://localhost:8081/health > /dev/null 2>&1; then
            success "Health check passed on port 8081"
            break
        fi
        if [[ $i -eq 15 ]]; then
            warning "Health check timeout on port 8081 (service may still be starting)"
        fi
        sleep 1
    done
else
    warning "Failed to restart service - check configuration"
fi

echo ""

# ============================================================================
# Installation Complete
# ============================================================================

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘         Installation Complete! ðŸŽ‰               â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [[ "$INSTALL_MODE" == "upgrade" ]]; then
    echo "Upgrade Summary:"
    echo "  â€¢ Configuration: Preserved (backup at ${BACKUP_FILE})"
    echo "  â€¢ Database: Preserved (backup at ${BACKUP_DIR}/)"
else
    echo "Installation Summary:"
fi

echo "  â€¢ Application directory: ${APP_DIR}"
echo "  â€¢ Binary: ${BINARY_PATH}"
echo "  â€¢ Service: togather.service"
echo ""

echo "Service Management:"
echo "  â€¢ Status:  sudo systemctl status togather"
echo "  â€¢ Stop:    sudo systemctl stop togather"
echo "  â€¢ Start:   sudo systemctl start togather"
echo "  â€¢ Restart: sudo systemctl restart togather"
echo "  â€¢ Logs:    sudo journalctl -u togather -f"
echo ""

echo "Health Check:"
echo "  â€¢ Local:   curl http://localhost:8081/health"
if command -v jq &> /dev/null; then
    echo "  â€¢ Pretty:  curl -s http://localhost:8081/health | jq"
fi
if command -v caddy &> /dev/null; then
    case "$ENVIRONMENT" in
        staging)
            echo "  â€¢ Staging: curl https://staging.toronto.togather.foundation/health"
            ;;
        production)
            echo "  â€¢ Production: curl https://toronto.togather.foundation/health"
            ;;
    esac
fi
echo ""

echo "Configuration:"
echo "  â€¢ Edit: ${APP_DIR}/.env"
echo "  â€¢ After editing, restart: sudo systemctl restart togather"
if command -v caddy &> /dev/null; then
    echo "  â€¢ Caddy config: /etc/caddy/Caddyfile"
    echo "  â€¢ Reload Caddy: sudo systemctl reload caddy"
fi
echo ""

if [[ "$INSTALL_MODE" == "upgrade" ]]; then
    echo "Rollback (if needed):"
    echo "  â€¢ Restore config: cp ${BACKUP_FILE} ${APP_DIR}/.env"
    echo "  â€¢ Restart service: sudo systemctl restart togather"
    echo ""
fi

echo "Next steps:"
if command -v caddy &> /dev/null; then
    echo "  1. Verify DNS points to this server"
    echo "  2. Check HTTPS access works"
    echo "  3. Review logs: sudo journalctl -u togather -f"
    echo "  4. Review Caddy logs: sudo journalctl -u caddy -f"
else
    echo "  1. Install Caddy: sudo apt install caddy"
    echo "  2. Run install.sh again to configure Caddy"
    echo "  3. Set up DNS records"
    echo "  4. Review logs: sudo journalctl -u togather -f"
fi
echo ""

success "Installation complete!"
